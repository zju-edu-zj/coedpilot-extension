{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask> from abc import ABC, abstractmethod\n <mask> import numbers\n <mask> \n <mask> import numpy as np\n <mask> \n <mask> from manimlib.constants import BLACK, BLUE, BLUE_D, BLUE_E, GREEN, GREY_A, WHITE, RED\n <mask> from manimlib.constants import DEGREES, PI\n <mask> from manimlib.constants import DL, UL, DOWN, DR, LEFT, ORIGIN, OUT, RIGHT, UP </s> remove from manimlib.constants import BLACK, BLUE, BLUE_D, GREEN, GREY_A, WHITE, RED </s> add from manimlib.constants import BLACK, BLUE, BLUE_D, BLUE_E, GREEN, GREY_A, WHITE, RED", "html_url": "https://github.com/3b1b/manim/commit/004b7427f513da7292617f15b9f77f9e6cb48d63", "file_name": "manimlib/mobject/coordinate_systems.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> import numbers\n <mask> \n <mask> import numpy as np\n <mask> \n <mask> from manimlib.constants import BLACK, BLUE, BLUE_D, GREEN, GREY_A, WHITE, RED\n <mask> from manimlib.constants import DEGREES, PI\n <mask> from manimlib.constants import DL, UL, DOWN, DR, LEFT, ORIGIN, OUT, RIGHT, UP\n <mask> from manimlib.constants import FRAME_HEIGHT, FRAME_WIDTH\n <mask> from manimlib.constants import FRAME_X_RADIUS, FRAME_Y_RADIUS\n <mask> from manimlib.constants import MED_SMALL_BUFF, SMALL_BUFF\n </s> Allow bound graphs to track discontinuities </s> remove from manimlib.mobject.types.vectorized_mobject import VGroup\n </s> add  </s> add import itertools as it", "html_url": "https://github.com/3b1b/manim/commit/004b7427f513da7292617f15b9f77f9e6cb48d63", "file_name": "manimlib/mobject/coordinate_systems.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.mobject.geometry import Line\n <mask> from manimlib.mobject.geometry import Rectangle\n <mask> from manimlib.mobject.number_line import NumberLine\n <mask> from manimlib.mobject.svg.tex_mobject import Tex\n <mask> from manimlib.mobject.types.vectorized_mobject import VGroup\n <mask> from manimlib.mobject.types.dot_cloud import DotCloud\n <mask> from manimlib.utils.config_ops import digest_config\n <mask> from manimlib.utils.config_ops import merge_dicts_recursively\n <mask> from manimlib.utils.simple_functions import binary_search\n <mask> from manimlib.utils.space_ops import angle_of_vector\n </s> Allow bound graphs to track discontinuities </s> add import itertools as it </s> remove from manimlib.constants import BLACK, BLUE, BLUE_D, GREEN, GREY_A, WHITE, RED\n </s> add from manimlib.constants import BLACK, BLUE, BLUE_D, BLUE_E, GREEN, GREY_A, WHITE, RED", "html_url": "https://github.com/3b1b/manim/commit/004b7427f513da7292617f15b9f77f9e6cb48d63", "file_name": "manimlib/mobject/coordinate_systems.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"\"\"\n <mask>         mobjects, continual_animations = self.separate_mobjects_and_continual_animations(\n <mask>             mobjects_or_continual_animations\n <mask>         )\n <mask>         self.remove(*mobjects_or_continual_animations)\n <mask>         self.mobjects += mobjects\n <mask>         self.continual_animations += continual_animations\n <mask>         return self\n <mask> \n <mask>     def add_mobjects_among(self, values): </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\") </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ): </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False)", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep add keep keep keep keep", "code_tokens": " <mask> \n <mask>         to_remove = self.camera.extract_mobject_family_members(mobjects)\n <mask> \n <mask>         self.continual_animations = filter(\n <mask>             lambda ca : ca not in continual_animations and \\\n <mask>                         ca.mobject not in to_remove, </s> Fixed bug associated with continual_animations being removed accidentally </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ): </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\")", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>             mobjects_or_continual_animations\n <mask>         )\n <mask>         to_remove = self.camera.extract_mobject_family_members(mobjects)\n <mask> \n <mask>         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n <mask>         self.foreground_mobjects = self.get_restructured_mobject_list(\n <mask>             self.foreground_mobjects, to_remove\n <mask>         )\n <mask>         self.continual_animations = filter(\n <mask>             lambda ca : ca not in continual_animations and \\\n <mask>                         ca.mobject not in to_remove,\n <mask>             self.continual_animations\n <mask>         ) </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False) </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\") </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ):", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             self.continual_animations\n <mask>         )\n <mask>         return self\n <mask> \n <mask>     def get_restructured_mobject_list(self, mobjects, to_remove):\n <mask>         \"\"\"\n <mask>         In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\n <mask>         of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\n <mask>         will be editing to contain other submobjects, but not m1, e.g. it will now\n <mask>         insert m2 and m3 to where the group once was. </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\") </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False)", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep add keep keep keep keep keep keep", "code_tokens": " <mask>         insert m2 and m3 to where the group once was.\n <mask>         \"\"\"\n <mask>         new_mobjects = []\n <mask>         def add_safe_mobjects_from_list(list_to_examine, set_to_remove):\n <mask>             for mob in list_to_examine:\n <mask>                 if mob in set_to_remove:\n <mask>                     continue\n <mask>                 intersect = set_to_remove.intersection(mob.submobject_family()) </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ): </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False) </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\")", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def add_foreground_mobject(self, mobject):\n <mask>         return self.add_foreground_mobjects(mobject)\n <mask> \n <mask>     def remove_foreground_mobjects(self, *mobjects):\n <mask>         self.foreground_mobjects = self.get_restructured_mobject_list(\n <mask>             self.foreground_mobjects, \n <mask>             self.camera.extract_mobject_family_members(mobjects)\n <mask>         )\n <mask>         return self\n <mask> \n <mask>     def remove_foreground_mobject(self, mobject):\n <mask>         return self.remove_foreground_mobjects(mobject)\n <mask>  </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ): </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False)", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         result = self.modify_special_strings(result)\n <mask>         return result\n <mask> \n <mask>     def modify_special_strings(self, tex):\n <mask>         tex = self.remove_stray_braces(tex)\n <mask>         should_add_filler = reduce(op.or_, [\n <mask>             # Fraction line needs something to be over\n <mask>             tex == \"\\\\over\",\n <mask>             tex == \"\\\\overline\",\n <mask>             # Makesure sqrt has overbar </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex): </s> add         tex = self.balance_braces(tex) </s> remove             num_submobs = len(sub_tex_mob.submobjects) </s> add             num_submobs = len(sub_tex_mob)\n            if num_submobs == 0:\n                continue </s> remove         num_lefts, num_rights = [\n            tex.count(char)\n            for char in \"{}\"\n        ] </s> add             sub_tex_mob.set_submobjects(self[curr_index:new_index])", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>             tex == \"\\\\overline\",\n <mask>             # Makesure sqrt has overbar\n <mask>             tex == \"\\\\sqrt\",\n <mask>             # Need to add blank subscript or superscript\n <mask>             tex.endswith(\"_\"),\n <mask>             tex.endswith(\"^\"),\n <mask>             tex.endswith(\"dot\"), </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = tex.strip() </s> remove             num_submobs = len(sub_tex_mob.submobjects) </s> add             num_submobs = len(sub_tex_mob)\n            if num_submobs == 0:\n                continue </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex): </s> add         tex = self.balance_braces(tex)", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask>         # To keep files from starting with a line break\n <mask>         if tex.startswith(\"\\\\\\\\\"):\n <mask>             tex = tex.replace(\"\\\\\\\\\", \"\\\\quad\\\\\\\\\")\n <mask> \n <mask>         # Handle imbalanced \\left and \\right\n <mask>         num_lefts, num_rights = [\n <mask>             len([\n <mask>                 s for s in tex.split(substr)[1:] </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex): </s> remove         num_lefts, num_rights = [\n            tex.count(char)\n            for char in \"{}\"\n        ] </s> add         num_lefts, num_rights = [tex.count(char) for char in \"{}\"] </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = tex.strip() </s> remove             num_submobs = len(sub_tex_mob.submobjects) </s> add             num_submobs = len(sub_tex_mob)\n            if num_submobs == 0:\n                continue", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep replace keep keep keep replace replace replace replace keep keep keep", "code_tokens": " <mask>         return tex\n <mask> \n <mask>     def remove_stray_braces(self, tex):\n <mask>         \"\"\"\n <mask>         Makes TexMobject resiliant to unmatched { at start\n <mask>         \"\"\"\n <mask>         num_lefts, num_rights = [\n <mask>             tex.count(char)\n <mask>             for char in \"{}\"\n <mask>         ]\n <mask>         while num_rights > num_lefts:\n <mask>             tex = \"{\" + tex\n <mask>             num_lefts += 1 </s> add         tex = self.balance_braces(tex) </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = tex.strip()", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep replace keep keep", "code_tokens": " <mask> \n <mask> class TexMobject(SingleStringTexMobject):\n <mask>     CONFIG = {\n <mask>         \"arg_separator\": \" \",\n <mask>         # Note, use of substrings_to_isolate is largely rendered\n <mask>         # moot by the fact that you can surround such strings in\n <mask>         # {{ and }} as needed.\n <mask>         \"substrings_to_isolate\": [],\n <mask>         \"tex_to_color_map\": {},\n <mask>     } </s> Rename substrings_to_isolate to simply isolate, and fix a bug associated with rendering sqrt{ </s> remove         # Separate out any strings specified in the substrings_to_isolate </s> add         # Separate out any strings specified in the isolate </s> remove         for ss in it.chain(self.substrings_to_isolate, self.tex_to_color_map.keys()): </s> add         for ss in it.chain(self.isolate, self.tex_to_color_map.keys()): </s> add         tex = self.balance_braces(tex) </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex): </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = tex.strip()", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep replace keep replace keep", "code_tokens": " <mask>             if len(tex_string) == 0:\n <mask>                 continue\n <mask>             sub_tex_mob = SingleStringTexMobject(tex_string, **config)\n <mask>             num_submobs = len(sub_tex_mob.submobjects)\n <mask>             new_index = curr_index + num_submobs\n <mask>             sub_tex_mob.set_submobjects(self.submobjects[curr_index:new_index])\n <mask>             new_submobjects.append(sub_tex_mob) </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = self.balance_braces(tex) </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex):", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>                 radius = self.dot_radius,\n <mask>             )\n <mask>             dot.r_squared = r_squared\n <mask>             self.lattice_points.add(dot)\n <mask>         self.lattice_points.sort_submobjects(np.linalg.norm)\n <mask> \n <mask>     def get_circle(self, radius = None, color = None):\n <mask>         if radius is None:\n <mask>             radius = self.max_lattice_point_radius\n <mask>         if color is None: </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> add         for dot in dots:\n            dot.add(Line(\n                self.plane_center,\n                dot.get_center(),\n                color = dot.get_color()\n            )) </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ]))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask>         r_squared = int(np.round(radius**2))\n <mask>         root_label = TexMobject(\"\\\\sqrt{%d}\"%r_squared)\n <mask>         root_label.add_background_rectangle()\n <mask>         root_label.next_to(radial_line, DOWN, SMALL_BUFF)\n <mask> \n <mask>         return radial_line, root_label\n <mask> \n <mask>     def get_lattice_points_on_r_squared_circle(self, r_squared):\n <mask>         points = VGroup(*filter( </s> add         self.lattice_points.sort_submobjects(\n            lambda p : np.linalg.norm(p - self.plane_center)\n        ) </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit() </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         new_point = point-self.get_center() </s> add         new_point = point-self.axes.get_center() </s> remove         self.plane.scale(self.plane_scale_factor) </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3)", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> class IntroduceComplexConjugate(LatticePointScene):\n <mask>     CONFIG = {\n <mask>         \"y_radius\" : 20,\n <mask>         \"x_radius\" : 30,\n <mask>         \"plane_scale_factor\" : 2,\n <mask>         \"example_coords\" : (3, 4),\n <mask>         \"x_color\" : GREEN,\n <mask>         \"y_color\" : RED,\n <mask>     }\n <mask>     def construct(self): </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         self.lattice_points.sort_submobjects(np.linalg.norm) </s> add         self.lattice_points.sort_submobjects(\n            lambda p : np.linalg.norm(p - self.plane_center)\n        ) </s> remove         self.plane.scale(self.plane_scale_factor) </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         \"x_color\" : GREEN,\n <mask>         \"y_color\" : RED,\n <mask>     }\n <mask>     def construct(self):\n <mask>         self.force_skipping()\n <mask> \n <mask>         self.resize_plane()\n <mask>         self.write_points_with_complex_coords()\n <mask>         self.introduce_complex_conjugate()\n <mask>         self.show_confusion()\n <mask>         self.expand_algebraically() </s> add         \"plane_scale_factor\" : 1.7,\n        \"plane_center\" : 2*LEFT, </s> remove         self.plane.scale(self.plane_scale_factor) </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3) </s> add         self.lattice_points.sort_submobjects(\n            lambda p : np.linalg.norm(p - self.plane_center)\n        ) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         self.expand_algebraically()\n <mask>         self.show_geometrically()\n <mask> \n <mask>     def resize_plane(self):\n <mask>         self.plane.scale(self.plane_scale_factor)\n <mask> \n <mask>     def write_points_with_complex_coords(self):\n <mask>         x, y = self.example_coords\n <mask>         x_color = self.x_color\n <mask>         y_color = self.y_color </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit() </s> remove         new_point = point-self.get_center() </s> add         new_point = point-self.axes.get_center()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         for label in tuple_label, complex_label:\n <mask>             label.add_background_rectangle()\n <mask>             label.next_to(dot, UP+RIGHT, buff = 0)\n <mask> \n <mask>         y_range = range(-8, 10, 2)\n <mask>         ticks = VGroup(*[\n <mask>             Line(\n <mask>                 ORIGIN, MED_SMALL_BUFF*RIGHT\n <mask>             ).move_to(self.plane.coords_to_point(0, y))\n <mask>             for y in y_range </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> add         for dot in dots:\n            dot.add(Line(\n                self.plane_center,\n                dot.get_center(),\n                color = dot.get_color()\n            ))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def introduce_complex_conjugate(self):\n <mask>         x, y = self.example_coords\n <mask>         equation = VGroup(\n <mask>             TexMobject(str(x), \"^2\", \"+\", str(y), \"^2\", \"=\"),\n <mask>             TexMobject(\"(\", str(x), \"+\", str(y), \"i\", \")\"),\n <mask>             TexMobject(\"(\", str(x), \"-\", str(y), \"i\", \")\"),\n <mask>         )\n <mask>         equation.arrange_submobjects(\n <mask>             RIGHT, buff = SMALL_BUFF, </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> add         VGroup(*equation[-2:]).shift(0.5*SMALL_BUFF*DOWN) </s> add         self.conjugate_label = VGroup(brace, conjugate_words)\n        self.equation = equation\n        self.conjugate_dot = dot </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep add keep keep keep keep keep keep", "code_tokens": " <mask>             RIGHT, buff = SMALL_BUFF,\n <mask>         )\n <mask>         equation.scale(0.9)\n <mask>         equation.to_corner(UP+RIGHT, buff = MED_SMALL_BUFF)\n <mask>         for tex_mob in equation:\n <mask>             tex_mob.highlight_by_tex(str(x), self.x_color)\n <mask>             tex_mob.highlight_by_tex(str(y), self.y_color)\n <mask>             tex_mob.add_background_rectangle() </s> Up to introduction of factorization in leibniz </s> remove         pass </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> add             TexMobject(\"25 = \", str(x), \"^2\", \"+\", str(y), \"^2\", \"=\"), </s> remove         pass </s> remove         self.revert_to_original_skipping_status()\n        for part in equation:\n            self.play(FadeIn(part))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         conjugate_words.scale(0.8)\n <mask>         conjugate_words.add_background_rectangle()\n <mask>         conjugate_words.next_to(brace, DOWN)\n <mask> \n <mask>         self.revert_to_original_skipping_status()\n <mask>         for part in equation:\n <mask>             self.play(FadeIn(part))\n <mask>         self.dither(2)\n <mask>         self.play(\n <mask>             GrowFromCenter(brace),\n <mask>             Write(conjugate_words, run_time = 2)\n <mask>         ) </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         y_range = range(-8, 10, 2) </s> add         y_range = range(-9, 10, 3) </s> add         for dot in dots:\n            dot.add(Line(\n                self.plane_center,\n                dot.get_center(),\n                color = dot.get_color()\n            )) </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> add         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n        morty = Mortimer().to_edge(DOWN)\n        randy.make_eye_contact(morty)\n\n        self.play(*map(FadeIn, [randy, morty]))\n        self.play(PiCreatureSays(\n            randy, \"Wait \\\\dots why?\",\n            target_mode = \"confused\",\n        ))\n        self.play(Blink(randy))\n        self.dither(2)\n        self.play(\n            RemovePiCreatureBubble(\n                randy, target_mode = \"erm\",\n            ),\n            PiCreatureSays(\n                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n                target_mode = \"hooray\",\n                bubble_kwargs = {\"width\" : 5, \"height\" : 3}\n            )\n        )\n        self.play(\n            morty.look_at, self.equation,\n            randy.look_at, self.equation,\n        )\n        self.play(Blink(morty))\n        self.play(randy.change_mode, \"pondering\")\n        self.play(RemovePiCreatureBubble(morty))\n        self.play(*map(FadeOut, [randy, morty]))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>             ]\n <mask>         ])\n <mask>         self.dither(2)\n <mask> \n <mask>     def show_confusion(self):\n <mask>         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n <mask>         morty = Mortimer().to_edge(DOWN)\n <mask>         randy.make_eye_contact(morty)\n <mask> \n <mask>         self.play(*map(FadeIn, [randy, morty])) </s> add         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n        morty = Mortimer().to_edge(DOWN)\n        randy.make_eye_contact(morty)\n\n        self.play(*map(FadeIn, [randy, morty]))\n        self.play(PiCreatureSays(\n            randy, \"Wait \\\\dots why?\",\n            target_mode = \"confused\",\n        ))\n        self.play(Blink(randy))\n        self.dither(2)\n        self.play(\n            RemovePiCreatureBubble(\n                randy, target_mode = \"erm\",\n            ),\n            PiCreatureSays(\n                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n                target_mode = \"hooray\",\n                bubble_kwargs = {\"width\" : 5, \"height\" : 3}\n            )\n        )\n        self.play(\n            morty.look_at, self.equation,\n            randy.look_at, self.equation,\n        )\n        self.play(Blink(morty))\n        self.play(randy.change_mode, \"pondering\")\n        self.play(RemovePiCreatureBubble(morty))\n        self.play(*map(FadeOut, [randy, morty])) </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         self.revert_to_original_skipping_status()\n        for part in equation:\n            self.play(FadeIn(part))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     def expand_algebraically(self):\n <mask>         pass\n <mask> \n <mask>     def show_geometrically(self):\n <mask>         pass\n <mask> \n <mask>         \n <mask> \n <mask> \n <mask>  </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ]))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask>         alt_factorization.add_background_rectangle()\n <mask>         \n <mask> \n <mask>         self.add(factorization)\n <mask>         self.play(\n <mask>             DrawBorderThenFill(five_dot), \n <mask>             FadeIn(five_label)\n <mask>         ) </s> add         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n        morty = Mortimer().to_edge(DOWN)\n        randy.make_eye_contact(morty)\n\n        self.play(*map(FadeIn, [randy, morty]))\n        self.play(PiCreatureSays(\n            randy, \"Wait \\\\dots why?\",\n            target_mode = \"confused\",\n        ))\n        self.play(Blink(randy))\n        self.dither(2)\n        self.play(\n            RemovePiCreatureBubble(\n                randy, target_mode = \"erm\",\n            ),\n            PiCreatureSays(\n                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n                target_mode = \"hooray\",\n                bubble_kwargs = {\"width\" : 5, \"height\" : 3}\n            )\n        )\n        self.play(\n            morty.look_at, self.equation,\n            randy.look_at, self.equation,\n        )\n        self.play(Blink(morty))\n        self.play(randy.change_mode, \"pondering\")\n        self.play(RemovePiCreatureBubble(morty))\n        self.play(*map(FadeOut, [randy, morty])) </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep replace keep keep keep keep keep keep keep keep replace replace keep keep", "code_tokens": " <mask> \n <mask>     def point_to_coords(self, point):\n <mask>         new_point = point-self.get_center()\n <mask>         center_x, center_y = self.coords_at_center\n <mask>         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n <mask>         y = center_y + point[1]/self.get_space_unit_to_y_unit()\n <mask>         return x, y\n <mask> \n <mask>     def point_to_coords(self, point):\n <mask>         new_point = point-self.get_center()\n <mask>         center_x, center_y = self.coords_at_center\n <mask>         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n <mask>         y = center_y + point[1]/self.get_space_unit_to_y_unit()\n <mask>         return x, y\n <mask>  </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "topics/number_line.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     }\n <mask> \n <mask>     def __init__(self, width=None, height=None, **kwargs):\n <mask>         Polygon.__init__(self, UR, UL, DL, DR, **kwargs)\n <mask>         self.width = width or self.width\n <mask>         self.height = height or self.height\n <mask>         self.set_width(self.width, stretch=True)\n <mask>         self.set_height(self.height, stretch=True)\n <mask> \n <mask> \n <mask> class Square(Rectangle):\n <mask>     CONFIG = {\n <mask>         \"side_length\": 2.0, </s> remove         Rectangle.__init__(\n            self,\n            height=self.side_length,\n            width=self.side_length,\n            **kwargs\n        )", "html_url": "https://github.com/3b1b/manim/commit/00ad9d7f9591e0dfa0407a6e41b83ba6c1af31df", "file_name": "manimlib/mobject/geometry.py"}
{"docstring_tokens": "keep keep replace keep replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask>     }\n <mask> \n <mask>     def __init__(self, **kwargs):\n <mask>         digest_config(self, kwargs)\n <mask>         Rectangle.__init__(\n <mask>             self,\n <mask>             height=self.side_length,\n <mask>             width=self.side_length,\n <mask>             **kwargs\n <mask>         )\n <mask> \n <mask> \n <mask> class RoundedRectangle(Rectangle):\n </s> Cleanup to square and rectangle init </s> remove         self.width = width or self.width\n        self.height = height or self.height\n        self.set_width(self.width, stretch=True)\n        self.set_height(self.height, stretch=True)\n </s> add         if width is None:\n            width = self.width\n        if height is None:\n            height = self.height\n\n        self.set_width(width, stretch=True)\n        self.set_height(height, stretch=True)", "html_url": "https://github.com/3b1b/manim/commit/00ad9d7f9591e0dfa0407a6e41b83ba6c1af31df", "file_name": "manimlib/mobject/geometry.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask>         # \"use_real_images\": False,\n <mask>         \"include_labels\": False,\n <mask>         \"camera_config\": {\"background_color\": DARKER_GREY},\n <mask>         \"random_seed\": 6,\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         self.add_title() </s> remove # TODO\nclass ContrastToOtherOlympiadProblems(Scene):", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         all_students.shuffle()\n <mask> \n <mask>         student_groups.generate_target()\n <mask>         student_groups.target.arrange_in_grid(\n <mask>             n_rows=10,\n <mask>             buff=SMALL_BUFF,\n <mask>         )\n <mask>         student_groups.target[-9:].align_to(student_groups.target[0], LEFT)\n <mask>         student_groups.target.match_height(flags)\n <mask>         student_groups.target.match_y(flags) </s> add                 print(\"Failed on {}\".format(country))\n\n        n_rows = self.n_flag_rows </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3) </s> remove             student_groups[1:].set_opacity, 0.1, </s> add             student_groups[1:].fade, 0.9, </s> add         \"windmill\", \"1440p60\"", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep replace replace keep replace keep keep", "code_tokens": " <mask>     def get_flags(self):\n <mask>         with open(os.path.join(\"assets\", \"imo_countries.json\")) as fp:\n <mask>             countries = json.load(fp)\n <mask>         with open(os.path.join(\"assets\", \"country_codes.json\")) as fp:\n <mask>             code_map = json.load(fp)\n <mask> \n <mask>         images = Group() </s> remove         for country in countries:\n            country = country.upper()\n            if country not in code_map: </s> add         for country, count in countries_with_counts:\n            country = country.lower()\n\n            alt_names = [\n                (\"united states of america\", \"united states\"),\n                (\"people's republic of china\", \"china\"),\n                (\"macau\", \"macao\"),\n                (\"syria\", \"syrian arab republic\"),\n                (\"north macedonia\", \"macedonia, the former yugoslav republic of\"),\n                (\"tanzania\", \"united republic of tanzania\"),\n                (\"vietnam\", \"viet nam\"),\n                (\"ivory coast\", \"cote d'ivoire\")\n            ]\n            for n1, n2 in alt_names:\n                if country == n1:\n                    country = n2\n\n            if country not in country_to_code2:\n                print(\"Can't find {}\".format(country))", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep replace", "code_tokens": " <mask>         with open(os.path.join(\"assets\", \"country_codes.json\")) as fp:\n <mask>             code_map = json.load(fp)\n <mask> \n <mask>         images = Group()\n <mask>         for country in countries:\n <mask>             country = country.upper()\n <mask>             if country not in code_map:\n <mask>                 continue\n <mask>             short_code = code_map[country].lower() </s> remove             code_map = json.load(fp) </s> add             country_codes = json.load(fp)\n            country_to_code2 = dict([\n                (country.lower(), code2.lower())\n                for country, code2, code3 in country_codes\n            ])\n            country_to_code3 = dict([\n                (country.lower(), code3.lower())\n                for country, code2, code3 in country_codes\n            ]) </s> remove         with open(os.path.join(\"assets\", \"imo_countries.json\")) as fp:\n            countries = json.load(fp) </s> add         year = self.year\n        file = \"{}_imo_countries.json\".format(year)\n        with open(os.path.join(\"assets\", file)) as fp:\n            countries_with_counts = json.load(fp) </s> remove                 label = VGroup(*[TextMobject(l) for l in country]) </s> add                 label = VGroup(*[\n                    TextMobject(l)\n                    for l in country_to_code3[country].upper()\n                ])", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             short_code = code_map[country].lower()\n <mask>             try:\n <mask>                 image = ImageMobject(os.path.join(\"flags\", short_code))\n <mask>                 image.set_width(1)\n <mask>                 label = VGroup(*[TextMobject(l) for l in country])\n <mask>                 label.arrange(RIGHT, buff=0.05, aligned_edge=DOWN)\n <mask>                 label.set_height(0.25)\n <mask>                 if not self.use_real_images:\n <mask>                     rect = SurroundingRectangle(image, buff=0)\n <mask>                     rect.set_stroke(WHITE, 1) </s> remove             short_code = code_map[country].lower() </s> add             short_code = country_to_code2[country] </s> remove         for country in countries:\n            country = country.upper()\n            if country not in code_map: </s> add             country_codes = json.load(fp)\n            country_to_code2 = dict([\n                (country.lower(), code2.lower())\n                for country, code2, code3 in country_codes\n            ])\n            country_to_code3 = dict([\n                (country.lower(), code3.lower())\n                for country, code2, code3 in country_codes\n            ]) </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>                     rect.set_stroke(WHITE, 1)\n <mask>                     image = rect\n <mask>                 image.label = label\n <mask>                 images.add(image)\n <mask>             except OSError:\n <mask>                 print(\"Failed on {}\".format(country))\n <mask>  </s> add                 print(\"Failed on {}\".format(country))\n\n        n_rows = self.n_flag_rows </s> add             short_code = country_to_code2[country] </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>                     image = rect\n <mask>                 image.label = label\n <mask>                 images.add(image)\n <mask>             except OSError:\n <mask>                 pass\n <mask>         # images.remove(*images[self.num_countries:])\n <mask>         n_rows = 10\n <mask>         images.arrange_in_grid(\n <mask>             n_rows=n_rows,\n <mask>             buff=1.25,\n <mask>         )\n <mask>         images[-(len(images) % n_rows):].align_to(images[0], LEFT) </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>         return images\n <mask> \n <mask> \n <mask> class ShowTest(Scene):\n <mask>     def construct(self):\n <mask>         self.introduce_test()\n <mask> \n <mask>     def introduce_test(self):\n <mask>         test = self.get_test() </s> remove         with open(os.path.join(\"assets\", \"imo_countries.json\")) as fp:\n            countries = json.load(fp) </s> remove # TODO\nclass ContrastToOtherOlympiadProblems(Scene):", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>         self.let_windmill_run(windmill, self.final_run_time)\n <mask> \n <mask> \n <mask> # TODO\n <mask> class ContrastToOtherOlympiadProblems(Scene):\n <mask>     def construct(self):\n <mask>         pass\n <mask> \n <mask> \n <mask> class WindmillExample30Points(WindmillScene): </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo) </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3) </s> remove         \"windmill_rotation_speed\": TAU / 8,", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> # TODO\n <mask> class ContrastToOtherOlympiadProblems(Scene):\n <mask>     def construct(self):\n <mask>         pass\n <mask> \n <mask> \n <mask> class WindmillExample30Points(WindmillScene):\n <mask>     CONFIG = {\n <mask>         \"random_seed\": 0, </s> remove # TODO\nclass ContrastToOtherOlympiadProblems(Scene): </s> remove         \"windmill_rotation_speed\": TAU / 8, </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep", "code_tokens": " <mask> \n <mask> class WindmillExample30Points(WindmillScene):\n <mask>     CONFIG = {\n <mask>         \"random_seed\": 0,\n <mask>         \"run_time\": 60,\n <mask>         \"counter_config\": {\n <mask>             \"counter_height\": 0.15,\n <mask>             \"buff\": 0.1, </s> remove         \"windmill_rotation_speed\": TAU / 8, </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>         \"n_points\": 30,\n <mask>         \"random_seed\": 0,\n <mask>         \"run_time\": 60,\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         points = self.get_random_point_set(self.n_points) </s> remove         points = self.get_random_point_set(30) </s> add         points = self.get_random_point_set(self.n_points)\n        points[:, 0] *= 1.5", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"run_time\": 60,\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         points = self.get_random_point_set(30)\n <mask>         sorted_points = sorted(list(points), key=lambda p: p[1])\n <mask>         sorted_points[4] += RIGHT\n <mask> \n <mask>         dots = self.get_dots(points)\n <mask>         windmill = self.get_windmill(points, sorted_points[5], angle=PI / 4) </s> remove         \"windmill_rotation_speed\": TAU / 8, </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo) </s> remove         self.let_windmill_run(windmill, 8) </s> add         self.let_windmill_run(windmill, 16) </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep replace replace replace keep keep replace keep", "code_tokens": " <mask>         self.add(dots)\n <mask>         self.add(pivot_dot)\n <mask>         self.add(self.get_pivot_counters(\n <mask>             windmill,\n <mask>             counter_height=0.15,\n <mask>             buff=0.1,\n <mask>         ))\n <mask> \n <mask>         self.let_windmill_run(windmill, run_time)\n <mask>  </s> remove         self.let_windmill_run(windmill, 8) </s> add         self.let_windmill_run(windmill, 16) </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask>         self.wait()\n <mask> \n <mask>         windmill.rot_speed = TAU / 8\n <mask>         self.let_windmill_run(windmill, 8)\n <mask>         highlight = windmill.copy()\n <mask>         highlight.set_stroke(YELLOW, 4)\n <mask>         self.play(\n <mask>             ShowCreationThenDestruction(highlight),\n <mask>         ) </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3) </s> remove         \"windmill_rotation_speed\": TAU / 8,", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> class FearedCase(WindmillScene):\n <mask>     CONFIG = {\n <mask>         \"n_points\": 25,\n <mask>         \"windmill_rotation_speed\": TAU / 8,\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         points = self.get_random_point_set(self.n_points)\n <mask>         sorted_points = sorted(list(points), key=lambda p: p[1]) </s> add         points = self.get_random_point_set(self.n_points)\n        points[:, 0] *= 1.5 </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask> \n <mask>         self.add_dot_color_updater(new_dots, windmill)\n <mask> \n <mask>         for rect in rects:\n <mask>             self.play(rect.set_opacity, 1)\n <mask>             self.play(rect.set_opacity, rects.const_opacity)\n <mask>         rects.resume_updating()\n <mask>         self.wait()\n <mask>         self.play( </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3) </s> remove         self.let_windmill_run(windmill, 8) </s> add         self.let_windmill_run(windmill, 16)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>         for rect in rects:\n <mask>             self.play(rect.set_opacity, 1)\n <mask>             self.play(rect.set_opacity, rects.const_opacity)\n <mask>         self.wait()\n <mask>         self.play(\n <mask>             counters.space_out_submobjects, 0.8,\n <mask>             counters.next_to, mid_words, DOWN, LARGE_BUFF,\n <mask>             FadeOut(label_sets),\n <mask>         ) </s> add         rects.suspend_updating() </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def ask_about_numbers(self):\n <mask>         self.windmill.rot_speed *= 0.5\n <mask>         self.let_windmill_run(self.windmill, 20)\n <mask> \n <mask> \n <mask> class SecondColoringExample(WindmillScene):\n <mask>     CONFIG = {\n <mask>         \"run_time\": 30, </s> remove         \"windmill_rotation_speed\": TAU / 8, </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace", "code_tokens": " <mask> \n <mask> \n <mask> class NewSceneName(Scene):\n <mask>     def construct(self):\n <mask>         pass </s> remove # TODO\nclass ContrastToOtherOlympiadProblems(Scene): </s> add class FootnoteToIMOIntro(Scene):\n    def construct(self):\n        words = TextMobject(\"$^*$Based on data from 2019 test\")\n        self.play(FadeInFrom(words, UP))\n        self.wait()", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"fill_dtype\": [\n <mask>             ('point', np.float32, (3,)),\n <mask>             ('color', np.float32, (4,)),\n <mask>             ('fill_all', np.float32, (1,)),\n <mask>             ('orientation', np.float32, (1,)),\n <mask>         ],\n <mask>         \"stroke_dtype\": [\n <mask>             (\"point\", np.float32, (3,)),\n <mask>             (\"prev_point\", np.float32, (3,)),\n <mask>             (\"next_point\", np.float32, (3,)), </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient; </s> remove         inner_tri_indices = inner_vert_indices[\n            earclip_triangulation(inner_verts, rings)\n        ] </s> add         inner_tri_indices = inner_vert_indices[earclip_triangulation(inner_verts, rings)] </s> add         # Always send points in a positively oriented way\n        if orientation < 0:\n            data[\"point\"][:len(points)] = points[::-1] </s> remove in float fill_type; </s> add in float fill_all;  // Either 0 or 1e", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         rings = np.arange(1, len(inner_vert_indices) + 1)[inner_vert_indices % 3 == 2]\n <mask> \n <mask>         # Triangulate\n <mask>         inner_verts = points[inner_vert_indices]\n <mask>         inner_tri_indices = inner_vert_indices[\n <mask>             earclip_triangulation(inner_verts, rings)\n <mask>         ]\n <mask> \n <mask>         tri_indices = np.hstack([indices, inner_tri_indices])\n <mask>         return tri_indices\n <mask> \n <mask>     def get_fill_shader_data(self): </s> add         # Always send points in a positively oriented way\n        if orientation < 0:\n            data[\"point\"][:len(points)] = points[::-1] </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep replace keep keep keep replace keep keep keep keep", "code_tokens": " <mask> \n <mask> in vec4 color;\n <mask> in float fill_type;\n <mask> in float uv_anti_alias_width;\n <mask> \n <mask> in vec2 uv_coords;\n <mask> in vec2 wz_coords;\n <mask> in vec2 uv_b2;\n <mask> in float bezier_degree;\n <mask> \n <mask> out vec4 frag_color; </s> remove in float v_orientation[3]; </s> remove out float fill_type; </s> add out float fill_all; </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1 </s> remove // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\nout vec2 wz_coords; </s> remove     float epsilon = 1e-6; </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_frag.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> const float FILL_OUTSIDE = 1;\n <mask> const float FILL_ALL = 2;\n <mask> \n <mask> \n <mask> // Needed for quadratic_bezier_distance\n <mask> float modify_distance_for_endpoints(vec2 p, float dist, float t){\n <mask>     return dist;\n <mask> }\n <mask> \n <mask> // To my knowledge, there is no notion of #include for shaders, </s> remove // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\nout vec2 wz_coords; </s> remove     float epsilon = 1e-6; </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1 </s> remove \nbool is_inside_curve(){\n    if(bezier_degree < 2) return false;\n\n    float value = wz_coords.x * wz_coords.x - wz_coords.y;\n    if(fill_type == FILL_INSIDE) return value < 0;\n    if(fill_type == FILL_OUTSIDE) return value > 0;\n    return false;\n} </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove out float fill_type; </s> add out float fill_all;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_frag.glsl"}
{"docstring_tokens": "keep keep replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep keep keep replace replace", "code_tokens": " <mask> #INSERT quadratic_bezier_distance.glsl\n <mask> \n <mask> \n <mask> bool is_inside_curve(){\n <mask>     if(bezier_degree < 2) return false;\n <mask> \n <mask>     float value = wz_coords.x * wz_coords.x - wz_coords.y;\n <mask>     if(fill_type == FILL_INSIDE) return value < 0;\n <mask>     if(fill_type == FILL_OUTSIDE) return value > 0;\n <mask>     return false;\n <mask> }\n <mask> \n <mask> \n <mask> float sdf(){\n <mask>     if(is_inside_curve()) return -1.0;\n <mask>     return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n <mask> }\n <mask> \n <mask> \n <mask> float sdf(){\n <mask>     if(is_inside_curve()) return -1.0;\n <mask>     return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> add </s> remove // Needed for quadratic_bezier_distance </s> add // Needed for quadratic_bezier_distance insertion below </s> remove         inner_tri_indices = inner_vert_indices[\n            earclip_triangulation(inner_verts, rings)\n        ] </s> add         inner_tri_indices = inner_vert_indices[earclip_triangulation(inner_verts, rings)] </s> remove         data[\"orientation\"] = orientation </s> add         # Always send points in a positively oriented way\n        if orientation < 0:\n            data[\"point\"][:len(points)] = points[::-1]", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_frag.glsl"}
{"docstring_tokens": "keep keep keep replace keep replace", "code_tokens": " <mask> void main() {\n <mask>     if (color.a == 0) discard;\n <mask>     frag_color = color;\n <mask>     if (fill_type == FILL_ALL) return;\n <mask>     frag_color.a *= smoothstep(1, 0, sdf() / uv_anti_alias_width);\n <mask>     // frag_color.a += 0.2; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_frag.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep replace keep keep keep keep", "code_tokens": " <mask> \n <mask> in vec3 bp[3];\n <mask> in vec4 v_color[3];\n <mask> in float v_fill_all[3];\n <mask> in float v_orientation[3];\n <mask> \n <mask> out vec4 color;\n <mask> out float fill_type;\n <mask> out float uv_anti_alias_width;\n <mask> \n <mask> // uv space is where b0 = (0, 0), b1 = (1, 0), and transform is orthogonal\n <mask> out vec2 uv_coords; </s> remove // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\nout vec2 wz_coords; </s> remove in vec2 wz_coords; </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1 </s> remove in float fill_type; </s> add in float fill_all;  // Either 0 or 1e </s> remove out float v_orientation;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> // uv space is where b0 = (0, 0), b1 = (1, 0), and transform is orthogonal\n <mask> out vec2 uv_coords;\n <mask> out vec2 uv_b2;\n <mask> // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\n <mask> out vec2 wz_coords;\n <mask> \n <mask> out float bezier_degree;\n <mask> \n <mask> const float FILL_INSIDE = 0;\n <mask> const float FILL_OUTSIDE = 1; </s> remove out float fill_type; </s> add out float fill_all; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad); </s> remove // Needed for quadratic_bezier_distance </s> remove in vec2 wz_coords; </s> remove     float epsilon = 1e-6; </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n}", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> // replaces this line with the contents of named file\n <mask> #INSERT quadratic_bezier_geometry_functions.glsl\n <mask> #INSERT scale_and_shift_point_for_frame.glsl\n <mask> \n <mask> \n <mask> mat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n <mask>     // If linear or null, this matrix is not needed\n <mask>     if(bezier_degree < 2) return mat3(1.0);\n <mask> \n <mask>     vec2 inv_col1 = 2 * (b1 - b0);\n <mask>     vec2 inv_col2 = b2 - 2 * b1 + b0;\n <mask>     float inv_det = cross(inv_col1, inv_col2);\n <mask> \n <mask>     mat3 transform = mat3(\n <mask>         inv_col2.y, -inv_col1.y, 0,\n <mask>         -inv_col2.x, inv_col1.x, 0,\n <mask>         0, 0, inv_det\n <mask>     ) / inv_det;\n <mask> \n <mask>     mat3 shift = mat3(\n <mask>         1, 0, 0,\n <mask>         0, 1, 0,\n <mask>         -b0.x, -b0.y, 1\n <mask>     );\n <mask>     return transform * shift;\n <mask> }\n <mask> \n <mask> \n <mask> void emit_simple_triangle(){\n <mask>     for(int i = 0; i < 3; i++){\n <mask>         color = v_color[i];\n <mask>         gl_Position = vec4(\n <mask>             scale_and_shift_point_for_frame(bp[i]), </s> remove     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2); </s> add     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2); </s> remove \nbool is_inside_curve(){\n    if(bezier_degree < 2) return false;\n\n    float value = wz_coords.x * wz_coords.x - wz_coords.y;\n    if(fill_type == FILL_INSIDE) return value < 0;\n    if(fill_type == FILL_OUTSIDE) return value > 0;\n    return false;\n} </s> add         float z = bp[nearest_bp_index_map[i]].z; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep replace keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2, float orientation){\n <mask>     // Tangent vectors\n <mask>     vec2 t01 = normalize(bp1 - bp0);\n <mask>     vec2 t12 = normalize(bp2 - bp1);\n <mask> \n <mask>     // Inside and left turn -> rot right -> -1\n <mask>     // Outside and left turn -> rot left -> +1\n <mask>     // Inside and right turn -> rot left -> +1\n <mask>     // Outside and right turn -> rot right -> -1\n <mask>     float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n <mask>     c_orient *= orientation;\n <mask> \n <mask>     bool fill_in = (c_orient > 0);\n <mask>     fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n <mask> \n <mask>     // float orient = in_or_out * c_orient;\n <mask> \n <mask>     // Normal vectors\n <mask>     // Rotate tangent vector 90-degrees clockwise\n <mask>     // if the curve is positively oriented, otherwise </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0); </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove     bool distinct_01 = length(v01) > epsilon;  // v01 is considered nonzero\n    bool distinct_12 = length(v12) > epsilon;  // v12 is considered nonzero </s> add     // bool aligned = abs(cross(normalize(v01), normalize(v12))) < angle_threshold;\n    bool aligned = acos(dot(normalize(v01), normalize(v12))) < angle_threshold;\n    bool distinct_01 = length(v01) > length_threshold;  // v01 is considered nonzero\n    bool distinct_12 = length(v12) > length_threshold;  // v12 is considered nonzero </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad); </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     // float orient = in_or_out * c_orient;\n <mask> \n <mask>     // Normal vectors\n <mask>     // Rotate tangent vector 90-degrees clockwise\n <mask>     // if the curve is positively oriented, otherwise\n <mask>     // rotate it 90-degrees counterclockwise\n <mask>     vec2 n01 = orientation * vec2(t01.y, -t01.x);\n <mask>     vec2 n12 = orientation * vec2(t12.y, -t12.x);\n <mask> \n <mask>     float aaw = anti_alias_width;\n <mask>     vec2 nudge1 = fill_in ? 0.5 * aaw * (n01 + n12) : vec2(0);\n <mask>     vec2 corners[5] = vec2[5](\n <mask>         bp0 + aaw * n01, </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient; </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation); </s> add         bp0 = new_bp[0];\n        bp1 = new_bp[1];\n        bp2 = new_bp[2]; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad); </s> add         return;\n    }\n\n    vec2 new_bp[3];\n    int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n    bezier_degree = float(n);\n    vec2 bp0, bp1, bp2;\n    if(n == 0){\n        return;  // Don't emit any vertices\n    }\n    else if(n == 1){\n        bp0 = new_bp[0];\n        bp2 = new_bp[1];\n        bp1 = 0.5 * (bp0 + bp2); </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n}", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     int coords_index_map[5] = int[5](0, 1, 2, 3, 4);\n <mask>     if(!fill_in) coords_index_map = int[5](1, 0, 2, 4, 3);\n <mask>         \n <mask>     mat3 xy_to_uv = get_xy_to_uv(bp0, bp1);\n <mask>     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2);\n <mask>     uv_b2 = (xy_to_uv * vec3(bp2, 1)).xy;\n <mask>     uv_anti_alias_width = anti_alias_width / length(bp1 - bp0);\n <mask> \n <mask>     for(int i = 0; i < 5; i++){\n <mask>         vec2 corner = corners[coords_index_map[i]]; </s> add     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2); </s> add         float z = bp[nearest_bp_index_map[i]].z; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove         wz_coords = (xy_to_wz * vec3(corner, 1)).xy;\n        float z; </s> remove void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2, float orientation){ </s> add void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2){", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>     uv_b2 = (xy_to_uv * vec3(bp2, 1)).xy;\n <mask>     uv_anti_alias_width = anti_alias_width / length(bp1 - bp0);\n <mask> \n <mask>     for(int i = 0; i < 5; i++){\n <mask>         vec2 corner = corners[coords_index_map[i]];\n <mask>         float z = bp[nearest_bp_index_map[i]].z;\n <mask>         uv_coords = (xy_to_uv * vec3(corner, 1)).xy; </s> remove     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2); </s> remove         wz_coords = (xy_to_wz * vec3(corner, 1)).xy;\n        float z; </s> add         float z = bp[nearest_bp_index_map[i]].z; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove         if(i < 2){\n            color = v_color[0];\n            z = bp[0].z;\n        }\n        else if(i == 2){\n            color = v_color[1];\n            z = bp[1].z;\n        }\n        else{\n            color = v_color[2];\n            z = bp[2].z;\n        } </s> add         if(i < 2)       color = v_color[0];\n        else if(i == 2) color = v_color[1];\n        else            color = v_color[2]; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2);\n <mask>     for(int i = 0; i < 5; i++){\n <mask>         vec2 corner = corners[coords_index_map[i]];\n <mask>         uv_coords = (xy_to_uv * vec3(corner, 1)).xy;\n <mask>         // I haven't a clue why an index map doesn't work just\n <mask>         // as well here, but for some reason it doesn't.\n <mask>         if(i < 2)       color = v_color[0];\n <mask>         else if(i == 2) color = v_color[1]; </s> remove         wz_coords = (xy_to_wz * vec3(corner, 1)).xy;\n        float z; </s> remove         if(i < 2){\n            color = v_color[0];\n            z = bp[0].z;\n        }\n        else if(i == 2){\n            color = v_color[1];\n            z = bp[1].z;\n        }\n        else{\n            color = v_color[2];\n            z = bp[2].z;\n        } </s> add         if(i < 2)       color = v_color[0];\n        else if(i == 2) color = v_color[1];\n        else            color = v_color[2]; </s> add     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2); </s> remove     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2); </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep replace replace keep keep replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask>         vec2 corner = corners[coords_index_map[i]];\n <mask>         uv_coords = (xy_to_uv * vec3(corner, 1)).xy;\n <mask>         wz_coords = (xy_to_wz * vec3(corner, 1)).xy;\n <mask>         float z;\n <mask>         // I haven't a clue why an index map doesn't work just\n <mask>         // as well here, but for some reason it doesn't.\n <mask>         if(i < 2){\n <mask>             color = v_color[0];\n <mask>             z = bp[0].z;\n <mask>         }\n <mask>         else if(i == 2){\n <mask>             color = v_color[1];\n <mask>             z = bp[1].z;\n <mask>         }\n <mask>         else{\n <mask>             color = v_color[2];\n <mask>             z = bp[2].z;\n <mask>         }\n <mask>         gl_Position = vec4(\n <mask>             scale_and_shift_point_for_frame(vec3(corner, z)),\n <mask>             1.0 </s> add         float z = bp[nearest_bp_index_map[i]].z; </s> add     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2); </s> remove     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2); </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep replace keep keep replace keep", "code_tokens": " <mask> \n <mask> void main(){\n <mask>     float fill_all = v_fill_all[0];\n <mask> \n <mask>     if(fill_all == 1){\n <mask>         fill_type = FILL_ALL;\n <mask>         emit_simple_triangle(); </s> remove     v_orientation = orientation; </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     if(fill_all == 1){\n <mask>         emit_simple_triangle();\n <mask>     }else{\n <mask>         bp0 = new_bp[0];\n <mask>         bp1 = new_bp[1];\n <mask>         bp2 = new_bp[2];\n <mask>     }\n <mask>  </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation); </s> add         bp0 = new_bp[0];\n        bp1 = new_bp[1];\n        bp2 = new_bp[2]; </s> remove     float fill_all = v_fill_all[0]; </s> add     fill_all = v_fill_all[0]; </s> add     emit_pentagon(bp0, bp1, bp2); </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask>     if(fill_all == 1){\n <mask>         fill_type = FILL_ALL;\n <mask>         emit_simple_triangle();\n <mask>     }else{\n <mask>         vec2 new_bp[3];\n <mask>         int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n <mask>         bezier_degree = float(n);\n <mask>         float orientation = v_orientation[0];\n <mask> \n <mask>         vec2 bp0, bp1, bp2;\n <mask>         if(n == 0){\n <mask>             return;  // Don't emit any vertices\n <mask>         }\n <mask>         else if(n == 1){\n <mask>             bp0 = new_bp[0];\n <mask>             bp2 = new_bp[1];\n <mask>             bp1 = 0.5 * (bp0 + bp2);\n <mask>         }else{\n <mask>             bp0 = new_bp[0];\n <mask>             bp1 = new_bp[1];\n <mask>             bp2 = new_bp[2];\n <mask>         }\n <mask> \n <mask>         emit_pentagon(bp0, bp1, bp2, orientation);\n <mask>     }\n <mask> }\n <mask>  </s> add         return;\n    }\n\n    vec2 new_bp[3];\n    int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n    bezier_degree = float(n);\n    vec2 bp0, bp1, bp2;\n    if(n == 0){\n        return;  // Don't emit any vertices\n    }\n    else if(n == 1){\n        bp0 = new_bp[0];\n        bp2 = new_bp[1];\n        bp1 = 0.5 * (bp0 + bp2); </s> add     emit_pentagon(bp0, bp1, bp2); </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0); </s> remove void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2, float orientation){ </s> add void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2){", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep add keep keep", "code_tokens": " <mask>         bp2 = new_bp[2];\n <mask>     }\n <mask> }\n <mask>  </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation); </s> add         bp0 = new_bp[0];\n        bp1 = new_bp[1];\n        bp2 = new_bp[2]; </s> add         return;\n    }\n\n    vec2 new_bp[3];\n    int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n    bezier_degree = float(n);\n    vec2 bp0, bp1, bp2;\n    if(n == 0){\n        return;  // Don't emit any vertices\n    }\n    else if(n == 1){\n        bp0 = new_bp[0];\n        bp2 = new_bp[1];\n        bp1 = 0.5 * (bp0 + bp2); </s> remove     v_orientation = orientation; </s> remove         if(i < 2){\n            color = v_color[0];\n            z = bp[0].z;\n        }\n        else if(i == 2){\n            color = v_color[1];\n            z = bp[1].z;\n        }\n        else{\n            color = v_color[2];\n            z = bp[2].z;\n        }", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep replace replace keep", "code_tokens": " <mask> #version 330\n <mask> \n <mask> in vec3 point;\n <mask> in vec4 color;\n <mask> // fill_all is 0 or 1\n <mask> in float fill_all;\n <mask> // orientation is +1 for counterclockwise curves, -1 otherwise\n <mask> in float orientation;\n <mask> \n <mask> out vec3 bp;  // Bezier control point\n <mask> out vec4 v_color;\n <mask> out float v_fill_all;\n <mask> out float v_orientation;\n <mask> \n <mask>  </s> remove in float fill_type; </s> add in float fill_all;  // Either 0 or 1e </s> remove in float v_orientation[3]; </s> remove out float fill_type; </s> add out float fill_all; </s> remove in vec2 wz_coords; </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_vert.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep", "code_tokens": " <mask> void main(){\n <mask>     bp = rotate_point_for_frame(point);\n <mask>     v_color = color;\n <mask>     v_fill_all = fill_all;\n <mask>     v_orientation = orientation;\n <mask> } </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove     float fill_all = v_fill_all[0]; </s> remove     float fill_all = v_fill_all[0]; </s> add     fill_all = v_fill_all[0]; </s> remove         fill_type = FILL_ALL; </s> remove out float fill_type; </s> add out float fill_all; </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1 </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_vert.glsl"}
{"docstring_tokens": "keep keep replace keep keep replace replace keep keep keep", "code_tokens": " <mask> // while also passing tangency information in the linear case.\n <mask> int get_reduced_control_points(vec2 b0, vec2 b1, vec2 b2, out vec2 new_points[3]){\n <mask>     float epsilon = 1e-6;\n <mask>     vec2 v01 = (b1 - b0);\n <mask>     vec2 v12 = (b2 - b1);\n <mask>     bool distinct_01 = length(v01) > epsilon;  // v01 is considered nonzero\n <mask>     bool distinct_12 = length(v12) > epsilon;  // v12 is considered nonzero\n <mask>     int n_uniques = int(distinct_01) + int(distinct_12);\n <mask>     if(n_uniques == 2){\n <mask>         bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon; </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0); </s> remove // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\nout vec2 wz_coords;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_geometry_functions.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     vec2 v12 = (b2 - b1);\n <mask>     bool distinct_01 = length(v01) > epsilon;  // v01 is considered nonzero\n <mask>     bool distinct_12 = length(v12) > epsilon;  // v12 is considered nonzero\n <mask>     int n_uniques = int(distinct_01) + int(distinct_12);\n <mask>     if(n_uniques == 2){\n <mask>         bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n <mask>         if(linear){\n <mask>             new_points[0] = b0;\n <mask>             new_points[1] = b2;\n <mask>             return 1;\n <mask>         }else{\n <mask>             new_points[0] = b0;\n <mask>             new_points[1] = b1;\n <mask>             new_points[2] = b2;\n <mask>             return 2;\n <mask>         }\n <mask>     }else if(n_uniques == 1){\n <mask>         new_points[0] = b0;\n <mask>         new_points[1] = b2;\n <mask>         return 1;\n <mask>     }else{\n <mask>         new_points[0] = b0; </s> remove     bool distinct_01 = length(v01) > epsilon;  // v01 is considered nonzero\n    bool distinct_12 = length(v12) > epsilon;  // v12 is considered nonzero </s> remove     float epsilon = 1e-6; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0); </s> remove // Needed for quadratic_bezier_distance", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_geometry_functions.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace", "code_tokens": " <mask> .DS_Store\n <mask> \n <mask> # For manim\n <mask> /videos\n <mask> /custom_defaults.yml\n <mask> /manimlib/defaults.yml </s> rename custom_defaults -> custom_config defaults -> default_config </s> add /custom_config.yml </s> rename custom_defaults -> custom_config defaults -> default_config </s> add /custom_config.yml\n/manimlib/default_config.yml </s> remove         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\") </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\") </s> remove         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove             # the custom_defaults.yml file </s> remove             # the custom_defaults.yml file", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": ".gitignore"}
{"docstring_tokens": "keep keep keep add", "code_tokens": " <mask> \n <mask> # For manim\n <mask> /videos\n <mask> /custom_config.yml </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove /custom_defaults.yml\n/manimlib/defaults.yml </s> add </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": ".gitignore"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             # You can texture a surface with up to two images, which will\n <mask>             # be interpreted as the side towards the light, and away from\n <mask>             # the light.  These can be either urls, or paths to a local file\n <mask>             # in whatever you've set as the image directory in\n <mask>             # the custom_defaults.yml file\n <mask> \n <mask>             # day_texture = \"EarthTextureMap\"\n <mask>             # night_texture = \"NightEarthTextureMap\"\n <mask>             day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n <mask>             night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\" </s> remove             # the custom_defaults.yml file </s> remove     # See if there's a custom_defaults file in current directory,", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "docs/source/getting_started/example_scenes.rst"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         # You can texture a surface with up to two images, which will\n <mask>         # be interpreted as the side towards the light, and away from\n <mask>         # the light.  These can be either urls, or paths to a local file\n <mask>         # in whatever you've set as the image directory in\n <mask>         # the custom_defaults.yml file\n <mask> \n <mask>         # day_texture = \"EarthTextureMap\"\n <mask>         # night_texture = \"NightEarthTextureMap\"\n <mask>         day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n <mask>         night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n </s> rename custom_defaults -> custom_config defaults -> default_config", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "example_scenes.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         spec.loader.exec_module(module)\n <mask>         return module\n <mask> \n <mask> \n <mask> def get_custom_defaults():\n <mask>     filename = \"custom_defaults.yml\"\n <mask>     global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\")\n <mask> \n <mask>     if not (os.path.exists(global_defaults_file) or os.path.exists(filename)):\n <mask>         print(\"There is no configuration file detected. Initial configuration:\\n\")\n <mask>         init_customization()\n <mask>  </s> remove         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove         custom_defaults = get_custom_defaults()\n        SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"]) </s> add         custom_config = get_custom_config()\n        SAVED_TEX_CONFIG.update(custom_config[\"tex\"]) </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\") </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep replace keep keep replace keep keep keep keep", "code_tokens": " <mask>         with open(global_defaults_file, \"r\") as file:\n <mask>             custom_defaults = yaml.safe_load(file)\n <mask>     else:\n <mask>         with open(filename, \"r\") as file:\n <mask>             local_defaults = yaml.safe_load(file)\n <mask> \n <mask>     # See if there's a custom_defaults file in current directory,\n <mask>     # and if so, it further updates the defaults based on it.\n <mask>     if os.path.exists(filename): </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove     # See if there's a custom_defaults file in current directory, </s> add     # See if there's a custom_config file in current directory, </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults </s> remove             # the custom_defaults.yml file </s> remove             # the custom_defaults.yml file </s> remove         custom_defaults = get_custom_defaults()\n        SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"])", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     else:\n <mask>         with open(filename, \"r\") as file:\n <mask>             local_defaults = yaml.safe_load(file)\n <mask> \n <mask>     # See if there's a custom_defaults file in current directory,\n <mask>     # and if so, it further updates the defaults based on it.\n <mask>     if os.path.exists(filename):\n <mask>         with open(filename, \"r\") as file:\n <mask>             local_defaults = yaml.safe_load(file)\n <mask>         if local_defaults: </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove             local_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file) </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults </s> remove             custom_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file)\n\n        if os.path.exists(filename):\n            with open(filename, \"r\") as file:\n                local_defaults = yaml.safe_load(file)\n            if local_defaults:\n                config = merge_dicts_recursively(\n                    config,\n                    local_defaults,\n                ) </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace keep keep keep replace keep keep keep", "code_tokens": " <mask>             local_defaults = yaml.safe_load(file)\n <mask> \n <mask>     # See if there's a custom_defaults file in current directory,\n <mask>     # and if so, it further updates the defaults based on it.\n <mask>     if os.path.exists(filename):\n <mask>         with open(filename, \"r\") as file:\n <mask>             local_defaults = yaml.safe_load(file)\n <mask>         if local_defaults:\n <mask>             custom_defaults = merge_dicts_recursively(\n <mask>                 custom_defaults,\n <mask>                 local_defaults,\n <mask>             )\n <mask> \n <mask>     return custom_defaults\n <mask> \n <mask> \n <mask> def get_configuration(args):\n <mask>     custom_defaults = get_custom_defaults()\n <mask> \n <mask>     write_file = any([args.write_file, args.open, args.finder])\n <mask>     if args.transparent: </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove     # See if there's a custom_defaults file in current directory, </s> add     # See if there's a custom_config file in current directory, </s> remove             local_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file) </s> remove             custom_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file)\n\n        if os.path.exists(filename):\n            with open(filename, \"r\") as file:\n                local_defaults = yaml.safe_load(file)\n            if local_defaults:\n                config = merge_dicts_recursively(\n                    config,\n                    local_defaults,\n                ) </s> remove         custom_defaults = get_custom_defaults()\n        SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"])", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         file_ext = \".mp4\"\n <mask> \n <mask>     file_writer_config = {\n <mask>         \"write_to_movie\": not args.skip_animations and write_file,\n <mask>         \"break_into_partial_movies\": custom_defaults[\"break_into_partial_movies\"],\n <mask>         \"save_last_frame\": args.skip_animations and write_file,\n <mask>         \"save_pngs\": args.save_pngs,\n <mask>         # If -t is passed in (for transparent), this will be RGBA\n <mask>         \"png_mode\": \"RGBA\" if args.transparent else \"RGB\",\n <mask>         \"movie_file_extension\": file_ext, </s> remove         \"mirror_module_path\": custom_defaults[\"directories\"][\"mirror_module_path\"],\n        \"output_directory\": args.video_dir or custom_defaults[\"directories\"][\"output\"], </s> add         \"mirror_module_path\": custom_config[\"directories\"][\"mirror_module_path\"],\n        \"output_directory\": args.video_dir or custom_config[\"directories\"][\"output\"], </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config) </s> remove             # the custom_defaults.yml file </s> remove             # the custom_defaults.yml file", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         \"save_pngs\": args.save_pngs,\n <mask>         # If -t is passed in (for transparent), this will be RGBA\n <mask>         \"png_mode\": \"RGBA\" if args.transparent else \"RGB\",\n <mask>         \"movie_file_extension\": file_ext,\n <mask>         \"mirror_module_path\": custom_defaults[\"directories\"][\"mirror_module_path\"],\n <mask>         \"output_directory\": args.video_dir or custom_defaults[\"directories\"][\"output\"],\n <mask>         \"file_name\": args.file_name,\n <mask>         \"input_file_path\": args.file or \"\",\n <mask>         \"open_file_upon_completion\": args.open,\n <mask>         \"show_file_location_upon_completion\": args.finder,\n <mask>         \"quiet\": args.quiet, </s> remove             # the custom_defaults.yml file </s> remove             # the custom_defaults.yml file </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     ])\n <mask>     return config\n <mask> \n <mask> \n <mask> def get_camera_configuration(args, custom_defaults):\n <mask>     camera_config = {}\n <mask>     camera_qualities = get_custom_defaults()[\"camera_qualities\"]\n <mask>     if args.low_quality:\n <mask>         quality = camera_qualities[\"low\"]\n <mask>     elif args.medium_quality: </s> remove     camera_qualities = get_custom_defaults()[\"camera_qualities\"] </s> add     camera_qualities = get_custom_config()[\"camera_qualities\"] </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> def get_camera_configuration(args, custom_defaults):\n <mask>     camera_config = {}\n <mask>     camera_qualities = get_custom_defaults()[\"camera_qualities\"]\n <mask>     if args.low_quality:\n <mask>         quality = camera_qualities[\"low\"]\n <mask>     elif args.medium_quality:\n <mask>         quality = camera_qualities[\"medium\"]\n <mask>     elif args.hd: </s> remove def get_camera_configuration(args, custom_defaults): </s> add def get_camera_configuration(args, custom_config): </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> class BlankScene(Scene):\n <mask>     def construct(self):\n <mask>         exec(get_custom_defaults()[\"universal_import_line\"])\n <mask>         self.embed()\n <mask> \n <mask> \n <mask> def is_child_scene(obj, module):\n <mask>     if not inspect.isclass(obj): </s> remove def get_camera_configuration(args, custom_defaults): </s> add def get_camera_configuration(args, custom_config):", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> import os\n <mask> import tempfile\n <mask> \n <mask> from manimlib.config import get_custom_defaults\n <mask> from manimlib.config import get_manim_dir\n <mask> \n <mask> CUSTOMIZATION = {}\n <mask> \n <mask>  </s> remove         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\") </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\")", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/customization.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> def get_customization():\n <mask>     if not CUSTOMIZATION:\n <mask>         CUSTOMIZATION.update(get_custom_defaults())\n <mask>         directories = CUSTOMIZATION[\"directories\"]\n <mask>         # Unless user has specified otherwise, use the system default temp\n <mask>         # directory for storing tex files, mobject_data, etc.\n <mask>         if not directories[\"temporary_storage\"]:\n <mask>             directories[\"temporary_storage\"] = tempfile.gettempdir() </s> remove def get_custom_defaults():\n    filename = \"custom_defaults.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add def get_custom_config():\n    filename = \"custom_config.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/customization.py"}
{"docstring_tokens": "keep replace keep replace keep keep", "code_tokens": " <mask>         from manimlib.config import get_manim_dir\n <mask>         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\")\n <mask>     else:\n <mask>         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\")\n <mask> \n <mask>     print(\"\\n directories:\") </s> remove from manimlib.config import get_custom_defaults </s> add from manimlib.config import get_custom_config </s> remove from manimlib.config import get_custom_defaults </s> add from manimlib.config import get_custom_config </s> remove def get_custom_defaults():\n    filename = \"custom_defaults.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add def get_custom_config():\n    filename = \"custom_config.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove from manimlib.config import get_custom_defaults </s> add from manimlib.config import get_custom_config", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/init_config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> from contextlib import contextmanager\n <mask> \n <mask> from manimlib.utils.directories import get_tex_dir\n <mask> from manimlib.config import get_manim_dir\n <mask> from manimlib.config import get_custom_defaults\n <mask> \n <mask> \n <mask> SAVED_TEX_CONFIG = {}\n <mask> \n <mask>  </s> remove         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\") </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\")", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/tex_file_writing.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>     }\n <mask>     \"\"\"\n <mask>     # Only load once, then save thereafter\n <mask>     if not SAVED_TEX_CONFIG:\n <mask>         custom_defaults = get_custom_defaults()\n <mask>         SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"])\n <mask>         # Read in template file\n <mask>         template_filename = os.path.join(\n <mask>             get_manim_dir(), \"manimlib\", \"tex_templates\",\n <mask>             SAVED_TEX_CONFIG[\"template_file\"],\n <mask>         ) </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults </s> remove             custom_defaults = yaml.safe_load(file) </s> remove     custom_defaults = get_custom_defaults() </s> remove def get_custom_defaults():\n    filename = \"custom_defaults.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add def get_custom_config():\n    filename = \"custom_config.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/tex_file_writing.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> uniform float reflectiveness;\n <mask> uniform float gloss;\n <mask> uniform float shadow;\n <mask> \n <mask> in vec3 bp[3];\n <mask> \n <mask> in float v_joint_angle[3];\n <mask> in float v_stroke_width[3];\n <mask> in vec4 v_color[3];\n <mask>  </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2]));", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> #INSERT get_unit_normal.glsl\n <mask> #INSERT finalize_color.glsl\n <mask> \n <mask> \n <mask> void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n <mask>     for(int i = 0; i < 3; i++){\n <mask>         float sf = perspective_scale_factor(points[i].z, focal_distance);\n <mask>         flat_points[i] = sf * points[i].xy;\n <mask>     }\n <mask> }\n <mask> \n <mask> \n <mask> float angle_between_vectors(vec2 v1, vec2 v2){\n <mask>     float v1_norm = length(v1);\n <mask>     float v2_norm = length(v2);\n <mask>     if(v1_norm == 0 || v2_norm == 0) return 0.0;\n <mask>     float dp = dot(v1, v2) / (v1_norm * v2_norm);\n <mask>     float angle = acos(clamp(dp, -1.0, 1.0));\n <mask>     float sn = sign(cross2d(v1, v2));\n <mask>     return sn * angle;\n <mask> }\n <mask> \n <mask> \n <mask> bool find_intersection(vec2 p0, vec2 v0, vec2 p1, vec2 v1, out vec2 intersection){\n <mask>     // Find the intersection of a line passing through\n <mask>     // p0 in the direction v0 and one passing through p1 in\n <mask>     // the direction p1. </s> Minor simplifications for stroke shader </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> add </s> remove     flatten_points(controls, flat_controls); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> add     int n_corners = get_corners(flat_controls, int(bezier_degree), scaled_strokes, corners); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     return 5;\n <mask> }\n <mask> \n <mask> \n <mask> void set_adjascent_info(vec2 c0, vec2 tangent,\n <mask>                         int degree,\n <mask>                         vec2 adj[3],\n <mask>                         out float bevel,\n <mask>                         out float angle\n <mask>                         ){\n <mask>     bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n <mask>     angle = angle_between_vectors(c0 - adj[1], tangent);\n <mask>     // Decide on joint type\n <mask>     bool one_linear = (degree == 1 || linear_adj);\n <mask>     bool should_bevel = (\n <mask>         (joint_type == AUTO_JOINT && one_linear) ||\n <mask>         joint_type == BEVEL_JOINT\n <mask>     );\n <mask>     bevel = should_bevel ? 1.0 : 0.0;\n <mask> }\n <mask> \n <mask> \n <mask> void find_joint_info(){\n <mask>     angle_from_prev = v_joint_angle[0];\n <mask>     angle_to_next = v_joint_angle[2];\n <mask>     has_prev = 1.0;\n <mask>     has_next = 1.0; </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    }", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep replace replace replace replace replace replace replace keep keep keep keep replace keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> void main() {\n <mask>     // Convert control points to a standard form if they are linear or null\n <mask>     vec3 controls[3];\n <mask>     bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n <mask>     if(bezier_degree == 0.0) return;  // Null curve\n <mask>     int degree = int(bezier_degree);\n <mask>     unit_normal = get_unit_normal(controls);\n <mask> \n <mask> \n <mask>     // Adjust stroke width based on distance from the camera\n <mask>     float scaled_strokes[3];\n <mask>     for(int i = 0; i < 3; i++){\n <mask>         float sf = perspective_scale_factor(controls[i].z, focal_distance);\n <mask>         if(bool(flat_stroke)){\n <mask>             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]);\n <mask>             sf *= abs(dot(unit_normal, to_cam)); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove     flatten_points(controls, flat_controls); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove     int n_corners = get_corners(flat_controls, degree, scaled_strokes, corners); </s> add     int n_corners = get_corners(flat_controls, int(bezier_degree), scaled_strokes, corners);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     float scaled_strokes[3];\n <mask>     for(int i = 0; i < 3; i++){\n <mask>         float sf = perspective_scale_factor(controls[i].z, focal_distance);\n <mask>         if(bool(flat_stroke)){\n <mask>             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]);\n <mask>             sf *= abs(dot(unit_normal, to_cam));\n <mask>         }\n <mask>         scaled_strokes[i] = v_stroke_width[i] * sf;\n <mask>     }\n <mask>  </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove     bp = position_point_into_frame(point); </s> add     verts = position_point_into_frame(point);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     // Control points are projected to the xy plane before drawing, which in turn\n <mask>     // gets tranlated to a uv plane.  The z-coordinate information will be remembered\n <mask>     // by what's sent out to gl_Position, and by how it affects the lighting and stroke width\n <mask>     vec2 flat_controls[3];\n <mask>     flatten_points(controls, flat_controls);\n <mask> \n <mask>     // Set joint angles, etc.\n <mask>     find_joint_info();\n <mask> \n <mask>     // Corners of a bounding region around curve </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove         // vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n        vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z); </s> add         vec3 xyz_coords = vec3(corners[i], verts[index_map[i]].z); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     find_joint_info();\n <mask> \n <mask>     // Corners of a bounding region around curve\n <mask>     vec2 corners[5];\n <mask>     int n_corners = get_corners(flat_controls, degree, scaled_strokes, corners);\n <mask> \n <mask>     int index_map[5] = int[5](0, 0, 1, 2, 2);\n <mask>     if(n_corners == 4) index_map[2] = 2;\n <mask> \n <mask>     // Find uv conversion matrix </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove         // vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n        vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z); </s> add         vec3 xyz_coords = vec3(corners[i], verts[index_map[i]].z); </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>     for(int i = 0; i < n_corners; i++){\n <mask>         uv_coords = (xy_to_uv * vec3(corners[i], 1.0)).xy;\n <mask>         uv_stroke_width = scaled_strokes[index_map[i]] / scale_factor;\n <mask>         // Apply some lighting to the color before sending out.\n <mask>         // vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n <mask>         vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n <mask>         color = finalize_color(\n <mask>             v_color[index_map[i]],\n <mask>             xyz_coords,\n <mask>             unit_normal,\n <mask>             light_source_position, </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     bp = position_point_into_frame(point); </s> add     verts = position_point_into_frame(point); </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n}", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             shadow\n <mask>         );\n <mask>         gl_Position = vec4(\n <mask>             get_gl_Position(vec3(corners[i], 0.0)).xy,\n <mask>             get_gl_Position(controls[index_map[i]]).zw\n <mask>         );\n <mask>         EmitVertex();\n <mask>     }\n <mask>     EndPrimitive();\n <mask> } </s> Minor simplifications for stroke shader </s> remove void set_adjascent_info(vec2 c0, vec2 tangent, </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove     bp = position_point_into_frame(point); </s> add     verts = position_point_into_frame(point); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     flatten_points(controls, flat_controls); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    }", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> in float stroke_width;\n <mask> in vec4 color;\n <mask> \n <mask> // Bezier control point\n <mask> out vec3 bp;\n <mask> \n <mask> out float v_joint_angle;\n <mask> out float v_stroke_width;\n <mask> out vec4 v_color;\n <mask>  </s> remove in vec3 bp[3]; </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/vert.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> #INSERT position_point_into_frame.glsl\n <mask> \n <mask> void main(){\n <mask>     bp = position_point_into_frame(point);\n <mask> \n <mask>     v_stroke_width = STROKE_WIDTH_CONVERSION * stroke_width * frame_shape[1] / 8.0;\n <mask>     v_joint_angle = joint_angle;\n <mask>     v_color = color;\n <mask> } </s> Minor simplifications for stroke shader </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){ </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove         // vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n        vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z); </s> add         vec3 xyz_coords = vec3(corners[i], verts[index_map[i]].z); </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/vert.glsl"}
{"docstring_tokens": "keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask> import os\n <mask> import numpy as np\n <mask> \n <mask> \n <mask> GENERALLY_BUFFER_POINTS = True\n <mask> \n <mask> PRODUCTION_QUALITY_DISPLAY_CONFIG = {\n <mask>     \"height\"         : 1440,\n <mask>     \"width\"          : 2560,\n <mask>     \"frame_duration\" : 0.04,\n <mask> } </s> add def adjusted_thickness(thickness, width, height):\n    big_width = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"width\"]\n    big_height = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"height\"]\n    factor = (big_width + big_height) / (width + height)\n    return 1 + (thickness-1)/factor", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "constants.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>     \"\"\"\n <mask>     Imagine dragging each pixel around like a paintbrush in\n <mask>     a plus-sign-shaped pixel arrangement surrounding it\n <mask>     \"\"\"\n <mask>     original = np.array(pixel_indices)\n <mask>     original_rgbs = np.array(rgbs)\n <mask>     for nudge in range(-thickness/2+1, thickness/2+1):\n <mask>         if nudge == 0:\n <mask>             continue\n <mask>         for x, y in [[nudge, 0], [0, nudge]]: </s> add         if nudge == 0:\n            continue </s> add def adjusted_thickness(thickness, width, height):\n    big_width = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"width\"]\n    big_height = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"height\"]\n    factor = (big_width + big_height) / (width + height)\n    return 1 + (thickness-1)/factor </s> add         \"point_thickness\" : DEFAULT_POINT_THICKNESS,", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "displayer.py"}
{"docstring_tokens": "keep add keep keep keep keep keep", "code_tokens": " <mask>     original_rgbs = np.array(rgbs)\n <mask>     for nudge in range(-thickness/2+1, thickness/2+1):\n <mask>         for x, y in [[nudge, 0], [0, nudge]]:\n <mask>             pixel_indices = np.append(\n <mask>                 pixel_indices, \n <mask>                 original+[x, y], \n <mask>                 axis = 0 </s> add     thickness = adjusted_thickness(thickness, width, height) </s> add def adjusted_thickness(thickness, width, height):\n    big_width = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"width\"]\n    big_height = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"height\"]\n    factor = (big_width + big_height) / (width + height)\n    return 1 + (thickness-1)/factor </s> add         \"point_thickness\" : DEFAULT_POINT_THICKNESS,", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "displayer.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>                   (pixel_indices[:,0] < width) & \\\n <mask>                   (pixel_indices[:,1] >= 0) & \\\n <mask>                   (pixel_indices[:,1] < height)\n <mask>     return pixel_indices[admissibles], rgbs[admissibles]\n <mask>     \n <mask> \n <mask> def place_on_screen(points, rgbs, space_width, space_height):\n <mask>     \"\"\"\n <mask>     Projects points to 2d space and remove those outside a\n <mask>     the space constraints </s> add         \"point_thickness\" : DEFAULT_POINT_THICKNESS, </s> add     thickness = adjusted_thickness(thickness, width, height)", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "displayer.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     \"\"\"\n <mask>     #Number of numbers used to describe a point (3 for pos, 3 for normal vector)\n <mask>     DEFAULT_CONFIG = {\n <mask>         \"color\" : \"white\",\n <mask>         \"point_thickness\" : 4,\n <mask>         \"name\" : None,\n <mask>     }\n <mask>     DIM = 3\n <mask>     def __init__(self, **kwargs):\n <mask>         digest_config(self, Mobject, kwargs) </s> remove         digest_config(self, Mobject1D, kwargs) </s> add         digest_config(self, Mobject2D, kwargs)", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "mobject/mobject.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask>         vector_coords = [-1, 2]\n <mask> \n <mask>         vector = self.move_matrix_columns(transposed_matrix, vector_coords)\n <mask>         self.scale_and_add(vector, vector_coords)\n <mask> \n <mask>     def move_matrix_columns(self, transposed_matrix, vector_coords = None):\n <mask>         matrix = np.array(transposed_matrix).transpose()\n <mask>         matrix_mob = Matrix(matrix)\n </s> About to start chapter 5 </s> remove         questions = map(TextMobject, [\n            \"Can you visualize these transformations?\",\n            \"Can you represent them with matrices?\",\n            \"How many rows and columns?\",\n            \"When does it make sense to multiply these matrices?\",\n        ])\n        nums = VMobject(*[\n            TexMobject(\"%d.\"%(num+1))\n            for num in range(len(questions))\n        ])\n        nums.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n        nums.to_edge(LEFT)\n        for num, question in zip(nums.split(), questions):\n            question.scale(0.8)\n            question.next_to(num)\n            self.play(Write(num), FadeIn(question))\n </s> add         questions = VMobject(*map(TextMobject, [\n            \"1. Can you visualize these transformations?\",\n            \"2. Can you represent them with matrices?\",\n            \"3. How many rows and columns?\",\n            \"4. When can you multiply these matrices?\",\n        ]))\n        questions.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n        questions.to_edge(LEFT)\n        for question in questions.split():\n            self.play(Write(question, run_time = 1)) </s> add class ComputerGraphicsAndRobotics(Scene):\n    def construct(self):\n        mob = VMobject(\n            TextMobject(\"Computer graphics\"),\n            TextMobject(\"Robotics\")\n        )\n        mob.arrange_submobjects(DOWN, buff = 1)\n        self.play(Write(mob, run_time = 1))\n        self.dither()\n", "html_url": "https://github.com/3b1b/manim/commit/014b7bfdef961acc4bf1717599b3276a484109d6", "file_name": "eola/chapter3.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask> \n <mask> class ApplyTwoSuccessiveTransforms(Scene):\n <mask>     pass\n <mask> \n <mask> class ThreeDRotation(Scene):\n <mask>     pass\n <mask> \n <mask> class ThreeDRotationBrokenUp(Scene):\n </s> About to start chapter 5 </s> remove         questions = map(TextMobject, [\n            \"Can you visualize these transformations?\",\n            \"Can you represent them with matrices?\",\n            \"How many rows and columns?\",\n            \"When does it make sense to multiply these matrices?\",\n        ])\n        nums = VMobject(*[\n            TexMobject(\"%d.\"%(num+1))\n            for num in range(len(questions))\n        ])\n        nums.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n        nums.to_edge(LEFT)\n        for num, question in zip(nums.split(), questions):\n            question.scale(0.8)\n            question.next_to(num)\n            self.play(Write(num), FadeIn(question))\n </s> add         questions = VMobject(*map(TextMobject, [\n            \"1. Can you visualize these transformations?\",\n            \"2. Can you represent them with matrices?\",\n            \"3. How many rows and columns?\",\n            \"4. When can you multiply these matrices?\",\n        ]))\n        questions.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n        questions.to_edge(LEFT)\n        for question in questions.split():\n            self.play(Write(question, run_time = 1)) </s> add         self.dither(3)", "html_url": "https://github.com/3b1b/manim/commit/014b7bfdef961acc4bf1717599b3276a484109d6", "file_name": "eola/footnote.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     def construct(self):\n <mask>         title = TextMobject(\"Questions to ponder\")\n <mask>         title.highlight(YELLOW).to_edge(UP)\n <mask>         self.add(title)\n <mask>         questions = map(TextMobject, [\n <mask>             \"Can you visualize these transformations?\",\n <mask>             \"Can you represent them with matrices?\",\n <mask>             \"How many rows and columns?\",\n <mask>             \"When does it make sense to multiply these matrices?\",\n <mask>         ])\n <mask>         nums = VMobject(*[\n <mask>             TexMobject(\"%d.\"%(num+1))\n <mask>             for num in range(len(questions))\n <mask>         ])\n <mask>         nums.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n <mask>         nums.to_edge(LEFT)\n <mask>         for num, question in zip(nums.split(), questions):\n <mask>             question.scale(0.8)\n <mask>             question.next_to(num)\n <mask>             self.play(Write(num), FadeIn(question))\n <mask>             self.dither()\n <mask> \n <mask> class NextVideo(Scene):\n <mask>     def construct(self):\n <mask>         title = TextMobject(\"\"\"\n </s> About to start chapter 5 </s> add class ComputerGraphicsAndRobotics(Scene):\n    def construct(self):\n        mob = VMobject(\n            TextMobject(\"Computer graphics\"),\n            TextMobject(\"Robotics\")\n        )\n        mob.arrange_submobjects(DOWN, buff = 1)\n        self.play(Write(mob, run_time = 1))\n        self.dither()\n </s> add         self.dither(3)", "html_url": "https://github.com/3b1b/manim/commit/014b7bfdef961acc4bf1717599b3276a484109d6", "file_name": "eola/footnote.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> from camera import Camera\n <mask> from mobject.svg_mobject import *\n <mask> from mobject.tex_mobject import *\n <mask> \n <mask> from eoc.chapter1 import OpeningQuote, PatreonThanks\n <mask> from eoc.graph_scene import *\n <mask> \n <mask> class LastVideo(TeacherStudentsScene):\n <mask>     def construct(self):\n <mask>         series = VideoSeries() </s> add     def any_pi_creatures_on_screen(self):\n        mobjects = self.get_mobjects()\n        return any([pi in mobjects for pi in self.get_pi_creatures()])\n\n    def get_on_screen_pi_creatures(self):\n        mobjects = self.get_mobjects()\n        return VGroup(*filter(\n            lambda pi : pi in mobjects,\n            self.get_pi_creatures()\n        ))", "html_url": "https://github.com/3b1b/manim/commit/01630a495885c380e027b50cdf4ae4a298a8fe37", "file_name": "eoc/exp_footnote.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         known_formulas.arrange_submobjects(\n <mask>             DOWN, buff = MED_LARGE_BUFF,\n <mask>         )\n <mask>         known_formulas.scale_to_fit_height(2.5)\n <mask>         exp_question = TexMobject(\"2^x, 7^x, e^x ???\")\n <mask> \n <mask>         last_video_brace = Brace(last_video)\n <mask>         known_formulas.next_to(last_video_brace, DOWN)\n <mask>         last_video_brace.save_state()\n <mask>         last_video_brace.shift(3*LEFT) </s> add     def force_skipping(self):\n        self.original_skipping_status = self.skip_animations\n        self.skip_animations = True\n        return self\n\n    def revert_to_original_skipping_status(self):\n        if hasattr(self, \"original_skipping_status\"):\n            self.skip_animations = self.original_skipping_status\n        return self </s> add     def any_pi_creatures_on_screen(self):\n        mobjects = self.get_mobjects()\n        return any([pi in mobjects for pi in self.get_pi_creatures()])\n\n    def get_on_screen_pi_creatures(self):\n        mobjects = self.get_mobjects()\n        return VGroup(*filter(\n            lambda pi : pi in mobjects,\n            self.get_pi_creatures()\n        )) </s> remove         if not any([pi in self.get_mobjects() for pi in self.get_pi_creatures()]):", "html_url": "https://github.com/3b1b/manim/commit/01630a495885c380e027b50cdf4ae4a298a8fe37", "file_name": "eoc/exp_footnote.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask> class PiCreatureScene(Scene):\n <mask>     CONFIG = {\n <mask>         \"total_dither_time\" : 0,\n <mask>         \"seconds_to_blink\" : 3,\n <mask>     }\n <mask>     def setup(self):\n <mask>         self.pi_creatures = VGroup(*self.create_pi_creatures())\n <mask>         if self.pi_creatures_start_on_screen: </s> remove         self.add(*self.pi_creatures) </s> add         if self.pi_creatures_start_on_screen:\n            self.add(*self.pi_creatures) </s> add         self.play(Blink(random.choice(self.get_on_screen_pi_creatures())))\n\n    def joint_blink(self, pi_creatures = None, shuffle = True, **kwargs):\n        if pi_creatures is None:\n            pi_creatures = self.get_on_screen_pi_creatures()\n        creatures_list = list(pi_creatures)\n        if shuffle:\n            random.shuffle(creatures_list)\n\n        def get_rate_func(pi):\n            index = creatures_list.index(pi)\n            proportion = float(index)/len(creatures_list)\n            start_time = 0.8*proportion\n            return squish_rate_func(\n                there_and_back,\n                start_time, start_time + 0.2\n            )\n\n        self.play(*[\n            Blink(pi, rate_func = get_rate_func(pi), **kwargs)\n            for pi in creatures_list\n        ])\n        return self </s> add     def any_pi_creatures_on_screen(self):\n        mobjects = self.get_mobjects()\n        return any([pi in mobjects for pi in self.get_pi_creatures()])\n\n    def get_on_screen_pi_creatures(self):\n        mobjects = self.get_mobjects()\n        return VGroup(*filter(\n            lambda pi : pi in mobjects,\n            self.get_pi_creatures()\n        )) </s> remove             if blink and self.total_dither_time%self.seconds_to_blink == 0: </s> add             time_to_blink = self.total_dither_time%self.seconds_to_blink == 0\n            if blink and self.any_pi_creatures_on_screen() and time_to_blink:", "html_url": "https://github.com/3b1b/manim/commit/01630a495885c380e027b50cdf4ae4a298a8fe37", "file_name": "topics/characters.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"seconds_to_blink\" : 3,\n <mask>     }\n <mask>     def setup(self):\n <mask>         self.pi_creatures = VGroup(*self.create_pi_creatures())\n <mask>         self.add(*self.pi_creatures)\n <mask> \n <mask>     def create_pi_creatures(self):\n <mask>         \"\"\" \n <mask>         Likely updated for subclasses \n <mask>         \"\"\" </s> add         \"pi_creatures_start_on_screen\" : True, </s> add         if not self.any_pi_creatures_on_screen(): </s> add     def any_pi_creatures_on_screen(self):\n        mobjects = self.get_mobjects()\n        return any([pi in mobjects for pi in self.get_pi_creatures()])\n\n    def get_on_screen_pi_creatures(self):\n        mobjects = self.get_mobjects()\n        return VGroup(*filter(\n            lambda pi : pi in mobjects,\n            self.get_pi_creatures()\n        )) </s> add         self.play(Blink(random.choice(self.get_on_screen_pi_creatures())))\n\n    def joint_blink(self, pi_creatures = None, shuffle = True, **kwargs):\n        if pi_creatures is None:\n            pi_creatures = self.get_on_screen_pi_creatures()\n        creatures_list = list(pi_creatures)\n        if shuffle:\n            random.shuffle(creatures_list)\n\n        def get_rate_func(pi):\n            index = creatures_list.index(pi)\n            proportion = float(index)/len(creatures_list)\n            start_time = 0.8*proportion\n            return squish_rate_func(\n                there_and_back,\n                start_time, start_time + 0.2\n            )\n\n        self.play(*[\n            Blink(pi, rate_func = get_rate_func(pi), **kwargs)\n            for pi in creatures_list\n        ])\n        return self </s> remove             if blink and self.total_dither_time%self.seconds_to_blink == 0: </s> add             time_to_blink = self.total_dither_time%self.seconds_to_blink == 0\n            if blink and self.any_pi_creatures_on_screen() and time_to_blink:", "html_url": "https://github.com/3b1b/manim/commit/01630a495885c380e027b50cdf4ae4a298a8fe37", "file_name": "topics/characters.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def get_primary_pi_creature(self):\n <mask>         return self.pi_creatures[0]\n <mask> \n <mask>     def introduce_bubble(\n <mask>         self, \n <mask>         pi_creature,\n <mask>         bubble_class,\n <mask>         content = None, </s> add         if self.pi_creatures_start_on_screen:\n            self.add(*self.pi_creatures)", "html_url": "https://github.com/3b1b/manim/commit/01630a495885c380e027b50cdf4ae4a298a8fe37", "file_name": "topics/characters.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         Add animations so that all pi creatures look at the \n <mask>         first mobject being animated with each .play call\n <mask>         \"\"\"\n <mask>         animations = Scene.compile_play_args_to_animation_list(self, *args)\n <mask>         if not any([pi in self.get_mobjects() for pi in self.get_pi_creatures()]):\n <mask>             return animations\n <mask> \n <mask>         non_pi_creature_anims = filter(\n <mask>             lambda anim : anim.mobject not in self.get_pi_creatures(),\n <mask>             animations </s> add     def any_pi_creatures_on_screen(self):\n        mobjects = self.get_mobjects()\n        return any([pi in mobjects for pi in self.get_pi_creatures()])\n\n    def get_on_screen_pi_creatures(self):\n        mobjects = self.get_mobjects()\n        return VGroup(*filter(\n            lambda pi : pi in mobjects,\n            self.get_pi_creatures()\n        )) </s> remove         self.play(Blink(random.choice(self.get_pi_creatures()))) </s> add     def force_skipping(self):\n        self.original_skipping_status = self.skip_animations\n        self.skip_animations = True\n        return self\n\n    def revert_to_original_skipping_status(self):\n        if hasattr(self, \"original_skipping_status\"):\n            self.skip_animations = self.original_skipping_status\n        return self", "html_url": "https://github.com/3b1b/manim/commit/01630a495885c380e027b50cdf4ae4a298a8fe37", "file_name": "topics/characters.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep", "code_tokens": " <mask> from mobject.svg_mobject import *\n <mask> from mobject.tex_mobject import *\n <mask> from topics.graph_scene import *\n <mask> \n <mask> class AddingPureFrequencies(PiCreatureScene):\n <mask>     CONFIG = {\n <mask>         \"A_frequency\" : 2.1,\n <mask>         \"A_color\" : YELLOW,\n <mask>         \"D_color\" : PINK, </s> Further additions to AddingPureFrequencies Scene of Fourier </s> add     CONFIG = {\n        \"A_frequency\" : 2.1,\n        \"A_color\" : YELLOW,\n        \"D_color\" : PINK,\n        \"sum_color\" : GREEN,\n        \"equilibrium_height\" : 1.5,\n    } </s> remove         frequency = 1.2\n        func = self.get_wave_func(frequency, axes)\n        graph = axes.get_graph(func)\n        graph.highlight(YELLOW) </s> add         frequency = self.A_frequency\n        graph = self.get_wave_graph(frequency, axes)\n        func = graph.underlying_function\n        graph.highlight(self.A_color)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask> #revert_to_original_skipping_status\n <mask> \n <mask> class AddingPureFrequencies(PiCreatureScene):\n <mask>     def construct(self):\n <mask>         self.force_skipping()\n <mask> \n <mask>         self.add_speaker()\n <mask>         self.play_A440()\n <mask>         self.measure_air_pressure() </s> Further additions to AddingPureFrequencies Scene of Fourier </s> remove     def play_a440(self): </s> add     def play_A440(self): </s> remove         a440_label = TextMobject(\"A440\")\n        a440_label.next_to(self.speaker, UP) </s> add         A_label = TextMobject(\"A440\")\n        A_label.highlight(self.A_color)\n        A_label.next_to(self.speaker, UP)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     def construct(self):\n <mask>         self.force_skipping()\n <mask> \n <mask>         self.add_speaker()\n <mask>         self.play_a440()\n <mask>         self.measure_air_pressure()\n <mask>         self.play_lower_pitch()\n <mask>         self.play_mix()\n <mask>         self.separate_out_parts()\n <mask>         self.add_more_notes() </s> remove     def play_a440(self): </s> add     def play_A440(self): </s> remove         a440_label = TextMobject(\"A440\")\n        a440_label.next_to(self.speaker, UP) </s> add         A_label = TextMobject(\"A440\")\n        A_label.highlight(self.A_color)\n        A_label.next_to(self.speaker, UP)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>         self.play_lower_pitch()\n <mask>         self.play_mix()\n <mask>         self.separate_out_parts()\n <mask>         self.add_more_notes()\n <mask> \n <mask>     def add_speaker(self):\n <mask>         speaker = SVGMobject(file_name = \"speaker\")\n <mask>         speaker.to_edge(DOWN)\n <mask>  </s> add         A_label = TextMobject(\"A440\")\n        A_label.highlight(self.A_color)\n        A_label.next_to(self.speaker, UP) </s> remove         frequency = 1.2\n        func = self.get_wave_func(frequency, axes)\n        graph = axes.get_graph(func)\n        graph.highlight(YELLOW) </s> add         frequency = self.A_frequency\n        graph = self.get_wave_graph(frequency, axes)\n        func = graph.underlying_function\n        graph.highlight(self.A_color) </s> add         axes.shift(LARGE_BUFF*DOWN)\n        eh = self.equilibrium_height\n        equilibrium_line = DashedLine(\n            axes.coords_to_point(0, eh),\n            axes.coords_to_point(axes.x_max, eh),\n            stroke_width = 2,\n            stroke_color = LIGHT_GREY\n        )", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace keep replace replace keep", "code_tokens": " <mask> \n <mask>         self.add(speaker)\n <mask>         self.speaker = speaker\n <mask> \n <mask>     def play_a440(self):\n <mask>         randy = self.pi_creature\n <mask>         a440_label = TextMobject(\"A440\")\n <mask>         a440_label.next_to(self.speaker, UP)\n <mask>  </s> remove             FadeIn(a440_label), </s> remove         self.set_variables_as_attrs(a440_label)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep replace keep keep keep", "code_tokens": " <mask>         a440_label = TextMobject(\"A440\")\n <mask>         a440_label.next_to(self.speaker, UP)\n <mask> \n <mask>         self.broadcast(\n <mask>             FadeIn(a440_label),\n <mask>             randy.change, \"pondering\"\n <mask>         )\n <mask>         self.dither()\n <mask> \n <mask>         self.set_variables_as_attrs(a440_label)\n <mask> \n <mask>     def measure_air_pressure(self):\n <mask>         randy = self.pi_creature </s> remove         a440_label = TextMobject(\"A440\")\n        a440_label.next_to(self.speaker, UP) </s> add         A_label = TextMobject(\"A440\")\n        A_label.highlight(self.A_color)\n        A_label.next_to(self.speaker, UP) </s> remove     def play_a440(self): </s> add     def play_A440(self):", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def measure_air_pressure(self):\n <mask>         randy = self.pi_creature\n <mask>         axes = Axes(\n <mask>             y_min = -1, y_max = 3,\n <mask>             x_min = 0, x_max = 10,\n <mask>             number_line_config = {\"include_tip\" : False},\n <mask>         )\n <mask>         axes.stretch_to_fit_height(2)\n <mask>         axes.to_corner(UP+LEFT) </s> remove         axes.shift(MED_LARGE_BUFF*DOWN) </s> add         axes.shift(LARGE_BUFF*DOWN)\n        eh = self.equilibrium_height\n        equilibrium_line = DashedLine(\n            axes.coords_to_point(0, eh),\n            axes.coords_to_point(axes.x_max, eh),\n            stroke_width = 2,\n            stroke_color = LIGHT_GREY\n        ) </s> remove         frequency = 1.2\n        func = self.get_wave_func(frequency, axes)\n        graph = axes.get_graph(func)\n        graph.highlight(YELLOW) </s> add         frequency = self.A_frequency\n        graph = self.get_wave_graph(frequency, axes)\n        func = graph.underlying_function\n        graph.highlight(self.A_color) </s> add         A_label = TextMobject(\"A440\")\n        A_label.highlight(self.A_color)\n        A_label.next_to(self.speaker, UP) </s> add         axes = self.axes\n        A_label = self.A_label\n        D_label = self.D_label\n        \n        A_group = VGroup(self.A_axes, self.A_graph)\n        D_group = VGroup(self.D_axes, self.D_graph)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep replace keep replace replace replace replace keep keep", "code_tokens": " <mask>         axes.stretch_to_fit_height(2)\n <mask>         axes.to_corner(UP+LEFT)\n <mask>         axes.shift(MED_LARGE_BUFF*DOWN)\n <mask> \n <mask>         frequency = 1.2\n <mask>         func = self.get_wave_func(frequency, axes)\n <mask>         graph = axes.get_graph(func)\n <mask>         graph.highlight(YELLOW)\n <mask>         pressure = TextMobject(\"Pressure\")\n <mask>         pressure.next_to(axes.y_axis, UP) </s> remove         pressure.next_to(axes.y_axis, UP)\n        pressure.shift_onto_screen() </s> add         for label in pressure, time:\n            label.scale_in_place(0.8)\n        pressure.next_to(axes.y_axis, UP)\n        pressure.to_edge(LEFT, buff = MED_SMALL_BUFF) </s> remove             return value + 1.5\n        return func </s> add             return value + self.equilibrium_height\n        ngp = 2*(x_max - x_min)*frequency + 1\n        graph = axes.get_graph(func, num_graph_points = ngp)\n        return graph\n\n    def get_A_graph_v_line(self, x):\n        return self.get_graph_v_line(x, self.A_axes, self.A_graph)\n\n    def get_D_graph_v_line(self, x):\n        return self.get_graph_v_line(x, self.D_axes, self.D_graph)\n\n    def get_graph_v_line(self, x, axes, graph):\n        result = Line(\n            axes.coords_to_point(x, self.equilibrium_height),\n            # axes.coords_to_point(x, graph.underlying_function(x)),\n            graph.point_from_proportion(float(x)/axes.x_max),\n            color = WHITE,\n            buff = 0,\n        )\n        return result\n    \n    def stack_v_lines(self, x, lines):\n        point = self.axes.coords_to_point(x, self.equilibrium_height)\n        A_line, D_line = lines\n        A_line.shift(point - A_line.get_start())\n        D_line.shift(A_line.get_end()-D_line.get_start())\n        A_line.highlight(self.A_color)\n        D_line.highlight(self.D_color)\n        return lines", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         func = self.get_wave_func(frequency, axes)\n <mask>         graph = axes.get_graph(func)\n <mask>         graph.highlight(YELLOW)\n <mask>         pressure = TextMobject(\"Pressure\")\n <mask>         pressure.next_to(axes.y_axis, UP)\n <mask>         pressure.shift_onto_screen()\n <mask>         time = TextMobject(\"Time\")\n <mask>         time.next_to(axes.x_axis.get_right(), DOWN+LEFT)\n <mask>         axes.labels = VGroup(pressure, time)\n <mask>         axes.add(axes.labels)\n <mask>  </s> remove         frequency = 1.2\n        func = self.get_wave_func(frequency, axes)\n        graph = axes.get_graph(func)\n        graph.highlight(YELLOW) </s> add         frequency = self.A_frequency\n        graph = self.get_wave_graph(frequency, axes)\n        func = graph.underlying_function\n        graph.highlight(self.A_color) </s> add         for label in pressure, time:\n            label.scale_in_place(0.8)\n        pressure.next_to(axes.y_axis, UP)\n        pressure.to_edge(LEFT, buff = MED_SMALL_BUFF) </s> remove         axes.add(axes.labels) </s> remove         axes.shift(MED_LARGE_BUFF*DOWN) </s> add         axes.shift(LARGE_BUFF*DOWN)\n        eh = self.equilibrium_height\n        equilibrium_line = DashedLine(\n            axes.coords_to_point(0, eh),\n            axes.coords_to_point(axes.x_max, eh),\n            stroke_width = 2,\n            stroke_color = LIGHT_GREY\n        ) </s> remove             axes.coords_to_point(7/frequency, func(7/frequency)),\n            axes.coords_to_point(8/frequency, func(8/frequency)), </s> add             axes.coords_to_point(n/frequency, func(n/frequency)),\n            axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)),", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>         graph.highlight(self.A_color)\n <mask>         pressure = TextMobject(\"Pressure\")\n <mask>         time = TextMobject(\"Time\")\n <mask>         time.next_to(axes.x_axis.get_right(), DOWN+LEFT)\n <mask>         axes.labels = VGroup(pressure, time)\n <mask> \n <mask>         n = 10 </s> remove         pressure.next_to(axes.y_axis, UP)\n        pressure.shift_onto_screen() </s> remove         axes.add(axes.labels) </s> remove         frequency = 1.2\n        func = self.get_wave_func(frequency, axes)\n        graph = axes.get_graph(func)\n        graph.highlight(YELLOW) </s> add         frequency = self.A_frequency\n        graph = self.get_wave_graph(frequency, axes)\n        func = graph.underlying_function\n        graph.highlight(self.A_color) </s> remove             axes.coords_to_point(7/frequency, func(7/frequency)),\n            axes.coords_to_point(8/frequency, func(8/frequency)), </s> add             axes.coords_to_point(n/frequency, func(n/frequency)),\n            axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)),", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         pressure.shift_onto_screen()\n <mask>         time = TextMobject(\"Time\")\n <mask>         time.next_to(axes.x_axis.get_right(), DOWN+LEFT)\n <mask>         axes.labels = VGroup(pressure, time)\n <mask>         axes.add(axes.labels)\n <mask> \n <mask>         brace = Brace(Line(\n <mask>             axes.coords_to_point(7/frequency, func(7/frequency)),\n <mask>             axes.coords_to_point(8/frequency, func(8/frequency)),\n <mask>         ), UP) </s> remove             axes.coords_to_point(7/frequency, func(7/frequency)),\n            axes.coords_to_point(8/frequency, func(8/frequency)), </s> add             axes.coords_to_point(n/frequency, func(n/frequency)),\n            axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)), </s> remove         pressure.next_to(axes.y_axis, UP)\n        pressure.shift_onto_screen() </s> add         for label in pressure, time:\n            label.scale_in_place(0.8)\n        pressure.next_to(axes.y_axis, UP)\n        pressure.to_edge(LEFT, buff = MED_SMALL_BUFF) </s> remove         frequency = 1.2\n        func = self.get_wave_func(frequency, axes)\n        graph = axes.get_graph(func)\n        graph.highlight(YELLOW) </s> add         frequency = self.A_frequency\n        graph = self.get_wave_graph(frequency, axes)\n        func = graph.underlying_function\n        graph.highlight(self.A_color)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep add keep keep keep keep keep keep", "code_tokens": " <mask>         axes.labels = VGroup(pressure, time)\n <mask> \n <mask>         brace = Brace(Line(\n <mask>             axes.coords_to_point(n/frequency, func(n/frequency)),\n <mask>             axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)),\n <mask>         ), UP)\n <mask>         words = brace.get_text(\"Imagine 440 per second\", buff = SMALL_BUFF)\n <mask>         words.scale(0.8, about_point = words.get_bottom()) </s> add         words.scale(0.8, about_point = words.get_bottom()) </s> remove             axes.coords_to_point(7/frequency, func(7/frequency)),\n            axes.coords_to_point(8/frequency, func(8/frequency)), </s> add             axes.coords_to_point(n/frequency, func(n/frequency)),\n            axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)), </s> remove         axes.add(axes.labels) </s> add         for label in pressure, time:\n            label.scale_in_place(0.8)\n        pressure.next_to(axes.y_axis, UP)\n        pressure.to_edge(LEFT, buff = MED_SMALL_BUFF) </s> remove         pressure.next_to(axes.y_axis, UP)\n        pressure.shift_onto_screen()", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         axes.labels = VGroup(pressure, time)\n <mask>         axes.add(axes.labels)\n <mask> \n <mask>         brace = Brace(Line(\n <mask>             axes.coords_to_point(7/frequency, func(7/frequency)),\n <mask>             axes.coords_to_point(8/frequency, func(8/frequency)),\n <mask>         ), UP)\n <mask>         words = brace.get_text(\"Imagine 440 per second\", buff = SMALL_BUFF)\n <mask> \n <mask>         self.revert_to_original_skipping_status()\n <mask>         self.play( </s> remove         axes.add(axes.labels) </s> add         words.scale(0.8, about_point = words.get_bottom()) </s> remove         pressure.next_to(axes.y_axis, UP)\n        pressure.shift_onto_screen() </s> add         for label in pressure, time:\n            label.scale_in_place(0.8)\n        pressure.next_to(axes.y_axis, UP)\n        pressure.to_edge(LEFT, buff = MED_SMALL_BUFF)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep", "code_tokens": " <mask>             axes.coords_to_point(n/frequency, func(n/frequency)),\n <mask>             axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)),\n <mask>         ), UP)\n <mask>         words = brace.get_text(\"Imagine 440 per second\", buff = SMALL_BUFF)\n <mask> \n <mask>         self.play(\n <mask>             FadeIn(pressure),\n <mask>             ShowCreation(axes.y_axis)\n <mask>         ) </s> remove             axes.coords_to_point(7/frequency, func(7/frequency)),\n            axes.coords_to_point(8/frequency, func(8/frequency)), </s> add             axes.coords_to_point(n/frequency, func(n/frequency)),\n            axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)), </s> remove         axes.add(axes.labels) </s> add         for label in pressure, time:\n            label.scale_in_place(0.8)\n        pressure.next_to(axes.y_axis, UP)\n        pressure.to_edge(LEFT, buff = MED_SMALL_BUFF)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             axes.coords_to_point(8/frequency, func(8/frequency)),\n <mask>         ), UP)\n <mask>         words = brace.get_text(\"Imagine 440 per second\", buff = SMALL_BUFF)\n <mask> \n <mask>         self.revert_to_original_skipping_status()\n <mask>         self.play(\n <mask>             FadeIn(pressure),\n <mask>             ShowCreation(axes.y_axis)\n <mask>         )\n <mask>         self.play( </s> add         words.scale(0.8, about_point = words.get_bottom()) </s> remove             axes.coords_to_point(7/frequency, func(7/frequency)),\n            axes.coords_to_point(8/frequency, func(8/frequency)), </s> add             axes.coords_to_point(n/frequency, func(n/frequency)),\n            axes.coords_to_point((n+1)/frequency, func((n+1)/frequency)), </s> remove         axes.add(axes.labels)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep", "code_tokens": " <mask>             ShowCreation(axes.x_axis)\n <mask>         )\n <mask>         self.dither()\n <mask>         self.broadcast(\n <mask>             ShowCreation(graph, run_time = 4, rate_func = None),\n <mask>             ShowCreation(equilibrium_line),\n <mask>         )\n <mask>         axes.add(equilibrium_line)\n <mask>         self.play( </s> add             ShowCreation(equilibrium_line),", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask>         self.dither()\n <mask>         self.broadcast(\n <mask>             ShowCreation(graph, run_time = 4, rate_func = None),\n <mask>             randy.change, \"erm\", graph\n <mask>         )\n <mask>         self.play(\n <mask>             GrowFromCenter(brace),\n <mask>             Write(words)\n <mask>         ) </s> add             randy.change, \"erm\", graph, </s> remove         frequency = 1.2\n        func = self.get_wave_func(frequency, axes)\n        graph = axes.get_graph(func)\n        graph.highlight(YELLOW) </s> add         frequency = self.A_frequency\n        graph = self.get_wave_graph(frequency, axes)\n        func = graph.underlying_function\n        graph.highlight(self.A_color)", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     def separate_out_parts(self):\n <mask>         pass\n <mask> \n <mask>     def add_more_notes(self):\n <mask>         pass\n <mask> \n <mask> \n <mask>     ####\n <mask> \n <mask>     def broadcast(self, *added_anims, **kwargs): </s> add         self.play(self.get_broadcast_animation(**kwargs), *added_anims)\n\n    def get_broadcast_animation(self, **kwargs): </s> remove         kwargs[\"n_circles\"] = kwargs.get(\"n_circles\", 8)\n        self.play(\n            Broadcast(self.speaker[1], **kwargs),\n            *added_anims\n        )", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>     ####\n <mask> \n <mask>     def broadcast(self, *added_anims, **kwargs):\n <mask>         kwargs[\"run_time\"] = kwargs.get(\"run_time\", 5)\n <mask>         kwargs[\"n_circles\"] = kwargs.get(\"n_circles\", 10)\n <mask>         return Broadcast(self.speaker[1], **kwargs)\n <mask> \n <mask>     def get_wave_graph(self, frequency, axes):\n <mask>         tail_len = 3.0 </s> remove         kwargs[\"n_circles\"] = kwargs.get(\"n_circles\", 8)\n        self.play(\n            Broadcast(self.speaker[1], **kwargs),\n            *added_anims\n        ) </s> add         kwargs[\"n_circles\"] = kwargs.get(\"n_circles\", 10)\n        return Broadcast(self.speaker[1], **kwargs) </s> add             return value + self.equilibrium_height\n        ngp = 2*(x_max - x_min)*frequency + 1\n        graph = axes.get_graph(func, num_graph_points = ngp)\n        return graph\n\n    def get_A_graph_v_line(self, x):\n        return self.get_graph_v_line(x, self.A_axes, self.A_graph)\n\n    def get_D_graph_v_line(self, x):\n        return self.get_graph_v_line(x, self.D_axes, self.D_graph)\n\n    def get_graph_v_line(self, x, axes, graph):\n        result = Line(\n            axes.coords_to_point(x, self.equilibrium_height),\n            # axes.coords_to_point(x, graph.underlying_function(x)),\n            graph.point_from_proportion(float(x)/axes.x_max),\n            color = WHITE,\n            buff = 0,\n        )\n        return result\n    \n    def stack_v_lines(self, x, lines):\n        point = self.axes.coords_to_point(x, self.equilibrium_height)\n        A_line, D_line = lines\n        A_line.shift(point - A_line.get_start())\n        D_line.shift(A_line.get_end()-D_line.get_start())\n        A_line.highlight(self.A_color)\n        D_line.highlight(self.D_color)\n        return lines", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep keep replace replace replace replace replace keep replace keep keep keep keep", "code_tokens": " <mask> \n <mask>     def broadcast(self, *added_anims, **kwargs):\n <mask>         kwargs[\"run_time\"] = kwargs.get(\"run_time\", 5)\n <mask>         kwargs[\"n_circles\"] = kwargs.get(\"n_circles\", 8)\n <mask>         self.play(\n <mask>             Broadcast(self.speaker[1], **kwargs),\n <mask>             *added_anims\n <mask>         )\n <mask> \n <mask>     def get_wave_func(self, frequency, axes):\n <mask>         tail_len = 3.0\n <mask>         x_min, x_max = axes.x_min, axes.x_max\n <mask>         def func(x):\n <mask>             value = 0.8*np.cos(2*np.pi*frequency*x) </s> add         self.play(self.get_broadcast_animation(**kwargs), *added_anims)\n\n    def get_broadcast_animation(self, **kwargs): </s> remove             value = 0.8*np.cos(2*np.pi*frequency*x) </s> add             return value + self.equilibrium_height\n        ngp = 2*(x_max - x_min)*frequency + 1\n        graph = axes.get_graph(func, num_graph_points = ngp)\n        return graph\n\n    def get_A_graph_v_line(self, x):\n        return self.get_graph_v_line(x, self.A_axes, self.A_graph)\n\n    def get_D_graph_v_line(self, x):\n        return self.get_graph_v_line(x, self.D_axes, self.D_graph)\n\n    def get_graph_v_line(self, x, axes, graph):\n        result = Line(\n            axes.coords_to_point(x, self.equilibrium_height),\n            # axes.coords_to_point(x, graph.underlying_function(x)),\n            graph.point_from_proportion(float(x)/axes.x_max),\n            color = WHITE,\n            buff = 0,\n        )\n        return result\n    \n    def stack_v_lines(self, x, lines):\n        point = self.axes.coords_to_point(x, self.equilibrium_height)\n        A_line, D_line = lines\n        A_line.shift(point - A_line.get_start())\n        D_line.shift(A_line.get_end()-D_line.get_start())\n        A_line.highlight(self.A_color)\n        D_line.highlight(self.D_color)\n        return lines", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep replace keep keep keep keep replace replace replace", "code_tokens": " <mask>         def func(x):\n <mask>             value = 0.8*np.cos(2*np.pi*frequency*x)\n <mask>             if x - x_min < tail_len:\n <mask>                 value *= smooth((x-x_min)/tail_len)\n <mask>             if x_max - x < tail_len:\n <mask>                 value *= smooth((x_max - x )/tail_len)\n <mask>             return value + 1.5\n <mask>         return func\n <mask>  </s> remove             y_min = -1, y_max = 3, </s> add             y_min = -2, y_max = 2,", "html_url": "https://github.com/3b1b/manim/commit/016e2c9adafba3b78b16adbd8d791bef4194dbaf", "file_name": "active_projects/fourier.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>     def pointwise_become_partial(self, vmobject: VMobject, a: float, b: float):\n <mask>         assert(isinstance(vmobject, VMobject))\n <mask>         vm_points = vmobject.get_points()\n <mask>         if a <= 0 and b >= 1:\n <mask>             self.set_points(vm_points, refresh_joints=False)\n <mask>             return self\n <mask>         num_curves = vmobject.get_num_curves() </s> remove             self.set_points(vm_points) </s> add             self.set_points(vm_points, refresh_joints=False)", "html_url": "https://github.com/3b1b/manim/commit/018b07212fec690b7e5c2617f22fd809c42c80d3", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     def pointwise_become_partial(self, vmobject: VMobject, a: float, b: float):\n <mask>         assert(isinstance(vmobject, VMobject))\n <mask>         vm_points = vmobject.get_points()\n <mask>         if a <= 0 and b >= 1:\n <mask>             self.set_points(vm_points)\n <mask>             return self\n <mask>         num_curves = vmobject.get_num_curves()\n <mask> \n <mask>         # Partial curve includes three portions:\n <mask>         # - A start, which is some ending portion of an inner quadratic </s> add         self.data[\"joint_product\"] = vmobject.data[\"joint_product\"]", "html_url": "https://github.com/3b1b/manim/commit/018b07212fec690b7e5c2617f22fd809c42c80d3", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             new_points[i1:i2] = low_tup\n <mask>             # Keep new_points i2:i3 as they are\n <mask>             new_points[i3:i4] = high_tup\n <mask>             new_points[i4:] = high_tup[2]\n <mask>         self.set_points(new_points)\n <mask>         return self\n <mask> \n <mask>     def get_subcurve(self, a: float, b: float) -> VMobject:\n <mask>         vmob = self.copy()\n <mask>         vmob.pointwise_become_partial(self, a, b) </s> remove             self.set_points(vm_points) </s> add             self.set_points(vm_points, refresh_joints=False) </s> remove     def set_points(self, points: Vect3Array): </s> add     def set_points(self, points: Vect3Array, refresh_joints: bool = True): </s> add         if refresh_joints:\n            self.get_joint_products(refresh=True)", "html_url": "https://github.com/3b1b/manim/commit/018b07212fec690b7e5c2617f22fd809c42c80d3", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep keep replace keep keep keep replace keep keep", "code_tokens": " <mask>             return self\n <mask>         return wrapper\n <mask> \n <mask>     def set_points(self, points: Vect3Array):\n <mask>         assert(len(points) == 0 or len(points) % 2 == 1)\n <mask>         super().set_points(points)\n <mask>         self.refresh_triangulation()\n <mask>         self.get_joint_products(refresh=True)\n <mask>         return self\n <mask>  </s> remove             self.set_points(vm_points) </s> add             self.set_points(vm_points, refresh_joints=False) </s> remove         self.set_points(new_points) </s> add         self.data[\"joint_product\"][:i1] = [0, 0, 0, 1]\n        self.data[\"joint_product\"][i4:] = [0, 0, 0, 1]\n        self.set_points(new_points, refresh_joints=False)", "html_url": "https://github.com/3b1b/manim/commit/018b07212fec690b7e5c2617f22fd809c42c80d3", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     return m + frac_diff\n <mask> \n <mask> # TODO?: Perhaps use modulus of (uniform) continuity instead of num_checkpoints, calculating \n <mask> # latter as needed from former?\n <mask> def make_alpha_winder(func, start, end, num_checkpoints):\n <mask>     check_points = [None for i in range(num_checkpoints)]\n <mask>     check_points[0] = func(start)\n <mask>     step_size = fdiv(end - start, num_checkpoints)\n <mask>     for i in range(num_checkpoints - 1):\n <mask>         check_points[i + 1] = \\ </s> remove                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints) </s> add                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints, cheap = self.use_cheap_winding_numbers) </s> remove         return resit_near(func(x), check_points[index]) </s> add         if cheap:\n            return check_points[index] # A more principled test that at least returns a reasonable answer\n        else:\n            return resit_near(func(x), check_points[index])", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>             func(start + (i + 1) * step_size),\n <mask>             check_points[i])\n <mask>     def return_func(alpha):\n <mask>         index = clamp(0, num_checkpoints - 1, int(alpha * num_checkpoints))\n <mask>         x = interpolate(start, end, alpha)\n <mask>         if cheap:\n <mask>             return check_points[index] # A more principled test that at least returns a reasonable answer\n <mask>         else:\n <mask>             return resit_near(func(x), check_points[index]) </s> remove         return resit_near(func(x), check_points[index]) </s> add         if cheap:\n            return check_points[index] # A more principled test that at least returns a reasonable answer\n        else:\n            return resit_near(func(x), check_points[index]) </s> remove                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints) </s> add                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints, cheap = self.use_cheap_winding_numbers) </s> remove def make_alpha_winder(func, start, end, num_checkpoints): </s> add #\n# \"cheap\" argument only used for diagnostic testing right now\ndef make_alpha_winder(func, start, end, num_checkpoints, cheap = False):", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             check_points[i])\n <mask>     def return_func(alpha):\n <mask>         index = clamp(0, num_checkpoints - 1, int(alpha * num_checkpoints))\n <mask>         x = interpolate(start, end, alpha)\n <mask>         return resit_near(func(x), check_points[index])\n <mask>     return return_func\n <mask> \n <mask> # The various inconsistent choices of what datatype to use where are a bit of a mess,\n <mask> # but I'm more keen to rush this video out now than to sort this out.\n <mask>  </s> add         if cheap:\n            return alpha # A test to see if this func is responsible for slowdown </s> remove def make_alpha_winder(func, start, end, num_checkpoints): </s> add #\n# \"cheap\" argument only used for diagnostic testing right now\ndef make_alpha_winder(func, start, end, num_checkpoints, cheap = False): </s> add         \"use_separate_plays\" : False,\n\n        \"use_cheap_winding_numbers\" : False, # To use this, make num_checkpoints large </s> remove                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints) </s> add                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints, cheap = self.use_cheap_winding_numbers)", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep replace keep keep keep keep keep keep keep keep replace", "code_tokens": " <mask> \n <mask>     def play_in_bfs(self, scene):\n <mask>         bfs_nodes = self.hacky_bfs()\n <mask>         print \"Number of nodes: \", len(bfs_nodes)\n <mask>         for node in bfs_nodes:\n <mask>             scene.play(node.first_anim)\n <mask> \n <mask>     def play_in_bfs(self, scene):\n <mask>         bfs_nodes = self.hacky_bfs()\n <mask>         print \"Number of nodes: \", len(bfs_nodes)\n <mask>         for node in bfs_nodes: </s> remove         if self.diagnostic_branch:\n            node.play_in_bfs(self)\n            return\n\n        self.play(anim, border_anim) </s> add         if self.use_separate_plays:\n            node.play_in_bfs(self, border_anim)\n        else:\n            self.play(anim, border_anim)", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep", "code_tokens": " <mask>         \"display_in_bfs\" : False,\n <mask> \n <mask>         \"use_fancy_lines\" : True,\n <mask>         # TODO: Consider adding a \"find_all_roots\" flag, which could be turned off \n <mask>         # to only explore one of the two candidate subrectangles when both are viable\n <mask> \n <mask>         # Walker settings\n <mask>         \"show_arrows\" : True, </s> remove         \"func\" : plane_func_from_complex_func(lambda c : (2 * c)**5 - (2 * c) - 1),\n        \"diagnostic_branch\" : True,\n        \"show_winding_numbers\" : False,\n        \"use_fancy_lines\" : False, \n        \"camera_config\" : {\"use_z_coordinate_for_display_order\": False}\n    } </s> add         # I think the combination of these two makes things slow\n        \"use_separate_plays\" : not False, # This one isn't important to set any particular way, so let's leave it like this\n        \"use_fancy_lines\" : True, \n\n        # This causes a small slowdown (before rendering, in particular), but not the big one, I think\n        \"show_winding_numbers\" : True,\n\n        # This doesn't significantly matter for rendering time, I think\n        \"camera_config\" : {\"use_z_coordinate_for_display_order\" : True}\n    }\n\n# All above flags False (meaning not db = False): just under 30 it/s\n# not db = True: 30\n# use_fancy_lines = True: 30 at first (if scene.play(bfs_nodes[0].first_anim, border_anim is off), but then drops to 3 (or drops right away if that simultaneous play is on)\n# use_z_coordinate = True: 30\n# show_winding_numbers = True: 10\n# winding AND use_fancy_lines: 10\n# not db AND fancy_lines AND z_coords = true, winding = false: 3. Not 30, but 3. Slow.\n# db AND use_fancy: 3. Slow.\n# fancy AND z_coords: 30. Fast. [Hm, this may have been a mistake; fancy and z_coords is now slow?]\n# fancy, winding, AND z_coords, but not (not db): 10\n# not db, winding, AND z_coords, but not fancy: 10\n\n# class DiagnosticB(Diagnostic):\n#     CONFIG = {\n#         \"num_iterations\" : 3,\n#         #\"num_checkpoints\" : 100,\n#         #\"show_winding_numbers\" : False,\n#         #\"use_cheap_winding_numbers\" : True,\n#     }", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"show_cursor\" : True,\n <mask> \n <mask>         \"linger_parameter\" : 0.5,\n <mask> \n <mask>         \"diagnostic_branch\" : False\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         if self.num_iterations == 0:\n <mask>             print \"You forgot to set num_iterations (maybe you meant to subclass something other than EquationSolver2d directly?)\" </s> remove class Diagnostic(Scene):\n    def construct(self):\n        testList = map(lambda n : (n, rev_to_rgba(n)), [0, 0.1, 0.2, 0.3, 0.4])\n        print \"Here you go:\", testList\n        self.wait()\n\nclass DiagnosticColorMap(PureColorMap):\n    CONFIG = {\n        \"func\" : lambda (x, y) : (25 * x, 25 * y),\n        \"show_num_plane\" : False,\n    } </s> remove         \"func\" : plane_func_from_complex_func(lambda c : (2 * c)**5 - (2 * c) - 1),\n        \"diagnostic_branch\" : True,\n        \"show_winding_numbers\" : False,\n        \"use_fancy_lines\" : False, \n        \"camera_config\" : {\"use_z_coordinate_for_display_order\": False}\n    }", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         num_plane = self.num_plane\n <mask> \n <mask>         clockwise_val_func = lambda p : -point_to_rev(self.func(p))\n <mask> \n <mask>         base_line = Line(UP, RIGHT, stroke_width = border_stroke_width, color = WHITE)\n <mask> \n <mask>         if self.use_fancy_lines:\n <mask>             base_line.color_using_background_image(self.background_image_file)\n <mask> \n <mask>         def match_style_with_bg(obj1, obj2): </s> remove                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints) </s> add                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints, cheap = self.use_cheap_winding_numbers) </s> remove class Diagnostic(Scene):\n    def construct(self):\n        testList = map(lambda n : (n, rev_to_rgba(n)), [0, 0.1, 0.2, 0.3, 0.4])\n        print \"Here you go:\", testList\n        self.wait()\n\nclass DiagnosticColorMap(PureColorMap):\n    CONFIG = {\n        \"func\" : lambda (x, y) : (25 * x, 25 * y),\n        \"show_num_plane\" : False,\n    } </s> remove         \"func\" : plane_func_from_complex_func(lambda c : (2 * c)**5 - (2 * c) - 1),\n        \"diagnostic_branch\" : True,\n        \"show_winding_numbers\" : False,\n        \"use_fancy_lines\" : False, \n        \"camera_config\" : {\"use_z_coordinate_for_display_order\": False}\n    } </s> add         # I think the combination of these two makes things slow\n        \"use_separate_plays\" : not False, # This one isn't important to set any particular way, so let's leave it like this\n        \"use_fancy_lines\" : True, \n\n        # This causes a small slowdown (before rendering, in particular), but not the big one, I think\n        \"show_winding_numbers\" : True,\n\n        # This doesn't significantly matter for rendering time, I think\n        \"camera_config\" : {\"use_z_coordinate_for_display_order\" : True}\n    }\n\n# All above flags False (meaning not db = False): just under 30 it/s\n# not db = True: 30\n# use_fancy_lines = True: 30 at first (if scene.play(bfs_nodes[0].first_anim, border_anim is off), but then drops to 3 (or drops right away if that simultaneous play is on)\n# use_z_coordinate = True: 30\n# show_winding_numbers = True: 10\n# winding AND use_fancy_lines: 10\n# not db AND fancy_lines AND z_coords = true, winding = false: 3. Not 30, but 3. Slow.\n# db AND use_fancy: 3. Slow.\n# fancy AND z_coords: 30. Fast. [Hm, this may have been a mistake; fancy and z_coords is now slow?]\n# fancy, winding, AND z_coords, but not (not db): 10\n# not db, winding, AND z_coords, but not fancy: 10\n\n# class DiagnosticB(Diagnostic):\n#     CONFIG = {\n#         \"num_iterations\" : 3,\n#         #\"num_checkpoints\" : 100,\n#         #\"show_winding_numbers\" : False,\n#         #\"use_cheap_winding_numbers\" : True,\n#     }", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             if cur_depth >= self.num_iterations:\n <mask>                 return EquationSolver2dNode(empty_animation)\n <mask> \n <mask>             def draw_line_return_wind(start, end, start_wind, should_linger = False, draw_line = True):\n <mask>                 alpha_winder = make_alpha_winder(clockwise_val_func, start, end, self.num_checkpoints)\n <mask>                 a0 = alpha_winder(0)\n <mask>                 rebased_winder = lambda alpha: alpha_winder(alpha) - a0 + start_wind\n <mask>                 colored_line = Line(num_plane.coords_to_point(*start) + IN, num_plane.coords_to_point(*end) + IN)\n <mask>                 match_style_with_bg(colored_line, base_line)\n <mask>  </s> remove def make_alpha_winder(func, start, end, num_checkpoints): </s> remove         base_line = Line(UP, RIGHT, stroke_width = border_stroke_width, color = WHITE) </s> add         base_line = Line(UP, RIGHT, stroke_width = border_stroke_width, color = self.line_color) </s> remove class Diagnostic(Scene):\n    def construct(self):\n        testList = map(lambda n : (n, rev_to_rgba(n)), [0, 0.1, 0.2, 0.3, 0.4])\n        print \"Here you go:\", testList\n        self.wait()\n\nclass DiagnosticColorMap(PureColorMap):\n    CONFIG = {\n        \"func\" : lambda (x, y) : (25 * x, 25 * y),\n        \"show_num_plane\" : False,\n    }", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask> \n <mask>         print \"About to do the big Play; for reference, the current time is \", time.strftime(\"%H:%M:%S\")\n <mask> \n <mask>         if self.diagnostic_branch:\n <mask>             node.play_in_bfs(self)\n <mask>             return\n <mask> \n <mask>         self.play(anim, border_anim)\n <mask> \n <mask>         print \"All done; for reference, the current time is \", time.strftime(\"%H:%M:%S\")\n <mask> \n <mask>         self.wait()\n <mask>  </s> add         # I think the combination of these two makes things slow\n        \"use_separate_plays\" : not False, # This one isn't important to set any particular way, so let's leave it like this\n        \"use_fancy_lines\" : True, \n\n        # This causes a small slowdown (before rendering, in particular), but not the big one, I think\n        \"show_winding_numbers\" : True,\n\n        # This doesn't significantly matter for rendering time, I think\n        \"camera_config\" : {\"use_z_coordinate_for_display_order\" : True}\n    }\n\n# All above flags False (meaning not db = False): just under 30 it/s\n# not db = True: 30\n# use_fancy_lines = True: 30 at first (if scene.play(bfs_nodes[0].first_anim, border_anim is off), but then drops to 3 (or drops right away if that simultaneous play is on)\n# use_z_coordinate = True: 30\n# show_winding_numbers = True: 10\n# winding AND use_fancy_lines: 10\n# not db AND fancy_lines AND z_coords = true, winding = false: 3. Not 30, but 3. Slow.\n# db AND use_fancy: 3. Slow.\n# fancy AND z_coords: 30. Fast. [Hm, this may have been a mistake; fancy and z_coords is now slow?]\n# fancy, winding, AND z_coords, but not (not db): 10\n# not db, winding, AND z_coords, but not fancy: 10\n\n# class DiagnosticB(Diagnostic):\n#     CONFIG = {\n#         \"num_iterations\" : 3,\n#         #\"num_checkpoints\" : 100,\n#         #\"show_winding_numbers\" : False,\n#         #\"use_cheap_winding_numbers\" : True,\n#     } </s> add         \"line_color\" : WHITE, # Only used for non-fancy lines </s> add         if cheap:\n            return alpha # A test to see if this func is responsible for slowdown </s> remove class Diagnostic(Scene):\n    def construct(self):\n        testList = map(lambda n : (n, rev_to_rgba(n)), [0, 0.1, 0.2, 0.3, 0.4])\n        print \"Here you go:\", testList\n        self.wait()\n\nclass DiagnosticColorMap(PureColorMap):\n    CONFIG = {\n        \"func\" : lambda (x, y) : (25 * x, 25 * y),\n        \"show_num_plane\" : False,\n    }", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep keep replace keep replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask>         \"display_in_bfs\" : True,\n <mask>     }\n <mask> \n <mask> class DiagnosticE2d(SolveX5MinusXMinus1_5Iterations):\n <mask>     CONFIG = {\n <mask>         \"func\" : plane_func_from_complex_func(lambda c : (2 * c)**5 - (2 * c) - 1),\n <mask>         \"diagnostic_branch\" : True,\n <mask>         \"show_winding_numbers\" : False,\n <mask>         \"use_fancy_lines\" : False, \n <mask>         \"camera_config\" : {\"use_z_coordinate_for_display_order\": False}\n <mask>     }\n <mask> \n <mask> class SolveX5MinusXMinus1Parallel(SolveX5MinusXMinus1):\n <mask>     CONFIG = { </s> add         \"func\" : plane_func_by_wind_spec(\n            (-3, -1.3, 2), (0.1, 0.2, 1), (2.8, -2, 1)\n        ), </s> remove class Diagnostic(Scene):\n    def construct(self):\n        testList = map(lambda n : (n, rev_to_rgba(n)), [0, 0.1, 0.2, 0.3, 0.4])\n        print \"Here you go:\", testList\n        self.wait()\n\nclass DiagnosticColorMap(PureColorMap):\n    CONFIG = {\n        \"func\" : lambda (x, y) : (25 * x, 25 * y),\n        \"show_num_plane\" : False,\n    } </s> remove         \"diagnostic_branch\" : False", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     }\n <mask> \n <mask> class ParallelClip(EquationSolver2d):\n <mask>     CONFIG = {\n <mask>         \"func\" : example_plane_func,\n <mask>         \"num_iterations\" : 5,\n <mask>         \"display_in_parallel\" : True,\n <mask>     }\n <mask> \n <mask> class EquationSolver2dMatchBreakdown(EquationSolver2d): </s> remove class Diagnostic(Scene):\n    def construct(self):\n        testList = map(lambda n : (n, rev_to_rgba(n)), [0, 0.1, 0.2, 0.3, 0.4])\n        print \"Here you go:\", testList\n        self.wait()\n\nclass DiagnosticColorMap(PureColorMap):\n    CONFIG = {\n        \"func\" : lambda (x, y) : (25 * x, 25 * y),\n        \"show_num_plane\" : False,\n    } </s> remove class DiagnosticE2d(SolveX5MinusXMinus1_5Iterations): </s> remove         \"func\" : plane_func_from_complex_func(lambda c : (2 * c)**5 - (2 * c) - 1),\n        \"diagnostic_branch\" : True,\n        \"show_winding_numbers\" : False,\n        \"use_fancy_lines\" : False, \n        \"camera_config\" : {\"use_z_coordinate_for_display_order\": False}\n    }", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     CONFIG = {\n <mask>          \"func\" : plane_func_by_wind_spec((1, 2), (-1, 1.5), (-1, 1.5))\n <mask>     }\n <mask> \n <mask> class Diagnostic(Scene):\n <mask>     def construct(self):\n <mask>         testList = map(lambda n : (n, rev_to_rgba(n)), [0, 0.1, 0.2, 0.3, 0.4])\n <mask>         print \"Here you go:\", testList\n <mask>         self.wait()\n <mask> \n <mask> class DiagnosticColorMap(PureColorMap):\n <mask>     CONFIG = {\n <mask>         \"func\" : lambda (x, y) : (25 * x, 25 * y),\n <mask>         \"show_num_plane\" : False,\n <mask>     }\n <mask> \n <mask> class PiWalkerOdometerTest(PiWalkerExamplePlaneFunc):\n <mask>     CONFIG = {\n <mask>         \"display_odometer\" : True\n <mask>     }\n <mask>  </s> remove         \"func\" : example_plane_func, </s> add         \"func\" : plane_func_by_wind_spec(\n            (-3, -1.3, 2), (0.1, 0.2, 1), (2.8, -2, 1)\n        ), </s> remove         \"func\" : plane_func_from_complex_func(lambda c : (2 * c)**5 - (2 * c) - 1),\n        \"diagnostic_branch\" : True,\n        \"show_winding_numbers\" : False,\n        \"use_fancy_lines\" : False, \n        \"camera_config\" : {\"use_z_coordinate_for_display_order\": False}\n    } </s> add         # I think the combination of these two makes things slow\n        \"use_separate_plays\" : not False, # This one isn't important to set any particular way, so let's leave it like this\n        \"use_fancy_lines\" : True, \n\n        # This causes a small slowdown (before rendering, in particular), but not the big one, I think\n        \"show_winding_numbers\" : True,\n\n        # This doesn't significantly matter for rendering time, I think\n        \"camera_config\" : {\"use_z_coordinate_for_display_order\" : True}\n    }\n\n# All above flags False (meaning not db = False): just under 30 it/s\n# not db = True: 30\n# use_fancy_lines = True: 30 at first (if scene.play(bfs_nodes[0].first_anim, border_anim is off), but then drops to 3 (or drops right away if that simultaneous play is on)\n# use_z_coordinate = True: 30\n# show_winding_numbers = True: 10\n# winding AND use_fancy_lines: 10\n# not db AND fancy_lines AND z_coords = true, winding = false: 3. Not 30, but 3. Slow.\n# db AND use_fancy: 3. Slow.\n# fancy AND z_coords: 30. Fast. [Hm, this may have been a mistake; fancy and z_coords is now slow?]\n# fancy, winding, AND z_coords, but not (not db): 10\n# not db, winding, AND z_coords, but not fancy: 10\n\n# class DiagnosticB(Diagnostic):\n#     CONFIG = {\n#         \"num_iterations\" : 3,\n#         #\"num_checkpoints\" : 100,\n#         #\"show_winding_numbers\" : False,\n#         #\"use_cheap_winding_numbers\" : True,\n#     }", "html_url": "https://github.com/3b1b/manim/commit/01906348000f00fd64bfa7fd16467ce7207a2823", "file_name": "active_projects/WindingNumber.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep", "code_tokens": " <mask> from manimlib.utils.space_ops import angle_of_vector\n <mask> from manimlib.utils.space_ops import complex_to_R3\n <mask> from manimlib.utils.space_ops import rotate_vector\n <mask> \n <mask> \n <mask> class Lightbulb(SVGMobject):\n <mask>     CONFIG = {\n <mask>         \"file_name\": \"lightbulb\", </s> add         if Color(pi_color) == Color(BLACK):\n            pi_color = GREY_D", "html_url": "https://github.com/3b1b/manim/commit/01cda8a1304847a2b27fc60787159eda4290ad9e", "file_name": "manimlib/mobject/svg/drawings.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"height_to_width\": 3.5 / 2.5,\n <mask>         \"card_height_to_symbol_height\": 7,\n <mask>         \"card_width_to_corner_num_width\": 10,\n <mask>         \"card_height_to_corner_num_height\": 10,\n <mask>         \"color\": LIGHT_GREY,\n <mask>         \"turned_over\": False,\n <mask>         \"possible_suits\": [\"hearts\", \"diamonds\", \"spades\", \"clubs\"],\n <mask>         \"possible_values\": list(map(str, list(range(2, 11)))) + [\"J\", \"Q\", \"K\", \"A\"],\n <mask>     }\n <mask>  </s> Fix a few problems with PlayingCard </s> remove     def init_points(self): </s> add         self.key = key </s> remove         except: </s> add         except Exception: </s> remove         from for_3b1b_videos.pi_creature import PiCreature </s> add         from manimlib.for_3b1b_videos.pi_creature import PiCreature </s> remove                 ])[string.upper(self.key[-1])] </s> add                 ])[self.key[-1].upper()]", "html_url": "https://github.com/3b1b/manim/commit/01cda8a1304847a2b27fc60787159eda4290ad9e", "file_name": "manimlib/mobject/svg/drawings.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"possible_values\": list(map(str, list(range(2, 11)))) + [\"J\", \"Q\", \"K\", \"A\"],\n <mask>     }\n <mask> \n <mask>     def __init__(self, key=None, **kwargs):\n <mask>         VGroup.__init__(self, key=key, **kwargs)\n <mask> \n <mask>     def init_points(self):\n <mask>         self.add(Rectangle(\n <mask>             height=self.height,\n <mask>             width=self.height / self.height_to_width, </s> remove     def init_points(self): </s> add         if Color(pi_color) == Color(BLACK):\n            pi_color = GREY_D", "html_url": "https://github.com/3b1b/manim/commit/01cda8a1304847a2b27fc60787159eda4290ad9e", "file_name": "manimlib/mobject/svg/drawings.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def __init__(self, key=None, **kwargs):\n <mask>         VGroup.__init__(self, key=key, **kwargs)\n <mask> \n <mask>     def init_points(self):\n <mask>         self.add(Rectangle(\n <mask>             height=self.height,\n <mask>             width=self.height / self.height_to_width,\n <mask>             stroke_color=WHITE,\n <mask>             stroke_width=2, </s> remove         VGroup.__init__(self, key=key, **kwargs) </s> add         VGroup.__init__(self, **kwargs) </s> add         if Color(pi_color) == Color(BLACK):\n            pi_color = GREY_D", "html_url": "https://github.com/3b1b/manim/commit/01cda8a1304847a2b27fc60787159eda4290ad9e", "file_name": "manimlib/mobject/svg/drawings.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             \"A\": 14,\n <mask>         }\n <mask>         try:\n <mask>             self.numerical_value = int(value)\n <mask>         except:\n <mask>             self.numerical_value = face_card_to_value[value]\n <mask>         return value\n <mask> \n <mask>     def get_symbol(self):\n <mask>         suit = self.suit </s> remove         value = string.upper(str(value)) </s> add         value = str(value).upper()", "html_url": "https://github.com/3b1b/manim/commit/01cda8a1304847a2b27fc60787159eda4290ad9e", "file_name": "manimlib/mobject/svg/drawings.py"}
{"docstring_tokens": "keep keep keep replace keep replace", "code_tokens": " <mask>         if suit is None:\n <mask>             if self.key is not None:\n <mask>                 suit = dict([\n <mask>                     (string.upper(s[0]), s)\n <mask>                     for s in self.possible_suits\n <mask>                 ])[string.upper(self.key[-1])] </s> remove         value = string.upper(str(value)) </s> add         if Color(pi_color) == Color(BLACK):\n            pi_color = GREY_D </s> add         self.key = key", "html_url": "https://github.com/3b1b/manim/commit/01cda8a1304847a2b27fc60787159eda4290ad9e", "file_name": "manimlib/mobject/svg/drawings.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         for mob in self.get_family():\n <mask>             mob.needs_new_joint_angles = True\n <mask>         return self\n <mask> \n <mask>     def get_joint_angles(self):\n <mask>         if not self.needs_new_joint_angles:\n <mask>             return self.data[\"joint_angle\"]\n <mask> \n <mask>         self.needs_new_joint_angles = False\n <mask> \n <mask>         points = self.get_points()\n </s> More tiny tweaks for joint_angles </s> add             for mob in (self, vmobject):\n                mob.get_joint_angles() </s> remove         self.data[\"joint_angle\"][:, 0] = sgn * angle\n </s> add         self.data[\"joint_angle\"][:len(angle), 0] = sgn * angle", "html_url": "https://github.com/3b1b/manim/commit/0205a3720973aef34512ac765d83400f9efdb97e", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         # Compute angles\n <mask>         dots = (vect_to_vert * vect_from_vert).sum(1)\n <mask>         angle = np.arccos(arr_clip(dots, -1, 1))\n <mask>         sgn = np.sign(cross2d(vect_to_vert, vect_from_vert))\n <mask>         self.data[\"joint_angle\"][:, 0] = sgn * angle\n <mask> \n <mask>         # If a given anchor point sits at the end of a curve,\n <mask>         # we set its angle equal to 0\n <mask>         ends_mismatch = (a1[-1] != a0[0]).any()\n <mask>         if ends_mismatch:\n </s> More tiny tweaks for joint_angles </s> add             for mob in (self, vmobject):\n                mob.get_joint_angles() </s> remove     def get_joint_angles(self):\n        if not self.needs_new_joint_angles:\n </s> add     def get_joint_angles(self, refresh: bool = False):\n        if not self.needs_new_joint_angles and not refresh:", "html_url": "https://github.com/3b1b/manim/commit/0205a3720973aef34512ac765d83400f9efdb97e", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> from active_projects.ode.part1.pendulum import *\n <mask> from active_projects.ode.part1.staging import *\n <mask> from active_projects.ode.part1.pi_scenes import *\n <mask> from active_projects.ode.part1.phase_space import *\n <mask> from active_projects.ode.part1.wordy_scenes import *\n <mask> \n <mask> OUTPUT_DIRECTORY = \"ode/part1\"\n <mask> SCENES_IN_ORDER = [\n <mask>     WhenChangeIsEasier,\n <mask>     VectorFieldTest, </s> remove from active_projects.ode.part4.staging import *\nfrom active_projects.ode.part4.fourier_series_scenes import *\nfrom active_projects.ode.part4.pi_creature_scenes import * </s> add from active_projects.diffyq.part4.staging import *\nfrom active_projects.diffyq.part4.fourier_series_scenes import *\nfrom active_projects.diffyq.part4.pi_creature_scenes import * </s> remove from active_projects.ode.part3.staging import *\nfrom active_projects.ode.part3.temperature_graphs import *\nfrom active_projects.ode.part3.pi_creature_scenes import *\nfrom active_projects.ode.part3.wordy_scenes import *\nfrom active_projects.ode.part3.discrete_case import * </s> add from active_projects.diffyq.part3.staging import *\nfrom active_projects.diffyq.part3.temperature_graphs import *\nfrom active_projects.diffyq.part3.pi_creature_scenes import *\nfrom active_projects.diffyq.part3.wordy_scenes import *\nfrom active_projects.diffyq.part3.discrete_case import * </s> remove from active_projects.ode.part2.staging import *\nfrom active_projects.ode.part2.fourier_series import *\nfrom active_projects.ode.part2.heat_equation import *\nfrom active_projects.ode.part2.pi_scenes import *\nfrom active_projects.ode.part2.wordy_scenes import * </s> add from active_projects.diffyq.part2.staging import *\nfrom active_projects.diffyq.part2.fourier_series import *\nfrom active_projects.diffyq.part2.heat_equation import *\nfrom active_projects.diffyq.part2.pi_scenes import *\nfrom active_projects.diffyq.part2.wordy_scenes import * </s> remove from active_projects.ode.part1.shared_constructs import *\nfrom active_projects.ode.part1.pendulum import Pendulum\nfrom active_projects.ode.part1.pendulum import ThetaVsTAxes\nfrom active_projects.ode.part1.phase_space import IntroduceVectorField </s> add from active_projects.diffyq.part1.shared_constructs import *\nfrom active_projects.diffyq.part1.pendulum import Pendulum\nfrom active_projects.diffyq.part1.pendulum import ThetaVsTAxes\nfrom active_projects.diffyq.part1.phase_space import IntroduceVectorField </s> remove from active_projects.ode.part1.staging import TourOfDifferentialEquations", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/all_part1_scenes.py"}
{"docstring_tokens": "replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> from active_projects.ode.part2.staging import *\n <mask> from active_projects.ode.part2.fourier_series import *\n <mask> from active_projects.ode.part2.heat_equation import *\n <mask> from active_projects.ode.part2.pi_scenes import *\n <mask> from active_projects.ode.part2.wordy_scenes import *\n <mask> \n <mask> OUTPUT_DIRECTORY = \"ode/part2\"\n <mask> SCENES_IN_ORDER = [\n <mask>     PartTwoOfTour,\n <mask>     HeatEquationIntroTitle, </s> remove from active_projects.ode.part3.staging import *\nfrom active_projects.ode.part3.temperature_graphs import *\nfrom active_projects.ode.part3.pi_creature_scenes import *\nfrom active_projects.ode.part3.wordy_scenes import *\nfrom active_projects.ode.part3.discrete_case import * </s> remove from active_projects.ode.part1.pendulum import *\nfrom active_projects.ode.part1.staging import *\nfrom active_projects.ode.part1.pi_scenes import *\nfrom active_projects.ode.part1.phase_space import *\nfrom active_projects.ode.part1.wordy_scenes import * </s> remove from active_projects.ode.part2.heat_equation import * </s> add from active_projects.diffyq.part2.heat_equation import * </s> remove from active_projects.ode.part2.heat_equation import * </s> add from active_projects.diffyq.part2.heat_equation import * </s> remove from active_projects.ode.part2.fourier_series import FourierOfName </s> add from active_projects.diffyq.part2.fourier_series import FourierOfName", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/all_part2_scenes.py"}
{"docstring_tokens": "replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> from active_projects.ode.part3.staging import *\n <mask> from active_projects.ode.part3.temperature_graphs import *\n <mask> from active_projects.ode.part3.pi_creature_scenes import *\n <mask> from active_projects.ode.part3.wordy_scenes import *\n <mask> from active_projects.ode.part3.discrete_case import *\n <mask> \n <mask> \n <mask> OUTPUT_DIRECTORY = \"ode/part3\"\n <mask> SCENES_IN_ORDER = [\n <mask>     LastChapterWrapper, </s> remove from active_projects.ode.part4.staging import *\nfrom active_projects.ode.part4.fourier_series_scenes import *\nfrom active_projects.ode.part4.pi_creature_scenes import * </s> add from active_projects.diffyq.part4.staging import *\nfrom active_projects.diffyq.part4.fourier_series_scenes import *\nfrom active_projects.diffyq.part4.pi_creature_scenes import * </s> remove from active_projects.ode.part1.pendulum import *\nfrom active_projects.ode.part1.staging import *\nfrom active_projects.ode.part1.pi_scenes import *\nfrom active_projects.ode.part1.phase_space import *\nfrom active_projects.ode.part1.wordy_scenes import * </s> add from active_projects.diffyq.part1.pendulum import *\nfrom active_projects.diffyq.part1.staging import *\nfrom active_projects.diffyq.part1.pi_scenes import *\nfrom active_projects.diffyq.part1.phase_space import *\nfrom active_projects.diffyq.part1.wordy_scenes import * </s> remove from active_projects.ode.part2.staging import *\nfrom active_projects.ode.part2.fourier_series import *\nfrom active_projects.ode.part2.heat_equation import *\nfrom active_projects.ode.part2.pi_scenes import *\nfrom active_projects.ode.part2.wordy_scenes import * </s> add from active_projects.diffyq.part2.staging import *\nfrom active_projects.diffyq.part2.fourier_series import *\nfrom active_projects.diffyq.part2.heat_equation import *\nfrom active_projects.diffyq.part2.pi_scenes import *\nfrom active_projects.diffyq.part2.wordy_scenes import *", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/all_part3_scenes.py"}
{"docstring_tokens": "replace replace replace keep keep keep keep keep", "code_tokens": " <mask> from active_projects.ode.part4.staging import *\n <mask> from active_projects.ode.part4.fourier_series_scenes import *\n <mask> from active_projects.ode.part4.pi_creature_scenes import *\n <mask> \n <mask> OUTPUT_DIRECTORY = \"ode/part4\"\n <mask> SCENES_IN_ORDER = [\n <mask>     ComplexFourierSeriesExample,\n <mask>     ComplexFourierSeriesExampleEnd, </s> remove from active_projects.ode.part3.staging import *\nfrom active_projects.ode.part3.temperature_graphs import *\nfrom active_projects.ode.part3.pi_creature_scenes import *\nfrom active_projects.ode.part3.wordy_scenes import *\nfrom active_projects.ode.part3.discrete_case import * </s> add from active_projects.diffyq.part3.staging import *\nfrom active_projects.diffyq.part3.temperature_graphs import *\nfrom active_projects.diffyq.part3.pi_creature_scenes import *\nfrom active_projects.diffyq.part3.wordy_scenes import *\nfrom active_projects.diffyq.part3.discrete_case import * </s> remove from active_projects.ode.part1.pendulum import *\nfrom active_projects.ode.part1.staging import *\nfrom active_projects.ode.part1.pi_scenes import *\nfrom active_projects.ode.part1.phase_space import *\nfrom active_projects.ode.part1.wordy_scenes import * </s> add from active_projects.diffyq.part1.pendulum import *\nfrom active_projects.diffyq.part1.staging import *\nfrom active_projects.diffyq.part1.pi_scenes import *\nfrom active_projects.diffyq.part1.phase_space import *\nfrom active_projects.diffyq.part1.wordy_scenes import * </s> remove from active_projects.ode.part2.staging import *\nfrom active_projects.ode.part2.fourier_series import *\nfrom active_projects.ode.part2.heat_equation import *\nfrom active_projects.ode.part2.pi_scenes import *\nfrom active_projects.ode.part2.wordy_scenes import * </s> add from active_projects.diffyq.part2.staging import *\nfrom active_projects.diffyq.part2.fourier_series import *\nfrom active_projects.diffyq.part2.heat_equation import *\nfrom active_projects.diffyq.part2.pi_scenes import *\nfrom active_projects.diffyq.part2.wordy_scenes import * </s> remove from active_projects.ode.part2.fourier_series import FourierOfName </s> add from active_projects.diffyq.part2.fourier_series import FourierOfName", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/all_part4_scenes.py"}
{"docstring_tokens": "keep keep replace keep keep keep keep keep", "code_tokens": " <mask> #!/usr/bin/env python\n <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part2.fourier_series import FourierOfName\n <mask> \n <mask> name_color_pairs = [\n <mask>     \n <mask> ]\n <mask>  </s> remove from active_projects.ode.part2.staging import *\nfrom active_projects.ode.part2.fourier_series import *\nfrom active_projects.ode.part2.heat_equation import *\nfrom active_projects.ode.part2.pi_scenes import *\nfrom active_projects.ode.part2.wordy_scenes import * </s> add from active_projects.diffyq.part2.staging import *\nfrom active_projects.diffyq.part2.fourier_series import *\nfrom active_projects.diffyq.part2.heat_equation import *\nfrom active_projects.diffyq.part2.pi_scenes import *\nfrom active_projects.diffyq.part2.wordy_scenes import * </s> remove from active_projects.ode.part2.fourier_series import FourierOfTrebleClef </s> add from active_projects.diffyq.part2.fourier_series import FourierOfTrebleClef </s> remove from active_projects.ode.part2.heat_equation import * </s> add from active_projects.diffyq.part2.heat_equation import *", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/name_animations.py"}
{"docstring_tokens": "keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part1.shared_constructs import *\n <mask> \n <mask> \n <mask> class Pendulum(VGroup):\n <mask>     CONFIG = {\n <mask>         \"length\": 3, </s> remove from active_projects.ode.part1.shared_constructs import * </s> remove from active_projects.ode.part2.shared_constructs import * </s> remove from active_projects.ode.part1.shared_constructs import *", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part1/pendulum.py"}
{"docstring_tokens": "keep replace replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part1.shared_constructs import *\n <mask> from active_projects.ode.part1.pendulum import Pendulum\n <mask> \n <mask> \n <mask> # TODO: Arguably separate the part showing many\n <mask> # configurations with the part showing just one.\n <mask> class VisualizeStates(Scene): </s> remove from active_projects.ode.part1.shared_constructs import *\nfrom active_projects.ode.part1.pendulum import Pendulum\nfrom active_projects.ode.part1.pendulum import ThetaVsTAxes\nfrom active_projects.ode.part1.phase_space import IntroduceVectorField </s> add from active_projects.diffyq.part1.shared_constructs import *\nfrom active_projects.diffyq.part1.pendulum import Pendulum\nfrom active_projects.diffyq.part1.pendulum import ThetaVsTAxes\nfrom active_projects.diffyq.part1.phase_space import IntroduceVectorField </s> remove from active_projects.ode.part1.shared_constructs import * </s> remove from active_projects.ode.part1.shared_constructs import * </s> remove from active_projects.ode.part1.shared_constructs import * </s> remove from active_projects.ode.part1.pendulum import *\nfrom active_projects.ode.part1.staging import *\nfrom active_projects.ode.part1.pi_scenes import *\nfrom active_projects.ode.part1.phase_space import *\nfrom active_projects.ode.part1.wordy_scenes import * </s> add from active_projects.diffyq.part1.pendulum import *\nfrom active_projects.diffyq.part1.staging import *\nfrom active_projects.diffyq.part1.pi_scenes import *\nfrom active_projects.diffyq.part1.phase_space import *\nfrom active_projects.diffyq.part1.wordy_scenes import *", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part1/phase_space.py"}
{"docstring_tokens": "keep replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part1.shared_constructs import *\n <mask> from active_projects.ode.part1.pendulum import Pendulum\n <mask> from active_projects.ode.part1.pendulum import ThetaVsTAxes\n <mask> from active_projects.ode.part1.phase_space import IntroduceVectorField\n <mask> from old_projects.div_curl import PhaseSpaceOfPopulationModel\n <mask> from old_projects.div_curl import ShowTwoPopulations\n <mask> \n <mask> \n <mask> # Scenes </s> remove from active_projects.ode.part1.shared_constructs import *\nfrom active_projects.ode.part1.pendulum import Pendulum </s> add from active_projects.diffyq.part1.shared_constructs import *\nfrom active_projects.diffyq.part1.pendulum import Pendulum </s> remove from active_projects.ode.part1.pendulum import *\nfrom active_projects.ode.part1.staging import *\nfrom active_projects.ode.part1.pi_scenes import *\nfrom active_projects.ode.part1.phase_space import *\nfrom active_projects.ode.part1.wordy_scenes import * </s> add from active_projects.diffyq.part1.pendulum import *\nfrom active_projects.diffyq.part1.staging import *\nfrom active_projects.diffyq.part1.pi_scenes import *\nfrom active_projects.diffyq.part1.phase_space import *\nfrom active_projects.diffyq.part1.wordy_scenes import * </s> remove from active_projects.ode.part3.staging import *\nfrom active_projects.ode.part3.temperature_graphs import *\nfrom active_projects.ode.part3.pi_creature_scenes import *\nfrom active_projects.ode.part3.wordy_scenes import *\nfrom active_projects.ode.part3.discrete_case import * </s> add from active_projects.diffyq.part3.staging import *\nfrom active_projects.diffyq.part3.temperature_graphs import *\nfrom active_projects.diffyq.part3.pi_creature_scenes import *\nfrom active_projects.diffyq.part3.wordy_scenes import *\nfrom active_projects.diffyq.part3.discrete_case import * </s> remove from active_projects.ode.part2.staging import *\nfrom active_projects.ode.part2.fourier_series import *\nfrom active_projects.ode.part2.heat_equation import *\nfrom active_projects.ode.part2.pi_scenes import *\nfrom active_projects.ode.part2.wordy_scenes import * </s> add from active_projects.diffyq.part2.staging import *\nfrom active_projects.diffyq.part2.fourier_series import *\nfrom active_projects.diffyq.part2.heat_equation import *\nfrom active_projects.diffyq.part2.pi_scenes import *\nfrom active_projects.diffyq.part2.wordy_scenes import * </s> remove from active_projects.ode.part1.shared_constructs import * </s> remove from active_projects.ode.part1.shared_constructs import *", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part1/staging.py"}
{"docstring_tokens": "keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part2.shared_constructs import *\n <mask> \n <mask> \n <mask> class TwoDBodyWithManyTemperatures(ThreeDScene):\n <mask>     CONFIG = {\n <mask>         \"cells_per_side\": 20, </s> add from active_projects.diffyq.part1.shared_constructs import * </s> add from active_projects.diffyq.part1.shared_constructs import *", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part2/heat_equation.py"}
{"docstring_tokens": "keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part2.wordy_scenes import WriteHeatEquationTemplate\n <mask> \n <mask> \n <mask> class ReactionsToInitialHeatEquation(PiCreatureScene):\n <mask>     def construct(self):\n <mask>         randy = self.pi_creature </s> remove from active_projects.ode.part3.temperature_graphs import TemperatureGraphScene\nfrom active_projects.ode.part2.wordy_scenes import WriteHeatEquationTemplate </s> add from active_projects.diffyq.part3.temperature_graphs import TemperatureGraphScene\nfrom active_projects.diffyq.part2.wordy_scenes import WriteHeatEquationTemplate", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part2/pi_scenes.py"}
{"docstring_tokens": "keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part1.staging import TourOfDifferentialEquations\n <mask> \n <mask> \n <mask> class PartTwoOfTour(TourOfDifferentialEquations):\n <mask>     CONFIG = {\n <mask>         \"zoomed_thumbnail_index\": 1, </s> remove from active_projects.ode.part1.shared_constructs import * </s> remove from active_projects.ode.part2.shared_constructs import * </s> remove from active_projects.ode.part1.shared_constructs import * </s> remove from active_projects.ode.part3.temperature_graphs import TemperatureGraphScene\nfrom active_projects.ode.part2.wordy_scenes import WriteHeatEquationTemplate </s> add from active_projects.diffyq.part3.temperature_graphs import TemperatureGraphScene\nfrom active_projects.diffyq.part2.wordy_scenes import WriteHeatEquationTemplate", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part2/staging.py"}
{"docstring_tokens": "keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part2.wordy_scenes import *\n <mask> \n <mask> \n <mask> class IveHeardOfThis(TeacherStudentsScene):\n <mask>     def construct(self):\n <mask>         point = VectorizedPoint() </s> remove from active_projects.ode.part1.shared_constructs import * </s> add from active_projects.diffyq.part1.shared_constructs import * </s> remove from active_projects.ode.part2.staging import *\nfrom active_projects.ode.part2.fourier_series import *\nfrom active_projects.ode.part2.heat_equation import *\nfrom active_projects.ode.part2.pi_scenes import *\nfrom active_projects.ode.part2.wordy_scenes import * </s> add from active_projects.diffyq.part2.staging import *\nfrom active_projects.diffyq.part2.fourier_series import *\nfrom active_projects.diffyq.part2.heat_equation import *\nfrom active_projects.diffyq.part2.pi_scenes import *\nfrom active_projects.diffyq.part2.wordy_scenes import *", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part3/pi_creature_scenes.py"}
{"docstring_tokens": "keep keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> \n <mask> from active_projects.ode.part2.fourier_series import FourierOfTrebleClef\n <mask> \n <mask> \n <mask> class FourierNameIntro(Scene):\n <mask>     def construct(self):\n <mask>         self.show_two_titles() </s> remove from active_projects.ode.part2.fourier_series import FourierOfName </s> add from active_projects.diffyq.part2.fourier_series import FourierOfName", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part3/staging.py"}
{"docstring_tokens": "keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> from scipy import integrate\n <mask> \n <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part2.heat_equation import *\n <mask> \n <mask> \n <mask> class TemperatureGraphScene(SpecialThreeDScene):\n <mask>     CONFIG = {\n <mask>         \"axes_config\": { </s> remove from active_projects.ode.part2.heat_equation import * </s> add from active_projects.diffyq.part2.heat_equation import * </s> remove from active_projects.ode.part3.temperature_graphs import TemperatureGraphScene\nfrom active_projects.ode.part2.wordy_scenes import WriteHeatEquationTemplate </s> add from active_projects.diffyq.part3.temperature_graphs import TemperatureGraphScene\nfrom active_projects.diffyq.part2.wordy_scenes import WriteHeatEquationTemplate", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part3/temperature_graphs.py"}
{"docstring_tokens": "keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part2.wordy_scenes import *\n <mask> \n <mask> \n <mask> class ThreeMainObservations(Scene):\n <mask>     def construct(self):\n <mask>         fourier = ImageMobject(\"Joseph Fourier\") </s> remove from active_projects.ode.part1.shared_constructs import * </s> remove from active_projects.ode.part2.fourier_series import FourierOfTrebleClef </s> add from active_projects.diffyq.part2.fourier_series import FourierOfTrebleClef </s> remove from active_projects.ode.part2.staging import *\nfrom active_projects.ode.part2.fourier_series import *\nfrom active_projects.ode.part2.heat_equation import *\nfrom active_projects.ode.part2.pi_scenes import *\nfrom active_projects.ode.part2.wordy_scenes import *", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part3/wordy_scenes.py"}
{"docstring_tokens": "keep replace replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.imports import *\n <mask> from active_projects.ode.part3.temperature_graphs import TemperatureGraphScene\n <mask> from active_projects.ode.part2.wordy_scenes import WriteHeatEquationTemplate\n <mask> \n <mask> \n <mask> class RelationToOtherVideos(Scene):\n <mask>     CONFIG = {\n <mask>         \"camera_config\": { </s> remove from active_projects.ode.part2.wordy_scenes import WriteHeatEquationTemplate </s> add from active_projects.diffyq.part2.wordy_scenes import WriteHeatEquationTemplate", "html_url": "https://github.com/3b1b/manim/commit/02413d165af2a126351287dc8ee052921f49aeca", "file_name": "active_projects/diffyq/part4/staging.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask>         return self\n <mask> \n <mask>     # Background rectangle\n <mask>     def add_background_rectangle(self, color=BLACK, opacity=0.75, **kwargs):\n <mask>         from mobject.shape_matchers import BackgroundRectangle\n <mask>         self.background_rectangle = BackgroundRectangle(\n <mask>             self, color=color,\n <mask>             fill_opacity=opacity, </s> remove # TODO list\n# - Make sure if \"color\" is passed into TexMobject, it behaves as expected </s> add     CONFIG = {\n        # To be filled by subclasses\n        \"tex\": None,\n        \"color\": None,\n    }", "html_url": "https://github.com/3b1b/manim/commit/0247224e0799c22951c961566e271825ffd618cc", "file_name": "mobject/mobject.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep", "code_tokens": " <mask> from svg_mobject import SVGMobject\n <mask> from svg_mobject import VMobjectFromSVGPathstring\n <mask> from utils.config_ops import digest_config\n <mask> from utils.strings import split_string_list_to_isolate_substring\n <mask> from mobject.types.vectorized_mobject import VGroup\n <mask> from mobject.types.vectorized_mobject import VectorizedPoint\n <mask> \n <mask> import operator as op\n <mask>  </s> remove # TODO list\n# - Make sure if \"color\" is passed into TexMobject, it behaves as expected </s> add     CONFIG = {\n        # To be filled by subclasses\n        \"tex\": None,\n        \"color\": None,\n    }", "html_url": "https://github.com/3b1b/manim/commit/0247224e0799c22951c961566e271825ffd618cc", "file_name": "mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask> from mobject.types.vectorized_mobject import VectorizedPoint\n <mask> \n <mask> import operator as op\n <mask> \n <mask> # TODO list\n <mask> # - Make sure if \"color\" is passed into TexMobject, it behaves as expected\n <mask> \n <mask> TEX_MOB_SCALE_FACTOR = 0.05\n <mask> \n <mask> \n <mask> class TexSymbol(VMobjectFromSVGPathstring):\n <mask>     def pointwise_become_partial(self, mobject, a, b): </s> add from utils.tex_file_writing import tex_to_svg_file </s> add         # TODO, this does not behave well when the mobject has points, \n        # since it gets displayed on top </s> add     CONFIG = {\n        # To be filled by subclasses\n        \"tex\": None,\n        \"color\": None,\n    } </s> add         should_add_filler = reduce(op.or_, [\n            # Fraction line needs something to be over\n            tex == \"\\\\over\",\n            tex == \"\\\\overline\",\n            # Makesure sqrt has overbar\n            tex == \"\\\\sqrt\",\n            # Need to add blank subscript or superscript\n            tex.endswith(\"_\"),\n            tex.endswith(\"^\"),\n        ])\n        if should_add_filler:\n            filler = \"{\\\\quad}\"\n            tex += filler", "html_url": "https://github.com/3b1b/manim/commit/0247224e0799c22951c961566e271825ffd618cc", "file_name": "mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         return result\n <mask> \n <mask>     def modify_special_strings(self, tex):\n <mask>         tex = self.remove_stray_braces(tex)\n <mask>         if tex in [\"\\\\over\", \"\\\\overline\"]:\n <mask>             # fraction line needs something to be over\n <mask>             tex += \"\\\\,\"\n <mask>         if tex == \"\\\\sqrt\":\n <mask>             tex += \"{\\\\quad}\"\n <mask>         if tex == \"\\\\substack\":\n <mask>             tex = \"\"\n <mask>         for t1, t2 in (\"\\\\left\", \"\\\\right\"), (\"\\\\right\", \"\\\\left\"):\n <mask>             should_replace = reduce(op.and_, [\n <mask>                 t1 in tex, </s> remove             backwards = tex[::-1].replace(\"}\", \"\", num_rights - num_lefts)\n            tex = backwards[::-1] </s> add             tex = \"{\" + tex </s> remove             tex = tex.replace(\"{\", \"\", num_lefts - num_rights) </s> add             tex = tex + \"}\" </s> remove ##########\n\n\ndef tex_hash(expression, template_tex_file):\n    return str(hash(expression + template_tex_file))\n\n\ndef tex_to_svg_file(expression, template_tex_file):\n    image_dir = os.path.join(\n        TEX_IMAGE_DIR,\n        tex_hash(expression, template_tex_file)\n    )\n    if os.path.exists(image_dir):\n        return get_sorted_image_list(image_dir)\n    tex_file = generate_tex_file(expression, template_tex_file)\n    dvi_file = tex_to_dvi(tex_file)\n    return dvi_to_svg(dvi_file)\n\n\ndef generate_tex_file(expression, template_tex_file):\n    result = os.path.join(\n        TEX_DIR,\n        tex_hash(expression, template_tex_file)\n    ) + \".tex\"\n    if not os.path.exists(result):\n        print(\"Writing \\\"%s\\\" to %s\" % (\n            \"\".join(expression), result\n        ))\n        with open(template_tex_file, \"r\") as infile:\n            body = infile.read()\n            body = body.replace(TEX_TEXT_TO_REPLACE, expression)\n        with open(result, \"w\") as outfile:\n            outfile.write(body)\n    return result\n\n\ndef get_null():\n    if os.name == \"nt\":\n        return \"NUL\"\n    return \"/dev/null\"\n\n\ndef tex_to_dvi(tex_file):\n    result = tex_file.replace(\".tex\", \".dvi\")\n    if not os.path.exists(result):\n        commands = [\n            \"latex\",\n            \"-interaction=batchmode\",\n            \"-halt-on-error\",\n            \"-output-directory=\" + TEX_DIR,\n            tex_file,\n            \">\",\n            get_null()\n        ]\n        exit_code = os.system(\" \".join(commands))\n        if exit_code != 0:\n            latex_output = ''\n            log_file = tex_file.replace(\".tex\", \".log\")\n            if os.path.exists(log_file):\n                with open(log_file, 'r') as f:\n                    latex_output = f.read()\n            raise Exception(\n                \"Latex error converting to dvi. \"\n                \"See log output above or the log file: %s\" % log_file)\n    return result\n\n\ndef dvi_to_svg(dvi_file, regen_if_exists=False):\n    \"\"\"\n    Converts a dvi, which potentially has multiple slides, into a\n    directory full of enumerated pngs corresponding with these slides.\n    Returns a list of PIL Image objects for these images sorted as they\n    where in the dvi\n    \"\"\"\n    result = dvi_file.replace(\".dvi\", \".svg\")\n    if not os.path.exists(result):\n        commands = [\n            \"dvisvgm\",\n            dvi_file,\n            \"-n\",\n            \"-v\",\n            \"0\",\n            \"-o\",\n            result,\n            \">\",\n            get_null()\n        ]\n        os.system(\" \".join(commands))\n    return result </s> add     CONFIG = {\n        # To be filled by subclasses\n        \"tex\": None,\n        \"color\": None,\n    }", "html_url": "https://github.com/3b1b/manim/commit/0247224e0799c22951c961566e271825ffd618cc", "file_name": "mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep replace replace keep replace keep keep", "code_tokens": " <mask>         if num_rights > num_lefts:\n <mask>             backwards = tex[::-1].replace(\"}\", \"\", num_rights - num_lefts)\n <mask>             tex = backwards[::-1]\n <mask>         elif num_lefts > num_rights:\n <mask>             tex = tex.replace(\"{\", \"\", num_lefts - num_rights)\n <mask>         return tex\n <mask>  </s> remove         if tex in [\"\\\\over\", \"\\\\overline\"]:\n            # fraction line needs something to be over\n            tex += \"\\\\,\"\n        if tex == \"\\\\sqrt\":\n            tex += \"{\\\\quad}\" </s> add         should_add_filler = reduce(op.or_, [\n            # Fraction line needs something to be over\n            tex == \"\\\\over\",\n            tex == \"\\\\overline\",\n            # Makesure sqrt has overbar\n            tex == \"\\\\sqrt\",\n            # Need to add blank subscript or superscript\n            tex.endswith(\"_\"),\n            tex.endswith(\"^\"),\n        ])\n        if should_add_filler:\n            filler = \"{\\\\quad}\"\n            tex += filler", "html_url": "https://github.com/3b1b/manim/commit/0247224e0799c22951c961566e271825ffd618cc", "file_name": "mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace", "code_tokens": " <mask>         digest_config(self, kwargs)\n <mask>         TexMobject.__init__(self, self.tex, **kwargs)\n <mask>         self.set_color(self.color)\n <mask> \n <mask> ##########\n <mask> \n <mask> \n <mask> def tex_hash(expression, template_tex_file):\n <mask>     return str(hash(expression + template_tex_file))\n <mask> \n <mask> \n <mask> def tex_to_svg_file(expression, template_tex_file):\n <mask>     image_dir = os.path.join(\n <mask>         TEX_IMAGE_DIR,\n <mask>         tex_hash(expression, template_tex_file)\n <mask>     )\n <mask>     if os.path.exists(image_dir):\n <mask>         return get_sorted_image_list(image_dir)\n <mask>     tex_file = generate_tex_file(expression, template_tex_file)\n <mask>     dvi_file = tex_to_dvi(tex_file)\n <mask>     return dvi_to_svg(dvi_file)\n <mask> \n <mask> \n <mask> def generate_tex_file(expression, template_tex_file):\n <mask>     result = os.path.join(\n <mask>         TEX_DIR,\n <mask>         tex_hash(expression, template_tex_file)\n <mask>     ) + \".tex\"\n <mask>     if not os.path.exists(result):\n <mask>         print(\"Writing \\\"%s\\\" to %s\" % (\n <mask>             \"\".join(expression), result\n <mask>         ))\n <mask>         with open(template_tex_file, \"r\") as infile:\n <mask>             body = infile.read()\n <mask>             body = body.replace(TEX_TEXT_TO_REPLACE, expression)\n <mask>         with open(result, \"w\") as outfile:\n <mask>             outfile.write(body)\n <mask>     return result\n <mask> \n <mask> \n <mask> def get_null():\n <mask>     if os.name == \"nt\":\n <mask>         return \"NUL\"\n <mask>     return \"/dev/null\"\n <mask> \n <mask> \n <mask> def tex_to_dvi(tex_file):\n <mask>     result = tex_file.replace(\".tex\", \".dvi\")\n <mask>     if not os.path.exists(result):\n <mask>         commands = [\n <mask>             \"latex\",\n <mask>             \"-interaction=batchmode\",\n <mask>             \"-halt-on-error\",\n <mask>             \"-output-directory=\" + TEX_DIR,\n <mask>             tex_file,\n <mask>             \">\",\n <mask>             get_null()\n <mask>         ]\n <mask>         exit_code = os.system(\" \".join(commands))\n <mask>         if exit_code != 0:\n <mask>             latex_output = ''\n <mask>             log_file = tex_file.replace(\".tex\", \".log\")\n <mask>             if os.path.exists(log_file):\n <mask>                 with open(log_file, 'r') as f:\n <mask>                     latex_output = f.read()\n <mask>             raise Exception(\n <mask>                 \"Latex error converting to dvi. \"\n <mask>                 \"See log output above or the log file: %s\" % log_file)\n <mask>     return result\n <mask> \n <mask> \n <mask> def dvi_to_svg(dvi_file, regen_if_exists=False):\n <mask>     \"\"\"\n <mask>     Converts a dvi, which potentially has multiple slides, into a\n <mask>     directory full of enumerated pngs corresponding with these slides.\n <mask>     Returns a list of PIL Image objects for these images sorted as they\n <mask>     where in the dvi\n <mask>     \"\"\"\n <mask>     result = dvi_file.replace(\".dvi\", \".svg\")\n <mask>     if not os.path.exists(result):\n <mask>         commands = [\n <mask>             \"dvisvgm\",\n <mask>             dvi_file,\n <mask>             \"-n\",\n <mask>             \"-v\",\n <mask>             \"0\",\n <mask>             \"-o\",\n <mask>             result,\n <mask>             \">\",\n <mask>             get_null()\n <mask>         ]\n <mask>         os.system(\" \".join(commands))\n <mask>     return result </s> remove         if tex in [\"\\\\over\", \"\\\\overline\"]:\n            # fraction line needs something to be over\n            tex += \"\\\\,\"\n        if tex == \"\\\\sqrt\":\n            tex += \"{\\\\quad}\" </s> add         should_add_filler = reduce(op.or_, [\n            # Fraction line needs something to be over\n            tex == \"\\\\over\",\n            tex == \"\\\\overline\",\n            # Makesure sqrt has overbar\n            tex == \"\\\\sqrt\",\n            # Need to add blank subscript or superscript\n            tex.endswith(\"_\"),\n            tex.endswith(\"^\"),\n        ])\n        if should_add_filler:\n            filler = \"{\\\\quad}\"\n            tex += filler </s> add             tex = \"{\" + tex </s> remove             tex = tex.replace(\"{\", \"\", num_lefts - num_rights) </s> add             tex = tex + \"}\"", "html_url": "https://github.com/3b1b/manim/commit/0247224e0799c22951c961566e271825ffd618cc", "file_name": "mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>             mobjects_or_continual_animations\n <mask>         )\n <mask>         to_remove = self.camera.extract_mobject_family_members(mobjects)\n <mask> \n <mask>         self.mobjects = list_difference_update(self.mobjects, to_remove)\n <mask>         self.remove_foreground_mobjects(*to_remove)\n <mask>         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n <mask>         self.foreground_mobjects = self.get_restructured_mobject_list(\n <mask>             self.foreground_mobjects, to_remove\n <mask>         )\n <mask>  </s> Removed separate_moving_and_static from scenes in place of cleaner get_moving_mobjects approach </s> remove         self.foreground_mobjects = list_difference_update( </s> add         self.foreground_mobjects = get_restructured_mobject_list( </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving_mobjects, static_mobjects = Scene.separate_moving_and_static_mobjects(\n            self, *animations\n        ) </s> add     def get_moving_mobjects(self, *animations):\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations) </s> add             return self.mobjects\n        return Scene.get_moving_mobjects(self, *animations) </s> remove             return self.get_mobjects(), [] </s> add             return self.mobjects </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving, static = Scene.separate_moving_and_static_mobjects(self, *animations) </s> add     def get_moving_mobjects(self, *animations): </s> remove             return moving_mobjects, static_mobjects", "html_url": "https://github.com/3b1b/manim/commit/024a9dd3d48659fe565709d35e8fa7fe7c8c47b7", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     def add_foreground_mobject(self, mobject):\n <mask>         return self.add_foreground_mobjects(mobject)\n <mask> \n <mask>     def remove_foreground_mobjects(self, *mobjects):\n <mask>         self.foreground_mobjects = list_difference_update(\n <mask>             self.foreground_mobjects, \n <mask>             self.camera.extract_mobject_family_members(mobjects)\n <mask>         )\n <mask>         return self\n <mask>  </s> Removed separate_moving_and_static from scenes in place of cleaner get_moving_mobjects approach </s> remove         self.mobjects = list_difference_update(self.mobjects, to_remove)\n        self.remove_foreground_mobjects(*to_remove) </s> add             return self.mobjects\n        return Scene.get_moving_mobjects(self, *animations) </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving_mobjects, static_mobjects = Scene.separate_moving_and_static_mobjects(\n            self, *animations\n        ) </s> add     def get_moving_mobjects(self, *animations):\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations) </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving, static = Scene.separate_moving_and_static_mobjects(self, *animations) </s> add     def get_moving_mobjects(self, *animations): </s> remove             return self.get_mobjects(), [] </s> add             return self.mobjects </s> remove             return moving_mobjects, static_mobjects", "html_url": "https://github.com/3b1b/manim/commit/024a9dd3d48659fe565709d35e8fa7fe7c8c47b7", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep replace replace replace replace keep keep replace keep", "code_tokens": " <mask>                 mobjects, **kwargs\n <mask>             )\n <mask>     def separate_moving_and_static_mobjects(self, *animations):\n <mask>         moving_mobjects, static_mobjects = Scene.separate_moving_and_static_mobjects(\n <mask>             self, *animations\n <mask>         )\n <mask>         if self.zoom_activated and self.little_rectangle in moving_mobjects:\n <mask>             # When the camera is moving, so is everything,\n <mask>             return self.get_mobjects(), []\n <mask>         else: </s> Removed separate_moving_and_static from scenes in place of cleaner get_moving_mobjects approach </s> remove             return moving_mobjects, static_mobjects </s> add             return moving_mobjects </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving, static = Scene.separate_moving_and_static_mobjects(self, *animations) </s> add     def get_moving_mobjects(self, *animations): </s> add             return self.mobjects\n        return Scene.get_moving_mobjects(self, *animations) </s> remove         self.foreground_mobjects = list_difference_update( </s> add         self.foreground_mobjects = get_restructured_mobject_list( </s> remove         self.mobjects = list_difference_update(self.mobjects, to_remove)\n        self.remove_foreground_mobjects(*to_remove)", "html_url": "https://github.com/3b1b/manim/commit/024a9dd3d48659fe565709d35e8fa7fe7c8c47b7", "file_name": "scene/zoomed_scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         if self.zoom_activated and self.little_rectangle in moving_mobjects:\n <mask>             # When the camera is moving, so is everything,\n <mask>             return self.get_mobjects(), []\n <mask>         else:\n <mask>             return moving_mobjects, static_mobjects\n <mask> \n <mask> \n <mask> \n <mask> \n <mask>  </s> Removed separate_moving_and_static from scenes in place of cleaner get_moving_mobjects approach </s> remove             return self.get_mobjects(), [] </s> add             return self.mobjects </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving_mobjects, static_mobjects = Scene.separate_moving_and_static_mobjects(\n            self, *animations\n        ) </s> add     def get_moving_mobjects(self, *animations):\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations) </s> add             return self.mobjects\n        return Scene.get_moving_mobjects(self, *animations) </s> add     def get_moving_mobjects(self, *animations): </s> remove         self.foreground_mobjects = list_difference_update( </s> add         self.foreground_mobjects = get_restructured_mobject_list( </s> remove         self.mobjects = list_difference_update(self.mobjects, to_remove)\n        self.remove_foreground_mobjects(*to_remove)", "html_url": "https://github.com/3b1b/manim/commit/024a9dd3d48659fe565709d35e8fa7fe7c8c47b7", "file_name": "scene/zoomed_scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         self.play(movement, *added_anims)\n <mask>         if is_camera_rotating:\n <mask>             self.add(self.ambient_camera_rotation)\n <mask> \n <mask>     def separate_moving_and_static_mobjects(self, *animations):\n <mask>         moving, static = Scene.separate_moving_and_static_mobjects(self, *animations)\n <mask>         if self.camera.rotation_mobject in moving:\n <mask>             return moving + static, []\n <mask>         return moving, static\n <mask> \n <mask> ############## </s> remove             return moving + static, []\n        return moving, static </s> add             return self.mobjects\n        return Scene.get_moving_mobjects(self, *animations) </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving_mobjects, static_mobjects = Scene.separate_moving_and_static_mobjects(\n            self, *animations\n        ) </s> add     def get_moving_mobjects(self, *animations):\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations)", "html_url": "https://github.com/3b1b/manim/commit/024a9dd3d48659fe565709d35e8fa7fe7c8c47b7", "file_name": "topics/three_dimensions.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def separate_moving_and_static_mobjects(self, *animations):\n <mask>         moving, static = Scene.separate_moving_and_static_mobjects(self, *animations)\n <mask>         if self.camera.rotation_mobject in moving:\n <mask>             return moving + static, []\n <mask>         return moving, static\n <mask> \n <mask> ##############\n <mask> \n <mask> def should_shade_in_3d(mobject):\n <mask>     return hasattr(mobject, \"shade_in_3d\") and mobject.shade_in_3d </s> Removed separate_moving_and_static from scenes in place of cleaner get_moving_mobjects approach </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving, static = Scene.separate_moving_and_static_mobjects(self, *animations) </s> add     def get_moving_mobjects(self, *animations): </s> remove     def separate_moving_and_static_mobjects(self, *animations):\n        moving_mobjects, static_mobjects = Scene.separate_moving_and_static_mobjects(\n            self, *animations\n        ) </s> add     def get_moving_mobjects(self, *animations):\n        moving_mobjects = Scene.get_moving_mobjects(self, *animations) </s> remove             return moving_mobjects, static_mobjects </s> remove             return self.get_mobjects(), [] </s> add             return self.mobjects </s> remove         self.foreground_mobjects = list_difference_update( </s> add         self.foreground_mobjects = get_restructured_mobject_list( </s> remove         self.mobjects = list_difference_update(self.mobjects, to_remove)\n        self.remove_foreground_mobjects(*to_remove)", "html_url": "https://github.com/3b1b/manim/commit/024a9dd3d48659fe565709d35e8fa7fe7c8c47b7", "file_name": "topics/three_dimensions.py"}
{"docstring_tokens": "keep add keep keep keep keep keep keep", "code_tokens": " <mask> \n <mask> def get_configuration(args):\n <mask>     file_writer_config = {\n <mask>         # By default, write to file\n <mask>         \"write_to_movie\": args.write_to_movie or not args.save_last_frame,\n <mask>         \"save_last_frame\": args.save_last_frame,\n <mask>         \"save_pngs\": args.save_pngs,\n <mask>         # If -t is passed in (for transparent), this will be RGBA </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> remove     for SceneClass in get_scene_classes(scene_names_to_classes, config): </s> add     if hasattr(module, \"OUTPUT_DIRECTORY\"):\n        file_writer_config[\"output_directory\"] = module.OUTPUT_DIRECTORY </s> remove def prompt_user_for_choice(name_to_obj):\n    num_to_name = {}\n    names = sorted(name_to_obj.keys())\n    for count, name in zip(it.count(1), names):", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep add keep keep keep keep keep keep", "code_tokens": " <mask>         \"file_name\": args.file_name,\n <mask>     }\n <mask>     config = {\n <mask>         \"module\": module,\n <mask>         \"scene_names\": args.scene_names,\n <mask>         \"open_video_upon_completion\": args.preview,\n <mask>         \"show_file_in_finder\": args.show_file_in_finder,\n <mask>         \"file_writer_config\": file_writer_config, </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> add     module = get_module(args.file) </s> remove     if scene_classes:\n        return scene_classes\n    return prompt_user_for_choice(scene_names_to_classes) </s> add     if result:\n        return result\n    return prompt_user_for_choice(scene_classes)\n\n\ndef get_scene_classes_from_module(module):\n    if hasattr(module, \"ALL_SCENE_CLASSES\"):\n        return module.ALL_SCENE_CLASSES\n    else:\n        return [\n            member[1]\n            for member in inspect.getmembers(\n                module,\n                lambda x: is_child_scene(x, module)\n            )\n        ] </s> remove     scene_names_to_classes = dict(\n        inspect.getmembers(module, lambda x: is_child_scene(x, module))\n    ) </s> add     all_scene_classes = get_scene_classes_from_module(module)\n    scene_classes_to_render = get_scenes_to_render(all_scene_classes, config) </s> remove def prompt_user_for_choice(name_to_obj):\n    num_to_name = {}\n    names = sorted(name_to_obj.keys())\n    for count, name in zip(it.count(1), names): </s> add def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in zip(it.count(1), scene_classes):\n        name = scene_class.__name__ </s> remove         if scene_name in scene_names_to_classes:\n            scene_classes.append(scene_names_to_classes[scene_name])\n        elif scene_name != \"\": </s> add         found = False\n        for scene_class in scene_classes:\n            if scene_class.__name__ == scene_name:\n                result.append(scene_class)\n                found = True\n                break\n        if not found and (scene_name != \"\"):", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         return False\n <mask>     return True\n <mask> \n <mask> \n <mask> def prompt_user_for_choice(name_to_obj):\n <mask>     num_to_name = {}\n <mask>     names = sorted(name_to_obj.keys())\n <mask>     for count, name in zip(it.count(1), names):\n <mask>         print(\"%d: %s\" % (count, name))\n <mask>         num_to_name[count] = name\n <mask>     try:\n <mask>         user_input = input(manimlib.constants.CHOOSE_NUMBER_MESSAGE)\n <mask>         return [ </s> add     if result:\n        return result\n    return prompt_user_for_choice(scene_classes)\n\n\ndef get_scene_classes_from_module(module):\n    if hasattr(module, \"ALL_SCENE_CLASSES\"):\n        return module.ALL_SCENE_CLASSES\n    else:\n        return [\n            member[1]\n            for member in inspect.getmembers(\n                module,\n                lambda x: is_child_scene(x, module)\n            )\n        ]", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         num_to_name[count] = name\n <mask>     try:\n <mask>         user_input = input(manimlib.constants.CHOOSE_NUMBER_MESSAGE)\n <mask>         return [\n <mask>             name_to_obj[num_to_name[int(num_str)]]\n <mask>             for num_str in user_input.split(\",\")\n <mask>         ]\n <mask>     except KeyError:\n <mask>         print(manimlib.constants.INVALID_NUMBER_MESSAGE)\n <mask>         sys.exit(2) </s> remove             name_to_obj[num_to_name[int(num_str)]] </s> add             num_to_class[int(num_str)]", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         print(manimlib.constants.INVALID_NUMBER_MESSAGE)\n <mask>         sys.exit(2)\n <mask>         user_input = input(manimlib.constants.CHOOSE_NUMBER_MESSAGE)\n <mask>         return [\n <mask>             name_to_obj[num_to_name[int(num_str)]]\n <mask>             for num_str in user_input.split(\",\")\n <mask>         ]\n <mask>     except EOFError:\n <mask>         sys.exit(1)\n <mask>  </s> remove             name_to_obj[num_to_name[int(num_str)]] </s> add             num_to_class[int(num_str)] </s> remove             \"skip_animations\", </s> add", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep replace replace keep keep keep replace replace keep keep keep keep", "code_tokens": " <mask>         sys.exit(1)\n <mask> \n <mask> \n <mask> def get_scene_classes(scene_names_to_classes, config):\n <mask>     if len(scene_names_to_classes) == 0:\n <mask>         print(manimlib.constants.NO_SCENE_MESSAGE)\n <mask>         return []\n <mask>     if config[\"write_all\"]:\n <mask>         return list(scene_names_to_classes.values())\n <mask>     scene_classes = []\n <mask>     for scene_name in config[\"scene_names\"]:\n <mask>         if scene_name in scene_names_to_classes:\n <mask>             scene_classes.append(scene_names_to_classes[scene_name])\n <mask>         elif scene_name != \"\": </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> remove         if scene_name in scene_names_to_classes:\n            scene_classes.append(scene_names_to_classes[scene_name])\n        elif scene_name != \"\": </s> add         found = False\n        for scene_class in scene_classes:\n            if scene_class.__name__ == scene_name:\n                result.append(scene_class)\n                found = True\n                break\n        if not found and (scene_name != \"\"): </s> remove     if scene_classes:\n        return scene_classes\n    return prompt_user_for_choice(scene_names_to_classes) </s> add     if result:\n        return result\n    return prompt_user_for_choice(scene_classes)\n\n\ndef get_scene_classes_from_module(module):\n    if hasattr(module, \"ALL_SCENE_CLASSES\"):\n        return module.ALL_SCENE_CLASSES\n    else:\n        return [\n            member[1]\n            for member in inspect.getmembers(\n                module,\n                lambda x: is_child_scene(x, module)\n            )\n        ] </s> remove     for SceneClass in get_scene_classes(scene_names_to_classes, config): </s> add     for SceneClass in scene_classes_to_render: </s> add def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in zip(it.count(1), scene_classes):\n        name = scene_class.__name__", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     if config[\"write_all\"]:\n <mask>         return list(scene_names_to_classes.values())\n <mask>     scene_classes = []\n <mask>     for scene_name in config[\"scene_names\"]:\n <mask>         if scene_name in scene_names_to_classes:\n <mask>             scene_classes.append(scene_names_to_classes[scene_name])\n <mask>         elif scene_name != \"\":\n <mask>             print(\n <mask>                 manimlib.constants.SCENE_NOT_FOUND_MESSAGE.format(\n <mask>                     scene_name\n <mask>                 ),\n <mask>                 file=sys.stderr </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> remove         return list(scene_names_to_classes.values())\n    scene_classes = [] </s> add         return scene_classes\n    result = [] </s> remove     if scene_classes:\n        return scene_classes\n    return prompt_user_for_choice(scene_names_to_classes) </s> add     if result:\n        return result\n    return prompt_user_for_choice(scene_classes)\n\n\ndef get_scene_classes_from_module(module):\n    if hasattr(module, \"ALL_SCENE_CLASSES\"):\n        return module.ALL_SCENE_CLASSES\n    else:\n        return [\n            member[1]\n            for member in inspect.getmembers(\n                module,\n                lambda x: is_child_scene(x, module)\n            )\n        ] </s> remove def get_scene_classes(scene_names_to_classes, config):\n    if len(scene_names_to_classes) == 0: </s> add def get_scenes_to_render(scene_classes, config):\n    if len(scene_classes) == 0: </s> add def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in zip(it.count(1), scene_classes):\n        name = scene_class.__name__", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>                     scene_name\n <mask>                 ),\n <mask>                 file=sys.stderr\n <mask>             )\n <mask>     if scene_classes:\n <mask>         return scene_classes\n <mask>     return prompt_user_for_choice(scene_names_to_classes)\n <mask> \n <mask> \n <mask> def main(config):\n <mask>     module = config[\"module\"]\n <mask>     scene_names_to_classes = dict( </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> remove     scene_names_to_classes = dict(\n        inspect.getmembers(module, lambda x: is_child_scene(x, module))\n    ) </s> add     all_scene_classes = get_scene_classes_from_module(module)\n    scene_classes_to_render = get_scenes_to_render(all_scene_classes, config) </s> remove         if scene_name in scene_names_to_classes:\n            scene_classes.append(scene_names_to_classes[scene_name])\n        elif scene_name != \"\": </s> add         found = False\n        for scene_class in scene_classes:\n            if scene_class.__name__ == scene_name:\n                result.append(scene_class)\n                found = True\n                break\n        if not found and (scene_name != \"\"): </s> remove         return list(scene_names_to_classes.values())\n    scene_classes = [] </s> add         return scene_classes\n    result = [] </s> remove def get_scene_classes(scene_names_to_classes, config):\n    if len(scene_names_to_classes) == 0: </s> add def get_scenes_to_render(scene_classes, config):\n    if len(scene_classes) == 0: </s> add def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in zip(it.count(1), scene_classes):\n        name = scene_class.__name__", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> def main(config):\n <mask>     module = config[\"module\"]\n <mask>     scene_names_to_classes = dict(\n <mask>         inspect.getmembers(module, lambda x: is_child_scene(x, module))\n <mask>     )\n <mask> \n <mask>     scene_kwargs = dict([\n <mask>         (key, config[key])\n <mask>         for key in [\n <mask>             \"camera_config\", </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> remove     if scene_classes:\n        return scene_classes\n    return prompt_user_for_choice(scene_names_to_classes) </s> add     if result:\n        return result\n    return prompt_user_for_choice(scene_classes)\n\n\ndef get_scene_classes_from_module(module):\n    if hasattr(module, \"ALL_SCENE_CLASSES\"):\n        return module.ALL_SCENE_CLASSES\n    else:\n        return [\n            member[1]\n            for member in inspect.getmembers(\n                module,\n                lambda x: is_child_scene(x, module)\n            )\n        ] </s> add def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in zip(it.count(1), scene_classes):\n        name = scene_class.__name__", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     scene_kwargs = dict([\n <mask>         (key, config[key])\n <mask>         for key in [\n <mask>             \"camera_config\",\n <mask>             \"skip_animations\",\n <mask>             \"file_writer_config\",\n <mask>             \"start_at_animation_number\",\n <mask>             \"end_at_animation_number\",\n <mask>             \"leave_progress_bars\",\n <mask>         ] </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> remove     scene_names_to_classes = dict(\n        inspect.getmembers(module, lambda x: is_child_scene(x, module))\n    ) </s> add     all_scene_classes = get_scene_classes_from_module(module)\n    scene_classes_to_render = get_scenes_to_render(all_scene_classes, config) </s> remove     for SceneClass in get_scene_classes(scene_names_to_classes, config): </s> add def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in zip(it.count(1), scene_classes):\n        name = scene_class.__name__", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>         for key in [\n <mask>             \"camera_config\",\n <mask>             \"file_writer_config\",\n <mask>             \"start_at_animation_number\",\n <mask>             \"end_at_animation_number\",\n <mask>             \"leave_progress_bars\",\n <mask>         ] </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> remove     scene_names_to_classes = dict(\n        inspect.getmembers(module, lambda x: is_child_scene(x, module))\n    ) </s> add     all_scene_classes = get_scene_classes_from_module(module)\n    scene_classes_to_render = get_scenes_to_render(all_scene_classes, config) </s> remove     for SceneClass in get_scene_classes(scene_names_to_classes, config): </s> add def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in zip(it.count(1), scene_classes):\n        name = scene_class.__name__", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             \"leave_progress_bars\",\n <mask>         ]\n <mask>     ])\n <mask> \n <mask>     for SceneClass in get_scene_classes(scene_names_to_classes, config):\n <mask>         try:\n <mask>             # By invoking, this renders the full scene\n <mask>             scene = SceneClass(**scene_kwargs)\n <mask>             open_file_if_needed(scene.file_writer, **config)\n <mask>             if config[\"sound\"]: </s> Allow scene extraction from a special file which contains an ALL_SCENE_CLASSES list and an OUTPUT_DIRECTORY.  This is part of a move to make the output file organization independent from the sourcecode organization </s> remove def get_scene_classes(scene_names_to_classes, config):\n    if len(scene_names_to_classes) == 0: </s> add def get_scenes_to_render(scene_classes, config):\n    if len(scene_classes) == 0: </s> add def prompt_user_for_choice(scene_classes):\n    num_to_class = {}\n    for count, scene_class in zip(it.count(1), scene_classes):\n        name = scene_class.__name__", "html_url": "https://github.com/3b1b/manim/commit/0255627922741b62553e8165aa2a655194810ddc", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     total_height = SPACE_HEIGHT\n <mask>     base = 2.3\n <mask> \n <mask>     for i, line in enumerate(lines):\n <mask>         if i < len(bool_list):\n <mask>             if bool_list[i]:\n <mask>                 mob = TexMobject(\"\\\\checkmark\")\n <mask>                 mob.highlight(GREEN)\n <mask>                 slot_group.shift(total_height*DOWN / (base**(i+1)))\n <mask>             else:\n <mask>                 mob = TexMobject(\"\\\\times\")\n <mask>                 mob.highlight(RED)\n <mask>                 slot_group.shift(total_height*UP / (base**(i+1)))\n <mask>         else:\n <mask>             mob = VectorizedPoint()\n <mask>         mob.next_to(line, UP, SMALL_BUFF)\n <mask>         slot_group.content.add(mob)\n <mask>     return slot_group\n <mask> \n </s> Up to CorrelationsWith35Percent in eop/independence </s> remove             FadeIn, VGroup(*chart.family_members_with_points()), \n </s> add             FadeIn, VGroup(*it.chain(*chart)),  </s> add         elif bool_list[i]:\n            mob = TexMobject(\"\\\\checkmark\")\n            mob.highlight(GREEN)\n            slot_group.shift(total_height*DOWN / (base**(i+1)))\n        else:\n            mob = TexMobject(\"\\\\times\")\n            mob.highlight(RED)\n            slot_group.shift(total_height*UP / (base**(i+1)))", "html_url": "https://github.com/3b1b/manim/commit/029c4f3c1f0df33504d8255d08fe3e64e958deae", "file_name": "eop/independence.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask> \n <mask>     for i, line in enumerate(lines):\n <mask>         if i >= len(bool_list) or bool_list[i] is None:\n <mask>             mob = VectorizedPoint()\n <mask>         mob.next_to(line, UP, SMALL_BUFF)\n <mask>         slot_group.content.add(mob)\n <mask>     return slot_group\n <mask>  </s> remove             FadeIn, VGroup(*chart.family_members_with_points()), </s> add             FadeIn, VGroup(*it.chain(*chart)), </s> remove         if i < len(bool_list):\n            if bool_list[i]:\n                mob = TexMobject(\"\\\\checkmark\")\n                mob.highlight(GREEN)\n                slot_group.shift(total_height*DOWN / (base**(i+1)))\n            else:\n                mob = TexMobject(\"\\\\times\")\n                mob.highlight(RED)\n                slot_group.shift(total_height*UP / (base**(i+1)))\n        else: </s> add         if i >= len(bool_list) or bool_list[i] is None:", "html_url": "https://github.com/3b1b/manim/commit/029c4f3c1f0df33504d8255d08fe3e64e958deae", "file_name": "eop/independence.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         chart.to_edge(LEFT)\n <mask>         self.bar_chart = chart\n <mask> \n <mask>         self.play(LaggedStart(\n <mask>             FadeIn, VGroup(*chart.family_members_with_points()), \n <mask>             run_time = 2\n <mask>         ))\n <mask> \n <mask>     def add_p_slider(self):\n <mask>         interval = UnitInterval(color = LIGHT_GREY)\n </s> Up to CorrelationsWith35Percent in eop/independence </s> add         elif bool_list[i]:\n            mob = TexMobject(\"\\\\checkmark\")\n            mob.highlight(GREEN)\n            slot_group.shift(total_height*DOWN / (base**(i+1)))\n        else:\n            mob = TexMobject(\"\\\\times\")\n            mob.highlight(RED)\n            slot_group.shift(total_height*UP / (base**(i+1))) </s> remove         if i < len(bool_list):\n            if bool_list[i]:\n                mob = TexMobject(\"\\\\checkmark\")\n                mob.highlight(GREEN)\n                slot_group.shift(total_height*DOWN / (base**(i+1)))\n            else:\n                mob = TexMobject(\"\\\\times\")\n                mob.highlight(RED)\n                slot_group.shift(total_height*UP / (base**(i+1)))\n        else:\n </s> add         if i >= len(bool_list) or bool_list[i] is None:", "html_url": "https://github.com/3b1b/manim/commit/029c4f3c1f0df33504d8255d08fe3e64e958deae", "file_name": "eop/independence.py"}
{"docstring_tokens": "keep add keep keep keep keep keep keep", "code_tokens": " <mask> # revert_to_original_skipping_status\n <mask> \n <mask> \n <mask> class Introduction(PiCreatureScene):\n <mask>     def construct(self):\n <mask>         self.introduce_three_objects()\n <mask>         self.show_screen()\n <mask>  </s> remove         self.pi_creature = Mortimer().to_corner(DOWN+RIGHT)\n        return self.pi_creature", "html_url": "https://github.com/3b1b/manim/commit/02de9ad9099a25b3c046dc812bce1f94d1420015", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>         self.add(words)\n <mask>         self.dither()\n <mask> \n <mask> \n <mask> class ShowCalculus(PiCreatureScene):\n <mask>     def construct(self):\n <mask>         frac_sum = TexMobject( </s> add def chi_func(n):\n    if n%2 == 0:\n        return 0\n    if n%4 == 1:\n        return 1\n    else:\n        return -1\n\n###### </s> add         self.pi_creature = self.get_primary_pi_creature() </s> add     def get_space_unit_to_x_unit(self):\n        return self.axes.get_width() / (2.0*self.x_radius)\n\n    def get_space_unit_to_y_unit(self):\n        return self.axes.get_height() / (2.0*self.y_radius)", "html_url": "https://github.com/3b1b/manim/commit/02de9ad9099a25b3c046dc812bce1f94d1420015", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep", "code_tokens": " <mask>         self.look_at(rhs_group[0])\n <mask>         self.dither()\n <mask> \n <mask> \n <mask> class Outline(PiCreatureScene):\n <mask>     def construct(self):\n <mask>         self.generate_list()\n <mask>         self.wonder_at_pi() </s> add class ShowSumMeantForFadedBackground(Scene):\n    def construct(self):\n        tex_mob = TexMobject(\n            \"1 - \\\\frac{1}{3} + \\\\frac{1}{5} - \\\\frac{1}{7} + \\\\cdots\",\n            \"=\", \"\\\\frac{\\\\pi}{4}\"\n        )\n        tex_mob.highlight_by_tex(\"pi\", YELLOW)\n        self.add(tex_mob)\n        self.dither()", "html_url": "https://github.com/3b1b/manim/commit/02de9ad9099a25b3c046dc812bce1f94d1420015", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask>         steps.to_corner(UP+LEFT)\n <mask> \n <mask> \n <mask>     def wonder_at_pi(self):\n <mask>         question = TexMobject(\"\\\\pi\", \"=???\")\n <mask>         pi = question.get_part_by_tex(\"pi\")\n <mask>         pi.scale(2, about_point = pi.get_right())\n <mask>         pi.highlight(YELLOW) </s> add         self.question = question\n        self.pi = question.get_part_by_tex(\"pi\") </s> add class ShowSumMeantForFadedBackground(Scene):\n    def construct(self):\n        tex_mob = TexMobject(\n            \"1 - \\\\frac{1}{3} + \\\\frac{1}{5} - \\\\frac{1}{7} + \\\\cdots\",\n            \"=\", \"\\\\frac{\\\\pi}{4}\"\n        )\n        tex_mob.highlight_by_tex(\"pi\", YELLOW)\n        self.add(tex_mob)\n        self.dither() </s> add     def get_space_unit_to_x_unit(self):\n        return self.axes.get_width() / (2.0*self.x_radius)\n\n    def get_space_unit_to_y_unit(self):\n        return self.axes.get_height() / (2.0*self.y_radius) </s> add         self.pi_creature = self.get_primary_pi_creature()", "html_url": "https://github.com/3b1b/manim/commit/02de9ad9099a25b3c046dc812bce1f94d1420015", "file_name": "leibniz.py"}
{"docstring_tokens": "keep add keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask> \n <mask> \n <mask>     def count_lattice_points(self):\n <mask>         step = self.steps[0]\n <mask>         plane = NumberPlane(\n <mask>             x_radius = 10, y_radius = 10, </s> remove         return self.num_pair_to_point(self.num_pair_at_center) </s> add         return self.num_pair_to_point(self.coords_at_center) </s> remove         center_x, center_y = self.num_pair_at_center\n        x = center_x + point[0]/self.space_unit_to_x_unit\n        y = center_y + point[1]/self.space_unit_to_y_unit </s> add         center_x, center_y = self.coords_at_center\n        x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add class ShowSumMeantForFadedBackground(Scene):\n    def construct(self):\n        tex_mob = TexMobject(\n            \"1 - \\\\frac{1}{3} + \\\\frac{1}{5} - \\\\frac{1}{7} + \\\\cdots\",\n            \"=\", \"\\\\frac{\\\\pi}{4}\"\n        )\n        tex_mob.highlight_by_tex(\"pi\", YELLOW)\n        self.add(tex_mob)\n        self.dither() </s> add     def get_space_unit_to_x_unit(self):\n        return self.axes.get_width() / (2.0*self.x_radius)\n\n    def get_space_unit_to_y_unit(self):\n        return self.axes.get_height() / (2.0*self.y_radius)", "html_url": "https://github.com/3b1b/manim/commit/02de9ad9099a25b3c046dc812bce1f94d1420015", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep", "code_tokens": " <mask>         self.dither()\n <mask> \n <mask> \n <mask> \n <mask> \n <mask> \n <mask> \n <mask>  </s> Preparing first lattice point counting scene </s> add class ShowSumMeantForFadedBackground(Scene):\n    def construct(self):\n        tex_mob = TexMobject(\n            \"1 - \\\\frac{1}{3} + \\\\frac{1}{5} - \\\\frac{1}{7} + \\\\cdots\",\n            \"=\", \"\\\\frac{\\\\pi}{4}\"\n        )\n        tex_mob.highlight_by_tex(\"pi\", YELLOW)\n        self.add(tex_mob)\n        self.dither()", "html_url": "https://github.com/3b1b/manim/commit/02de9ad9099a25b3c046dc812bce1f94d1420015", "file_name": "leibniz.py"}