{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask> from abc import ABC, abstractmethod\n <mask> import numbers\n <mask> \n <mask> import numpy as np\n <mask> \n <mask> from manimlib.constants import BLACK, BLUE, BLUE_D, BLUE_E, GREEN, GREY_A, WHITE, RED\n <mask> from manimlib.constants import DEGREES, PI\n <mask> from manimlib.constants import DL, UL, DOWN, DR, LEFT, ORIGIN, OUT, RIGHT, UP </s> remove from manimlib.constants import BLACK, BLUE, BLUE_D, GREEN, GREY_A, WHITE, RED </s> add from manimlib.constants import BLACK, BLUE, BLUE_D, BLUE_E, GREEN, GREY_A, WHITE, RED", "html_url": "https://github.com/3b1b/manim/commit/004b7427f513da7292617f15b9f77f9e6cb48d63", "file_name": "manimlib/mobject/coordinate_systems.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> import numbers\n <mask> \n <mask> import numpy as np\n <mask> \n <mask> from manimlib.constants import BLACK, BLUE, BLUE_D, GREEN, GREY_A, WHITE, RED\n <mask> from manimlib.constants import DEGREES, PI\n <mask> from manimlib.constants import DL, UL, DOWN, DR, LEFT, ORIGIN, OUT, RIGHT, UP\n <mask> from manimlib.constants import FRAME_HEIGHT, FRAME_WIDTH\n <mask> from manimlib.constants import FRAME_X_RADIUS, FRAME_Y_RADIUS\n <mask> from manimlib.constants import MED_SMALL_BUFF, SMALL_BUFF\n </s> Allow bound graphs to track discontinuities </s> remove from manimlib.mobject.types.vectorized_mobject import VGroup\n </s> add  </s> add import itertools as it", "html_url": "https://github.com/3b1b/manim/commit/004b7427f513da7292617f15b9f77f9e6cb48d63", "file_name": "manimlib/mobject/coordinate_systems.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> from manimlib.mobject.geometry import Line\n <mask> from manimlib.mobject.geometry import Rectangle\n <mask> from manimlib.mobject.number_line import NumberLine\n <mask> from manimlib.mobject.svg.tex_mobject import Tex\n <mask> from manimlib.mobject.types.vectorized_mobject import VGroup\n <mask> from manimlib.mobject.types.dot_cloud import DotCloud\n <mask> from manimlib.utils.config_ops import digest_config\n <mask> from manimlib.utils.config_ops import merge_dicts_recursively\n <mask> from manimlib.utils.simple_functions import binary_search\n <mask> from manimlib.utils.space_ops import angle_of_vector\n </s> Allow bound graphs to track discontinuities </s> add import itertools as it </s> remove from manimlib.constants import BLACK, BLUE, BLUE_D, GREEN, GREY_A, WHITE, RED\n </s> add from manimlib.constants import BLACK, BLUE, BLUE_D, BLUE_E, GREEN, GREY_A, WHITE, RED", "html_url": "https://github.com/3b1b/manim/commit/004b7427f513da7292617f15b9f77f9e6cb48d63", "file_name": "manimlib/mobject/coordinate_systems.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"\"\"\n <mask>         mobjects, continual_animations = self.separate_mobjects_and_continual_animations(\n <mask>             mobjects_or_continual_animations\n <mask>         )\n <mask>         self.remove(*mobjects_or_continual_animations)\n <mask>         self.mobjects += mobjects\n <mask>         self.continual_animations += continual_animations\n <mask>         return self\n <mask> \n <mask>     def add_mobjects_among(self, values): </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\") </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ): </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False)", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep add keep keep keep keep", "code_tokens": " <mask> \n <mask>         to_remove = self.camera.extract_mobject_family_members(mobjects)\n <mask> \n <mask>         self.continual_animations = filter(\n <mask>             lambda ca : ca not in continual_animations and \\\n <mask>                         ca.mobject not in to_remove, </s> Fixed bug associated with continual_animations being removed accidentally </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ): </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\")", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>             mobjects_or_continual_animations\n <mask>         )\n <mask>         to_remove = self.camera.extract_mobject_family_members(mobjects)\n <mask> \n <mask>         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n <mask>         self.foreground_mobjects = self.get_restructured_mobject_list(\n <mask>             self.foreground_mobjects, to_remove\n <mask>         )\n <mask>         self.continual_animations = filter(\n <mask>             lambda ca : ca not in continual_animations and \\\n <mask>                         ca.mobject not in to_remove,\n <mask>             self.continual_animations\n <mask>         ) </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False) </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\") </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ):", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             self.continual_animations\n <mask>         )\n <mask>         return self\n <mask> \n <mask>     def get_restructured_mobject_list(self, mobjects, to_remove):\n <mask>         \"\"\"\n <mask>         In cases where the scene contains a group, e.g. Group(m1, m2, m3), but one\n <mask>         of its submobjects is removed, e.g. scene.remove(m1), the list of mobjects\n <mask>         will be editing to contain other submobjects, but not m1, e.g. it will now\n <mask>         insert m2 and m3 to where the group once was. </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\") </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False)", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep add keep keep keep keep keep keep", "code_tokens": " <mask>         insert m2 and m3 to where the group once was.\n <mask>         \"\"\"\n <mask>         new_mobjects = []\n <mask>         def add_safe_mobjects_from_list(list_to_examine, set_to_remove):\n <mask>             for mob in list_to_examine:\n <mask>                 if mob in set_to_remove:\n <mask>                     continue\n <mask>                 intersect = set_to_remove.intersection(mob.submobject_family()) </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ): </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False) </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> remove     def remove_foreground_mobjects(self, *mobjects):\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, \n            self.camera.extract_mobject_family_members(mobjects)\n        ) </s> add     def remove_foreground_mobjects(self, *to_remove):\n        self.restructure_mobjects(to_remove, \"foreground_mobjects\")", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def add_foreground_mobject(self, mobject):\n <mask>         return self.add_foreground_mobjects(mobject)\n <mask> \n <mask>     def remove_foreground_mobjects(self, *mobjects):\n <mask>         self.foreground_mobjects = self.get_restructured_mobject_list(\n <mask>             self.foreground_mobjects, \n <mask>             self.camera.extract_mobject_family_members(mobjects)\n <mask>         )\n <mask>         return self\n <mask> \n <mask>     def remove_foreground_mobject(self, mobject):\n <mask>         return self.remove_foreground_mobjects(mobject)\n <mask>  </s> remove         self.mobjects = self.get_restructured_mobject_list(self.mobjects, to_remove)\n        self.foreground_mobjects = self.get_restructured_mobject_list(\n            self.foreground_mobjects, to_remove\n        ) </s> remove         self.remove(*mobjects_or_continual_animations) </s> add         self.restructure_mobjects(to_remove = mobjects) </s> add         if extract_families:\n            to_remove = self.camera.extract_mobject_family_members(to_remove)\n        _list = getattr(self, mobject_list_name)\n        new_list = self.get_restructured_mobject_list(_list, to_remove)\n        setattr(self, mobject_list_name, new_list)\n        return self\n\n    def get_restructured_mobject_list(self, mobjects, to_remove): </s> remove     def get_restructured_mobject_list(self, mobjects, to_remove): </s> add     def restructure_mobjects(\n        self, to_remove, \n        mobject_list_name = \"mobjects\", \n        extract_families = True\n        ): </s> add         for list_name in \"mobjects\", \"foreground_mobjects\":\n            self.restructure_mobjects(mobjects, list_name, False)", "html_url": "https://github.com/3b1b/manim/commit/00713b7971b5056b53fe9dc6b4d7857e527bcad3", "file_name": "scene/scene.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         result = self.modify_special_strings(result)\n <mask>         return result\n <mask> \n <mask>     def modify_special_strings(self, tex):\n <mask>         tex = self.remove_stray_braces(tex)\n <mask>         should_add_filler = reduce(op.or_, [\n <mask>             # Fraction line needs something to be over\n <mask>             tex == \"\\\\over\",\n <mask>             tex == \"\\\\overline\",\n <mask>             # Makesure sqrt has overbar </s> add             tex == \"\\\\sqrt{\", </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex): </s> add         tex = self.balance_braces(tex) </s> remove             num_submobs = len(sub_tex_mob.submobjects) </s> add             num_submobs = len(sub_tex_mob)\n            if num_submobs == 0:\n                continue </s> remove         num_lefts, num_rights = [\n            tex.count(char)\n            for char in \"{}\"\n        ] </s> add         num_lefts, num_rights = [tex.count(char) for char in \"{}\"] </s> remove             sub_tex_mob.set_submobjects(self.submobjects[curr_index:new_index]) </s> add             sub_tex_mob.set_submobjects(self[curr_index:new_index])", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>             tex == \"\\\\overline\",\n <mask>             # Makesure sqrt has overbar\n <mask>             tex == \"\\\\sqrt\",\n <mask>             # Need to add blank subscript or superscript\n <mask>             tex.endswith(\"_\"),\n <mask>             tex.endswith(\"^\"),\n <mask>             tex.endswith(\"dot\"), </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = tex.strip() </s> remove             num_submobs = len(sub_tex_mob.submobjects) </s> add             num_submobs = len(sub_tex_mob)\n            if num_submobs == 0:\n                continue </s> add         for ss in it.chain(self.isolate, self.tex_to_color_map.keys()): </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex): </s> add         tex = self.balance_braces(tex)", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask>         # To keep files from starting with a line break\n <mask>         if tex.startswith(\"\\\\\\\\\"):\n <mask>             tex = tex.replace(\"\\\\\\\\\", \"\\\\quad\\\\\\\\\")\n <mask> \n <mask>         # Handle imbalanced \\left and \\right\n <mask>         num_lefts, num_rights = [\n <mask>             len([\n <mask>                 s for s in tex.split(substr)[1:] </s> Rename substrings_to_isolate to simply isolate, and fix a bug associated with rendering sqrt{ </s> remove         for ss in it.chain(self.substrings_to_isolate, self.tex_to_color_map.keys()): </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex): </s> remove         num_lefts, num_rights = [\n            tex.count(char)\n            for char in \"{}\"\n        ] </s> add         num_lefts, num_rights = [tex.count(char) for char in \"{}\"] </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = tex.strip() </s> remove             num_submobs = len(sub_tex_mob.submobjects) </s> add             num_submobs = len(sub_tex_mob)\n            if num_submobs == 0:\n                continue", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep replace keep keep keep replace replace replace replace keep keep keep", "code_tokens": " <mask>         return tex\n <mask> \n <mask>     def remove_stray_braces(self, tex):\n <mask>         \"\"\"\n <mask>         Makes TexMobject resiliant to unmatched { at start\n <mask>         \"\"\"\n <mask>         num_lefts, num_rights = [\n <mask>             tex.count(char)\n <mask>             for char in \"{}\"\n <mask>         ]\n <mask>         while num_rights > num_lefts:\n <mask>             tex = \"{\" + tex\n <mask>             num_lefts += 1 </s> Rename substrings_to_isolate to simply isolate, and fix a bug associated with rendering sqrt{ </s> add         tex = self.balance_braces(tex) </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = tex.strip() </s> add             sub_tex_mob.set_submobjects(self[curr_index:new_index]) </s> remove         for ss in it.chain(self.substrings_to_isolate, self.tex_to_color_map.keys()): </s> add         for ss in it.chain(self.isolate, self.tex_to_color_map.keys()):", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep replace keep keep", "code_tokens": " <mask> \n <mask> class TexMobject(SingleStringTexMobject):\n <mask>     CONFIG = {\n <mask>         \"arg_separator\": \" \",\n <mask>         # Note, use of substrings_to_isolate is largely rendered\n <mask>         # moot by the fact that you can surround such strings in\n <mask>         # {{ and }} as needed.\n <mask>         \"substrings_to_isolate\": [],\n <mask>         \"tex_to_color_map\": {},\n <mask>     } </s> Rename substrings_to_isolate to simply isolate, and fix a bug associated with rendering sqrt{ </s> remove         # Separate out any strings specified in the substrings_to_isolate </s> add         # Separate out any strings specified in the isolate </s> remove         for ss in it.chain(self.substrings_to_isolate, self.tex_to_color_map.keys()): </s> add         for ss in it.chain(self.isolate, self.tex_to_color_map.keys()): </s> add         tex = self.balance_braces(tex) </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex): </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = tex.strip()", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep replace keep replace keep", "code_tokens": " <mask>             if len(tex_string) == 0:\n <mask>                 continue\n <mask>             sub_tex_mob = SingleStringTexMobject(tex_string, **config)\n <mask>             num_submobs = len(sub_tex_mob.submobjects)\n <mask>             new_index = curr_index + num_submobs\n <mask>             sub_tex_mob.set_submobjects(self.submobjects[curr_index:new_index])\n <mask>             new_submobjects.append(sub_tex_mob) </s> remove         tex = self.remove_stray_braces(tex) </s> add         tex = self.balance_braces(tex) </s> remove     def remove_stray_braces(self, tex): </s> add     def balance_braces(self, tex):", "html_url": "https://github.com/3b1b/manim/commit/007680a18364560adeb91ca94b177aeefa0c3c13", "file_name": "manimlib/mobject/svg/tex_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>                 radius = self.dot_radius,\n <mask>             )\n <mask>             dot.r_squared = r_squared\n <mask>             self.lattice_points.add(dot)\n <mask>         self.lattice_points.sort_submobjects(np.linalg.norm)\n <mask> \n <mask>     def get_circle(self, radius = None, color = None):\n <mask>         if radius is None:\n <mask>             radius = self.max_lattice_point_radius\n <mask>         if color is None: </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> add         for dot in dots:\n            dot.add(Line(\n                self.plane_center,\n                dot.get_center(),\n                color = dot.get_color()\n            )) </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> add         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n        morty = Mortimer().to_edge(DOWN)\n        randy.make_eye_contact(morty)\n\n        self.play(*map(FadeIn, [randy, morty]))\n        self.play(PiCreatureSays(\n            randy, \"Wait \\\\dots why?\",\n            target_mode = \"confused\",\n        ))\n        self.play(Blink(randy))\n        self.dither(2)\n        self.play(\n            RemovePiCreatureBubble(\n                randy, target_mode = \"erm\",\n            ),\n            PiCreatureSays(\n                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n                target_mode = \"hooray\",\n                bubble_kwargs = {\"width\" : 5, \"height\" : 3}\n            )\n        )\n        self.play(\n            morty.look_at, self.equation,\n            randy.look_at, self.equation,\n        )\n        self.play(Blink(morty))\n        self.play(randy.change_mode, \"pondering\")\n        self.play(RemovePiCreatureBubble(morty))\n        self.play(*map(FadeOut, [randy, morty]))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask>         r_squared = int(np.round(radius**2))\n <mask>         root_label = TexMobject(\"\\\\sqrt{%d}\"%r_squared)\n <mask>         root_label.add_background_rectangle()\n <mask>         root_label.next_to(radial_line, DOWN, SMALL_BUFF)\n <mask> \n <mask>         return radial_line, root_label\n <mask> \n <mask>     def get_lattice_points_on_r_squared_circle(self, r_squared):\n <mask>         points = VGroup(*filter( </s> remove         self.lattice_points.sort_submobjects(np.linalg.norm) </s> add         self.lattice_points.sort_submobjects(\n            lambda p : np.linalg.norm(p - self.plane_center)\n        ) </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit() </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         new_point = point-self.get_center() </s> add         new_point = point-self.axes.get_center() </s> remove         self.plane.scale(self.plane_scale_factor) </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3)", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> class IntroduceComplexConjugate(LatticePointScene):\n <mask>     CONFIG = {\n <mask>         \"y_radius\" : 20,\n <mask>         \"x_radius\" : 30,\n <mask>         \"plane_scale_factor\" : 2,\n <mask>         \"example_coords\" : (3, 4),\n <mask>         \"x_color\" : GREEN,\n <mask>         \"y_color\" : RED,\n <mask>     }\n <mask>     def construct(self): </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         self.lattice_points.sort_submobjects(np.linalg.norm) </s> add         self.lattice_points.sort_submobjects(\n            lambda p : np.linalg.norm(p - self.plane_center)\n        ) </s> remove         self.plane.scale(self.plane_scale_factor) </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         \"x_color\" : GREEN,\n <mask>         \"y_color\" : RED,\n <mask>     }\n <mask>     def construct(self):\n <mask>         self.force_skipping()\n <mask> \n <mask>         self.resize_plane()\n <mask>         self.write_points_with_complex_coords()\n <mask>         self.introduce_complex_conjugate()\n <mask>         self.show_confusion()\n <mask>         self.expand_algebraically() </s> add         \"plane_scale_factor\" : 1.7,\n        \"plane_center\" : 2*LEFT, </s> remove         self.plane.scale(self.plane_scale_factor) </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3) </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         self.lattice_points.sort_submobjects(np.linalg.norm) </s> add         self.lattice_points.sort_submobjects(\n            lambda p : np.linalg.norm(p - self.plane_center)\n        ) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         self.expand_algebraically()\n <mask>         self.show_geometrically()\n <mask> \n <mask>     def resize_plane(self):\n <mask>         self.plane.scale(self.plane_scale_factor)\n <mask> \n <mask>     def write_points_with_complex_coords(self):\n <mask>         x, y = self.example_coords\n <mask>         x_color = self.x_color\n <mask>         y_color = self.y_color </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit() </s> remove         new_point = point-self.get_center() </s> add         new_point = point-self.axes.get_center()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         for label in tuple_label, complex_label:\n <mask>             label.add_background_rectangle()\n <mask>             label.next_to(dot, UP+RIGHT, buff = 0)\n <mask> \n <mask>         y_range = range(-8, 10, 2)\n <mask>         ticks = VGroup(*[\n <mask>             Line(\n <mask>                 ORIGIN, MED_SMALL_BUFF*RIGHT\n <mask>             ).move_to(self.plane.coords_to_point(0, y))\n <mask>             for y in y_range </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         self.revert_to_original_skipping_status()\n        for part in equation:\n            self.play(FadeIn(part)) </s> add         VGroup(*equation[-2:]).shift(0.5*SMALL_BUFF*DOWN) </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> add         for dot in dots:\n            dot.add(Line(\n                self.plane_center,\n                dot.get_center(),\n                color = dot.get_color()\n            ))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def introduce_complex_conjugate(self):\n <mask>         x, y = self.example_coords\n <mask>         equation = VGroup(\n <mask>             TexMobject(str(x), \"^2\", \"+\", str(y), \"^2\", \"=\"),\n <mask>             TexMobject(\"(\", str(x), \"+\", str(y), \"i\", \")\"),\n <mask>             TexMobject(\"(\", str(x), \"-\", str(y), \"i\", \")\"),\n <mask>         )\n <mask>         equation.arrange_submobjects(\n <mask>             RIGHT, buff = SMALL_BUFF, </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> add         VGroup(*equation[-2:]).shift(0.5*SMALL_BUFF*DOWN) </s> add         self.conjugate_label = VGroup(brace, conjugate_words)\n        self.equation = equation\n        self.conjugate_dot = dot </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep add keep keep keep keep keep keep", "code_tokens": " <mask>             RIGHT, buff = SMALL_BUFF,\n <mask>         )\n <mask>         equation.scale(0.9)\n <mask>         equation.to_corner(UP+RIGHT, buff = MED_SMALL_BUFF)\n <mask>         for tex_mob in equation:\n <mask>             tex_mob.highlight_by_tex(str(x), self.x_color)\n <mask>             tex_mob.highlight_by_tex(str(y), self.y_color)\n <mask>             tex_mob.add_background_rectangle() </s> Up to introduction of factorization in leibniz </s> remove         pass </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove             TexMobject(str(x), \"^2\", \"+\", str(y), \"^2\", \"=\"), </s> add             TexMobject(\"25 = \", str(x), \"^2\", \"+\", str(y), \"^2\", \"=\"), </s> remove         pass </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         self.revert_to_original_skipping_status()\n        for part in equation:\n            self.play(FadeIn(part)) </s> add         for dot in dots:\n            dot.add(Line(\n                self.plane_center,\n                dot.get_center(),\n                color = dot.get_color()\n            ))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         conjugate_words.scale(0.8)\n <mask>         conjugate_words.add_background_rectangle()\n <mask>         conjugate_words.next_to(brace, DOWN)\n <mask> \n <mask>         self.revert_to_original_skipping_status()\n <mask>         for part in equation:\n <mask>             self.play(FadeIn(part))\n <mask>         self.dither(2)\n <mask>         self.play(\n <mask>             GrowFromCenter(brace),\n <mask>             Write(conjugate_words, run_time = 2)\n <mask>         ) </s> remove         pass </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> add         VGroup(*equation[-2:]).shift(0.5*SMALL_BUFF*DOWN) </s> remove         y_range = range(-8, 10, 2) </s> add         y_range = range(-9, 10, 3) </s> add         for dot in dots:\n            dot.add(Line(\n                self.plane_center,\n                dot.get_center(),\n                color = dot.get_color()\n            )) </s> remove         pass </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove         pass </s> add         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n        morty = Mortimer().to_edge(DOWN)\n        randy.make_eye_contact(morty)\n\n        self.play(*map(FadeIn, [randy, morty]))\n        self.play(PiCreatureSays(\n            randy, \"Wait \\\\dots why?\",\n            target_mode = \"confused\",\n        ))\n        self.play(Blink(randy))\n        self.dither(2)\n        self.play(\n            RemovePiCreatureBubble(\n                randy, target_mode = \"erm\",\n            ),\n            PiCreatureSays(\n                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n                target_mode = \"hooray\",\n                bubble_kwargs = {\"width\" : 5, \"height\" : 3}\n            )\n        )\n        self.play(\n            morty.look_at, self.equation,\n            randy.look_at, self.equation,\n        )\n        self.play(Blink(morty))\n        self.play(randy.change_mode, \"pondering\")\n        self.play(RemovePiCreatureBubble(morty))\n        self.play(*map(FadeOut, [randy, morty]))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>             ]\n <mask>         ])\n <mask>         self.dither(2)\n <mask> \n <mask>     def show_confusion(self):\n <mask>         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n <mask>         morty = Mortimer().to_edge(DOWN)\n <mask>         randy.make_eye_contact(morty)\n <mask> \n <mask>         self.play(*map(FadeIn, [randy, morty])) </s> add         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n        morty = Mortimer().to_edge(DOWN)\n        randy.make_eye_contact(morty)\n\n        self.play(*map(FadeIn, [randy, morty]))\n        self.play(PiCreatureSays(\n            randy, \"Wait \\\\dots why?\",\n            target_mode = \"confused\",\n        ))\n        self.play(Blink(randy))\n        self.dither(2)\n        self.play(\n            RemovePiCreatureBubble(\n                randy, target_mode = \"erm\",\n            ),\n            PiCreatureSays(\n                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n                target_mode = \"hooray\",\n                bubble_kwargs = {\"width\" : 5, \"height\" : 3}\n            )\n        )\n        self.play(\n            morty.look_at, self.equation,\n            randy.look_at, self.equation,\n        )\n        self.play(Blink(morty))\n        self.play(randy.change_mode, \"pondering\")\n        self.play(RemovePiCreatureBubble(morty))\n        self.play(*map(FadeOut, [randy, morty])) </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit() </s> remove         self.revert_to_original_skipping_status()\n        for part in equation:\n            self.play(FadeIn(part))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep replace keep keep replace keep keep", "code_tokens": " <mask> \n <mask>     def show_confusion(self):\n <mask>         pass\n <mask> \n <mask>     def expand_algebraically(self):\n <mask>         pass\n <mask> \n <mask>     def show_geometrically(self): </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3)", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     def expand_algebraically(self):\n <mask>         pass\n <mask> \n <mask>     def show_geometrically(self):\n <mask>         pass\n <mask> \n <mask>         \n <mask> \n <mask> \n <mask>  </s> add         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n        morty = Mortimer().to_edge(DOWN)\n        randy.make_eye_contact(morty)\n\n        self.play(*map(FadeIn, [randy, morty]))\n        self.play(PiCreatureSays(\n            randy, \"Wait \\\\dots why?\",\n            target_mode = \"confused\",\n        ))\n        self.play(Blink(randy))\n        self.dither(2)\n        self.play(\n            RemovePiCreatureBubble(\n                randy, target_mode = \"erm\",\n            ),\n            PiCreatureSays(\n                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n                target_mode = \"hooray\",\n                bubble_kwargs = {\"width\" : 5, \"height\" : 3}\n            )\n        )\n        self.play(\n            morty.look_at, self.equation,\n            randy.look_at, self.equation,\n        )\n        self.play(Blink(morty))\n        self.play(randy.change_mode, \"pondering\")\n        self.play(RemovePiCreatureBubble(morty))\n        self.play(*map(FadeOut, [randy, morty])) </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove         self.plane.scale(self.plane_scale_factor) </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3) </s> remove         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + point[1]/self.get_space_unit_to_y_unit() </s> add         x = center_x + new_point[0]/self.get_space_unit_to_x_unit()\n        y = center_y + new_point[1]/self.get_space_unit_to_y_unit()", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask>         alt_factorization.add_background_rectangle()\n <mask>         \n <mask> \n <mask>         self.add(factorization)\n <mask>         self.play(\n <mask>             DrawBorderThenFill(five_dot), \n <mask>             FadeIn(five_label)\n <mask>         ) </s> add         randy = Randolph(color = BLUE_C).to_corner(DOWN+LEFT)\n        morty = Mortimer().to_edge(DOWN)\n        randy.make_eye_contact(morty)\n\n        self.play(*map(FadeIn, [randy, morty]))\n        self.play(PiCreatureSays(\n            randy, \"Wait \\\\dots why?\",\n            target_mode = \"confused\",\n        ))\n        self.play(Blink(randy))\n        self.dither(2)\n        self.play(\n            RemovePiCreatureBubble(\n                randy, target_mode = \"erm\",\n            ),\n            PiCreatureSays(\n                morty, \"Now it's a \\\\\\\\ factoring problem!\",\n                target_mode = \"hooray\",\n                bubble_kwargs = {\"width\" : 5, \"height\" : 3}\n            )\n        )\n        self.play(\n            morty.look_at, self.equation,\n            randy.look_at, self.equation,\n        )\n        self.play(Blink(morty))\n        self.play(randy.change_mode, \"pondering\")\n        self.play(RemovePiCreatureBubble(morty))\n        self.play(*map(FadeOut, [randy, morty])) </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove         self.revert_to_original_skipping_status()\n        for part in equation:\n            self.play(FadeIn(part)) </s> add         self.play(FadeIn(\n            equation,\n            run_time = 3,\n            submobject_mode = \"lagged_start\"\n        ))", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "leibniz.py"}
{"docstring_tokens": "keep keep replace keep keep keep keep keep keep keep keep replace replace keep keep", "code_tokens": " <mask> \n <mask>     def point_to_coords(self, point):\n <mask>         new_point = point-self.get_center()\n <mask>         center_x, center_y = self.coords_at_center\n <mask>         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n <mask>         y = center_y + point[1]/self.get_space_unit_to_y_unit()\n <mask>         return x, y\n <mask> \n <mask>     def point_to_coords(self, point):\n <mask>         new_point = point-self.get_center()\n <mask>         center_x, center_y = self.coords_at_center\n <mask>         x = center_x + point[0]/self.get_space_unit_to_x_unit()\n <mask>         y = center_y + point[1]/self.get_space_unit_to_y_unit()\n <mask>         return x, y\n <mask>  </s> add         x, y = self.example_coords\n        expansion = VGroup(\n            TexMobject(str(x), \"^2\"),\n            TexMobject(\"-\", \"(\", str(y), \"i\", \")^2\")\n        )\n        expansion.arrange_submobjects(RIGHT, buff = SMALL_BUFF)\n        expansion.next_to(\n            VGroup(*self.equation[-2:]), \n            DOWN, LARGE_BUFF\n        )\n        alt_y_term = TexMobject(\"+\", str(y), \"^2\")\n        alt_y_term.move_to(expansion[1], LEFT)\n        for tex_mob in list(expansion) + [alt_y_term]:\n            tex_mob.highlight_by_tex(str(x), self.x_color)\n            tex_mob.highlight_by_tex(str(y), self.y_color)\n            tex_mob.rect = BackgroundRectangle(tex_mob)\n\n        x1 = self.equation[-2][1][1]\n        x2 = self.equation[-1][1][1]\n        y1 = VGroup(*self.equation[-2][1][3:5])\n        y2 = VGroup(*self.equation[-1][1][2:5])\n        vect = MED_LARGE_BUFF*UP\n\n        self.play(FadeOut(self.conjugate_label))\n        group = VGroup(x1, x2)\n        self.play(group.shift, -vect)\n        self.play(\n            FadeIn(expansion[0].rect),\n            ReplacementTransform(group.copy(), expansion[0]),\n        )\n        self.play(group.shift, vect)\n        group = VGroup(x1, y2)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(x2, y1)\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(group.shift, vect)\n        group = VGroup(*it.chain(y1, y2))\n        self.play(group.shift, -vect)\n        self.dither()\n        self.play(\n            FadeIn(expansion[1].rect),\n            ReplacementTransform(group.copy(), expansion[1]),\n        )\n        self.play(group.shift, vect)\n        self.dither(2)\n        self.play(\n            Transform(expansion[1].rect, alt_y_term.rect),\n            Transform(expansion[1], alt_y_term),\n        )\n        self.dither()\n        self.play(*map(FadeOut, [\n            expansion[0].rect,\n            expansion[1].rect,\n            expansion\n        ])) </s> remove         root_label.next_to(radial_line, DOWN, SMALL_BUFF) </s> add         root_label.next_to(radial_line, UP, SMALL_BUFF) </s> remove         self.plane.scale(self.plane_scale_factor) </s> add         self.plane.scale(\n            self.plane_scale_factor,\n            about_point = self.plane_center\n        )\n        self.plane.set_stroke(width = 3) </s> add         dots = [self.example_dot, self.conjugate_dot]\n        top_dot, low_dot = dots\n        for dot in dots:\n            dot.line = Line(\n                self.plane_center, dot.get_center(), \n                color = BLUE\n            )\n            dot.angle = dot.line.get_angle()\n            dot.arc = Arc(\n                dot.angle,\n                radius = 0.75, \n                color = YELLOW\n            )\n            dot.arc.shift(self.plane_center)\n            dot.arc.add_tip(tip_length = 0.2)\n            dot.rotate_word = TextMobject(\"Rotate\")\n            dot.rotate_word.scale(0.5)\n            dot.rotate_word.next_to(dot.arc, RIGHT, SMALL_BUFF)\n            dot.magnitude_word = TextMobject(\"Length 5\")\n            dot.magnitude_word.scale(0.6)\n            dot.magnitude_word.next_to(\n                ORIGIN,\n                np.sign(dot.get_center()[1])*UP,\n                buff = SMALL_BUFF\n            )\n            dot.magnitude_word.add_background_rectangle()\n            dot.magnitude_word.rotate(dot.angle)\n            dot.magnitude_word.shift(dot.line.get_center())\n        twenty_five_label = TexMobject(\"25\")\n        twenty_five_label.add_background_rectangle()\n        twenty_five_label.next_to(\n            self.plane.coords_to_point(25, 0),\n            DOWN\n        )\n\n        self.play(ShowCreation(top_dot.line))\n        mover = VGroup(\n            top_dot.line.copy().highlight(PINK), \n            top_dot.copy()\n        )\n        self.play(FadeIn(\n            top_dot.magnitude_word,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither()\n        self.play(ShowCreation(top_dot.arc))\n        self.dither(2)\n        self.play(ShowCreation(low_dot.line))\n        self.play(\n            ReplacementTransform(\n                top_dot.arc,\n                low_dot.arc\n            ),\n            FadeIn(low_dot.rotate_word)\n        )\n        self.play(\n            Rotate(\n                mover, low_dot.angle, \n                about_point = self.plane_center\n            ),\n            run_time = 2\n        )\n        self.play(\n            FadeOut(low_dot.arc),\n            FadeOut(low_dot.rotate_word),\n            FadeIn(low_dot.magnitude_word),\n        )\n        self.play(\n            mover[0].scale_about_point, 5, self.plane_center,\n            mover[1].move_to, self.plane.coords_to_point(25, 0),\n            run_time = 2\n        )\n        self.dither()\n        self.play(Write(twenty_five_label))\n        self.dither(3)\n\nclass NameGaussianIntegers(LatticePointScene):\n    CONFIG = {\n        \"max_lattice_point_radius\" : 15,\n        \"dot_radius\" : 0.05,\n        \"plane_center\" : 2*LEFT,\n        \"x_radius\" : 15,\n    }\n    def construct(self):\n        self.add_axis_labels()\n        self.add_a_plus_bi()\n        self.draw_lattice_points()\n        self.add_name()\n        self.restrict_to_one_circle()\n        self.show_question_algebraically()\n\n    def add_a_plus_bi(self):\n        label = TexMobject(\n            \"a\", \"+\", \"b\", \"i\"\n        )\n        a = label.get_part_by_tex(\"a\")\n        b = label.get_part_by_tex(\"b\")\n        a.highlight(GREEN)\n        b.highlight(RED)\n        label.add_background_rectangle()\n        label.to_corner(UP+RIGHT)\n        integers = TextMobject(\"Integers\")\n        integers.next_to(label, DOWN, LARGE_BUFF)\n        integers.add_background_rectangle()\n        arrows = VGroup(*[\n            Arrow(integers.get_top(), mob, tip_length = 0.15)\n            for mob in a, b\n        ])\n        self.add_foreground_mobjects(label, integers, arrows)\n\n        self.a_plus_bi = label\n        self.integers_label = VGroup(integers, arrows)\n\n    def add_name(self):\n        gauss_name = TextMobject(\n            \"Carl Friedrich Gauss\"\n        )\n        gauss_name.add_background_rectangle()\n        gauss_name.next_to(ORIGIN, UP, MED_LARGE_BUFF)\n        gauss_name.to_edge(LEFT)\n\n        gaussian_integers = TextMobject(\"``Gaussian integers'': \")\n        gaussian_integers.scale(0.9)\n        gaussian_integers.next_to(self.a_plus_bi, LEFT)\n        gaussian_integers.add_background_rectangle()\n\n        self.play(FadeIn(gaussian_integers))\n        self.add_foreground_mobject(gaussian_integers)\n        self.play(FadeIn(\n            gauss_name,\n            run_time = 2,\n            submobject_mode = \"lagged_start\"\n        ))\n        self.dither(3)\n        self.play(FadeOut(gauss_name))\n\n        self.gaussian_integers = gaussian_integers\n\n    def restrict_to_one_circle(self):\n        dots = self.get_lattice_points_on_r_squared_circle(25).copy()\n        for dot in dots:\n            dot.scale_in_place(2)\n        circle = self.get_circle(5)\n        radius, root_label = self.get_radial_line_with_label(5)\n\n        self.play(\n            FadeOut(self.lattice_points),\n            ShowCreation(circle),\n            Rotating(\n                radius, \n                run_time = 1, rate_func = smooth,\n                about_point = self.plane_center\n            ),\n            *map(GrowFromCenter, dots)\n        )\n        self.play(Write(root_label))\n        self.dither()\n\n        self.circle_dots = dots\n\n    def show_question_algebraically(self):\n        for i, dot in enumerate(self.circle_dots):\n            x, y = self.dot_to_int_coords(dot)\n            x_str = str(x)\n            y_str = str(y) if y >= 0 else \"(%d)\"%y\n            label = TexMobject(x_str, \"+\", y_str, \"i\")\n            label.scale(0.8)\n            label.next_to(\n                dot, \n                dot.get_center()-self.plane_center + SMALL_BUFF*(UP+RIGHT),\n                buff = 0,\n            )\n            label.add_background_rectangle()\n            dot.label = label\n\n            equation = TexMobject(\n                \"25 = \"\n                \"(\", x_str, \"+\", y_str, \"i\", \")\",\n                \"(\", x_str, \"-\", y_str, \"i\", \")\",\n            )\n            equation.scale(0.9)\n            equation.add_background_rectangle()\n            equation.to_corner(UP + RIGHT)\n            dot.equation = equation\n\n            for mob in label, equation:\n                mob.highlight_by_tex(x_str, GREEN, substring = False)\n                mob.highlight_by_tex(y_str, RED, substring = False)\n\n            dot.line_pair = VGroup(*[\n                Line(\n                    self.plane_center,\n                    self.plane.coords_to_point(x, u*y),\n                    color = PINK,\n                )\n                for u in 1, -1\n            ])\n            dot.conjugate_dot = self.circle_dots[-i]\n\n        self.play(*map(FadeOut, [\n            self.a_plus_bi, self.integers_label,\n            self.gaussian_integers,\n        ]))\n\n        last_dot = None\n        for dot in self.circle_dots:\n            anims = [\n                dot.highlight, PINK,\n                dot.conjugate_dot.highlight, PINK,\n            ]\n            if last_dot is None:\n                anims += [\n                    FadeIn(dot.equation),\n                    FadeIn(dot.label),\n                ]\n                anims += map(ShowCreation, dot.line_pair)\n            else:\n                anims += [\n                    last_dot.highlight, self.dot_color,\n                    last_dot.conjugate_dot.highlight, self.dot_color,\n                    ReplacementTransform(last_dot.equation, dot.equation),\n                    ReplacementTransform(last_dot.label, dot.label),\n                    ReplacementTransform(last_dot.line_pair, dot.line_pair),\n                ]\n            self.play(*anims)\n            self.dither()\n            last_dot = dot\n\nclass FactorOrdinaryNumber(TeacherStudentsScene):\n    def construct(self):\n        equation = TexMobject(\n            \"2{,}250\", \"=\", \"2 \\\\cdot 3^2 \\\\cdot 5^3\"\n        )\n        equation.next_to(self.get_pi_creatures(), UP, LARGE_BUFF)\n        number = equation[0]\n        alt_rhs_list = list(it.starmap(TexMobject, [\n            (\"\\\\ne\", \"2^2 \\\\cdot 563\"),\n            (\"\\\\ne\", \"2^2 \\\\cdot 3 \\\\cdot 11 \\\\cdot 17\"),\n            (\"\\\\ne\", \"2 \\\\cdot 7^2 \\\\cdot 23\"),\n            (\"=\", \"(-2) \\\\cdot (-3) \\\\cdot (3) \\\\cdot 5^3\"),\n        ]))\n        for alt_rhs in alt_rhs_list:\n            if \"\\\\ne\" in alt_rhs.get_tex_string():\n                alt_rhs.highlight(RED)\n            else:\n                alt_rhs.highlight(GREEN)\n            alt_rhs.move_to(equation.get_right())\n        number.save_state()\n        number.next_to(self.teacher, UP+LEFT)\n\n        self.play(\n            self.teacher.change_mode, \"raise_right_hand\",\n            Write(number)\n        )\n        self.dither(2)\n        self.play(\n            number.restore,\n            Write(VGroup(*equation[1:]))\n        )\n        self.change_student_modes(\n            *[\"pondering\"]*3,\n            look_at_arg = equation,\n            added_anims = [self.teacher.change_mode, \"happy\"]\n        )\n        self.dither()\n        last_alt_rhs = None\n        for alt_rhs in alt_rhs_list:\n            equation.generate_target()\n            equation.target.next_to(alt_rhs, LEFT)\n            anims = [MoveToTarget(equation)]\n            if last_alt_rhs:\n                anims += [ReplacementTransform(last_alt_rhs, alt_rhs)]\n            else:\n                anims += [FadeIn(alt_rhs)]\n            self.play(*anims)\n            if alt_rhs is alt_rhs_list[-1]:\n                self.change_student_modes(\n                    *[\"sassy\"]*3,\n                    look_at_arg = alt_rhs\n                )\n            self.dither(2)\n            last_alt_rhs = alt_rhs </s> remove             TexMobject(str(x), \"^2\", \"+\", str(y), \"^2\", \"=\"), </s> add             TexMobject(\"25 = \", str(x), \"^2\", \"+\", str(y), \"^2\", \"=\"),", "html_url": "https://github.com/3b1b/manim/commit/0092ac9a2a20873c7c077cefc4d68397a6df2ada", "file_name": "topics/number_line.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     }\n <mask> \n <mask>     def __init__(self, width=None, height=None, **kwargs):\n <mask>         Polygon.__init__(self, UR, UL, DL, DR, **kwargs)\n <mask>         self.width = width or self.width\n <mask>         self.height = height or self.height\n <mask>         self.set_width(self.width, stretch=True)\n <mask>         self.set_height(self.height, stretch=True)\n <mask> \n <mask> \n <mask> class Square(Rectangle):\n <mask>     CONFIG = {\n <mask>         \"side_length\": 2.0, </s> remove         Rectangle.__init__(\n            self,\n            height=self.side_length,\n            width=self.side_length,\n            **kwargs\n        ) </s> add         if side_length is None:\n            side_length = self.side_length\n\n        super().__init__(side_length, side_length, **kwargs) </s> add     def __init__(self, side_length=None, **kwargs):", "html_url": "https://github.com/3b1b/manim/commit/00ad9d7f9591e0dfa0407a6e41b83ba6c1af31df", "file_name": "manimlib/mobject/geometry.py"}
{"docstring_tokens": "keep keep replace keep replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask>     }\n <mask> \n <mask>     def __init__(self, **kwargs):\n <mask>         digest_config(self, kwargs)\n <mask>         Rectangle.__init__(\n <mask>             self,\n <mask>             height=self.side_length,\n <mask>             width=self.side_length,\n <mask>             **kwargs\n <mask>         )\n <mask> \n <mask> \n <mask> class RoundedRectangle(Rectangle):\n </s> Cleanup to square and rectangle init </s> remove         self.width = width or self.width\n        self.height = height or self.height\n        self.set_width(self.width, stretch=True)\n        self.set_height(self.height, stretch=True)\n </s> add         if width is None:\n            width = self.width\n        if height is None:\n            height = self.height\n\n        self.set_width(width, stretch=True)\n        self.set_height(height, stretch=True)", "html_url": "https://github.com/3b1b/manim/commit/00ad9d7f9591e0dfa0407a6e41b83ba6c1af31df", "file_name": "manimlib/mobject/geometry.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask>         # \"use_real_images\": False,\n <mask>         \"include_labels\": False,\n <mask>         \"camera_config\": {\"background_color\": DARKER_GREY},\n <mask>         \"random_seed\": 6,\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         self.add_title() </s> remove # TODO\nclass ContrastToOtherOlympiadProblems(Scene):", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         all_students.shuffle()\n <mask> \n <mask>         student_groups.generate_target()\n <mask>         student_groups.target.arrange_in_grid(\n <mask>             n_rows=10,\n <mask>             buff=SMALL_BUFF,\n <mask>         )\n <mask>         student_groups.target[-9:].align_to(student_groups.target[0], LEFT)\n <mask>         student_groups.target.match_height(flags)\n <mask>         student_groups.target.match_y(flags) </s> Animations for windmill up to early draft publish </s> remove                 pass\n        # images.remove(*images[self.num_countries:])\n        n_rows = 10 </s> add                 print(\"Failed on {}\".format(country))\n\n        n_rows = self.n_flag_rows </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3) </s> remove         self.let_windmill_run(windmill, 8) </s> add         self.let_windmill_run(windmill, 16) </s> remove             student_groups[1:].set_opacity, 0.1, </s> add             student_groups[1:].fade, 0.9, </s> remove         \"diffyq\", \"part5\", \"1440p60\" </s> add         \"windmill\", \"1440p60\"", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep add keep keep keep keep keep", "code_tokens": " <mask>         dots.match_height(flag)\n <mask>         dots.next_to(flag, RIGHT, SMALL_BUFF)\n <mask>         if isinstance(flag, ImageMobject):\n <mask>             rgba = random.choice(random.choice(flag.pixel_array))\n <mask>             if np.all(rgba < 100):\n <mask>                 rgba = interpolate(rgba, 256 * np.ones(len(rgba)), 0.5)\n <mask>             color = rgba_to_color(rgba / 256) </s> add                 label = VGroup(*[\n                    TextMobject(l)\n                    for l in country_to_code3[country].upper()\n                ])", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep replace replace keep replace keep keep", "code_tokens": " <mask>     def get_flags(self):\n <mask>         with open(os.path.join(\"assets\", \"imo_countries.json\")) as fp:\n <mask>             countries = json.load(fp)\n <mask>         with open(os.path.join(\"assets\", \"country_codes.json\")) as fp:\n <mask>             code_map = json.load(fp)\n <mask> \n <mask>         images = Group() </s> remove         for country in countries:\n            country = country.upper()\n            if country not in code_map: </s> add         for country, count in countries_with_counts:\n            country = country.lower()\n\n            alt_names = [\n                (\"united states of america\", \"united states\"),\n                (\"people's republic of china\", \"china\"),\n                (\"macau\", \"macao\"),\n                (\"syria\", \"syrian arab republic\"),\n                (\"north macedonia\", \"macedonia, the former yugoslav republic of\"),\n                (\"tanzania\", \"united republic of tanzania\"),\n                (\"vietnam\", \"viet nam\"),\n                (\"ivory coast\", \"cote d'ivoire\")\n            ]\n            for n1, n2 in alt_names:\n                if country == n1:\n                    country = n2\n\n            if country not in country_to_code2:\n                print(\"Can't find {}\".format(country)) </s> remove         points = self.get_random_point_set(30)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep replace", "code_tokens": " <mask>         with open(os.path.join(\"assets\", \"country_codes.json\")) as fp:\n <mask>             code_map = json.load(fp)\n <mask> \n <mask>         images = Group()\n <mask>         for country in countries:\n <mask>             country = country.upper()\n <mask>             if country not in code_map:\n <mask>                 continue\n <mask>             short_code = code_map[country].lower() </s> Animations for windmill up to early draft publish </s> remove             code_map = json.load(fp) </s> add             country_codes = json.load(fp)\n            country_to_code2 = dict([\n                (country.lower(), code2.lower())\n                for country, code2, code3 in country_codes\n            ])\n            country_to_code3 = dict([\n                (country.lower(), code3.lower())\n                for country, code2, code3 in country_codes\n            ]) </s> remove         with open(os.path.join(\"assets\", \"imo_countries.json\")) as fp:\n            countries = json.load(fp) </s> add         year = self.year\n        file = \"{}_imo_countries.json\".format(year)\n        with open(os.path.join(\"assets\", file)) as fp:\n            countries_with_counts = json.load(fp) </s> remove                 label = VGroup(*[TextMobject(l) for l in country]) </s> add                 label = VGroup(*[\n                    TextMobject(l)\n                    for l in country_to_code3[country].upper()\n                ])", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             short_code = code_map[country].lower()\n <mask>             try:\n <mask>                 image = ImageMobject(os.path.join(\"flags\", short_code))\n <mask>                 image.set_width(1)\n <mask>                 label = VGroup(*[TextMobject(l) for l in country])\n <mask>                 label.arrange(RIGHT, buff=0.05, aligned_edge=DOWN)\n <mask>                 label.set_height(0.25)\n <mask>                 if not self.use_real_images:\n <mask>                     rect = SurroundingRectangle(image, buff=0)\n <mask>                     rect.set_stroke(WHITE, 1) </s> remove             short_code = code_map[country].lower() </s> add             short_code = country_to_code2[country] </s> remove         for country in countries:\n            country = country.upper()\n            if country not in code_map: </s> add         for country, count in countries_with_counts:\n            country = country.lower()\n\n            alt_names = [\n                (\"united states of america\", \"united states\"),\n                (\"people's republic of china\", \"china\"),\n                (\"macau\", \"macao\"),\n                (\"syria\", \"syrian arab republic\"),\n                (\"north macedonia\", \"macedonia, the former yugoslav republic of\"),\n                (\"tanzania\", \"united republic of tanzania\"),\n                (\"vietnam\", \"viet nam\"),\n                (\"ivory coast\", \"cote d'ivoire\")\n            ]\n            for n1, n2 in alt_names:\n                if country == n1:\n                    country = n2\n\n            if country not in country_to_code2:\n                print(\"Can't find {}\".format(country)) </s> add                 print(\"Failed on {}\".format(country))\n\n        n_rows = self.n_flag_rows </s> add             country_codes = json.load(fp)\n            country_to_code2 = dict([\n                (country.lower(), code2.lower())\n                for country, code2, code3 in country_codes\n            ])\n            country_to_code3 = dict([\n                (country.lower(), code3.lower())\n                for country, code2, code3 in country_codes\n            ]) </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>                     rect.set_stroke(WHITE, 1)\n <mask>                     image = rect\n <mask>                 image.label = label\n <mask>                 images.add(image)\n <mask>             except OSError:\n <mask>                 print(\"Failed on {}\".format(country))\n <mask>  </s> remove                 pass\n        # images.remove(*images[self.num_countries:])\n        n_rows = 10 </s> add                 print(\"Failed on {}\".format(country))\n\n        n_rows = self.n_flag_rows </s> remove             short_code = code_map[country].lower() </s> add             short_code = country_to_code2[country] </s> remove         for country in countries:\n            country = country.upper()\n            if country not in code_map: </s> add         for country, count in countries_with_counts:\n            country = country.lower()\n\n            alt_names = [\n                (\"united states of america\", \"united states\"),\n                (\"people's republic of china\", \"china\"),\n                (\"macau\", \"macao\"),\n                (\"syria\", \"syrian arab republic\"),\n                (\"north macedonia\", \"macedonia, the former yugoslav republic of\"),\n                (\"tanzania\", \"united republic of tanzania\"),\n                (\"vietnam\", \"viet nam\"),\n                (\"ivory coast\", \"cote d'ivoire\")\n            ]\n            for n1, n2 in alt_names:\n                if country == n1:\n                    country = n2\n\n            if country not in country_to_code2:\n                print(\"Can't find {}\".format(country)) </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>                     image = rect\n <mask>                 image.label = label\n <mask>                 images.add(image)\n <mask>             except OSError:\n <mask>                 pass\n <mask>         # images.remove(*images[self.num_countries:])\n <mask>         n_rows = 10\n <mask>         images.arrange_in_grid(\n <mask>             n_rows=n_rows,\n <mask>             buff=1.25,\n <mask>         )\n <mask>         images[-(len(images) % n_rows):].align_to(images[0], LEFT) </s> add                 image.n_students = count </s> add             short_code = country_to_code2[country] </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>         return images\n <mask> \n <mask> \n <mask> class ShowTest(Scene):\n <mask>     def construct(self):\n <mask>         self.introduce_test()\n <mask> \n <mask>     def introduce_test(self):\n <mask>         test = self.get_test() </s> remove         with open(os.path.join(\"assets\", \"imo_countries.json\")) as fp:\n            countries = json.load(fp) </s> add         year = self.year\n        file = \"{}_imo_countries.json\".format(year)\n        with open(os.path.join(\"assets\", file)) as fp:\n            countries_with_counts = json.load(fp) </s> remove # TODO\nclass ContrastToOtherOlympiadProblems(Scene): </s> add             country_codes = json.load(fp)\n            country_to_code2 = dict([\n                (country.lower(), code2.lower())\n                for country, code2, code3 in country_codes\n            ])\n            country_to_code3 = dict([\n                (country.lower(), code3.lower())\n                for country, code2, code3 in country_codes\n            ])", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def show_tests(self):\n <mask>         tests = VGroup(\n <mask>             self.get_test(\n <mask>                 [\"American \", \"Mathematics \", \"Content\"],\n <mask>                 n_questions=25,\n <mask>                 time_string=\"75 minutes\",\n <mask>                 hours=1.25,\n <mask>                 n_students=250000,\n <mask>             ), </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask>         self.let_windmill_run(windmill, self.final_run_time)\n <mask> \n <mask> \n <mask> # TODO\n <mask> class ContrastToOtherOlympiadProblems(Scene):\n <mask>     def construct(self):\n <mask>         pass\n <mask> \n <mask> \n <mask> class WindmillExample30Points(WindmillScene): </s> add class FootnoteToIMOIntro(Scene):\n    def construct(self):\n        words = TextMobject(\"$^*$Based on data from 2019 test\")\n        self.play(FadeInFrom(words, UP))\n        self.wait() </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo) </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3) </s> remove         \"windmill_rotation_speed\": TAU / 8,", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> # TODO\n <mask> class ContrastToOtherOlympiadProblems(Scene):\n <mask>     def construct(self):\n <mask>         pass\n <mask> \n <mask> \n <mask> class WindmillExample30Points(WindmillScene):\n <mask>     CONFIG = {\n <mask>         \"random_seed\": 0, </s> remove # TODO\nclass ContrastToOtherOlympiadProblems(Scene): </s> remove         \"windmill_rotation_speed\": TAU / 8, </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep", "code_tokens": " <mask> \n <mask> class WindmillExample30Points(WindmillScene):\n <mask>     CONFIG = {\n <mask>         \"random_seed\": 0,\n <mask>         \"run_time\": 60,\n <mask>         \"counter_config\": {\n <mask>             \"counter_height\": 0.15,\n <mask>             \"buff\": 0.1, </s> remove         \"windmill_rotation_speed\": TAU / 8, </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>         \"n_points\": 30,\n <mask>         \"random_seed\": 0,\n <mask>         \"run_time\": 60,\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         points = self.get_random_point_set(self.n_points) </s> remove         points = self.get_random_point_set(30) </s> add         points = self.get_random_point_set(self.n_points)\n        points[:, 0] *= 1.5 </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"run_time\": 60,\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         points = self.get_random_point_set(30)\n <mask>         sorted_points = sorted(list(points), key=lambda p: p[1])\n <mask>         sorted_points[4] += RIGHT\n <mask> \n <mask>         dots = self.get_dots(points)\n <mask>         windmill = self.get_windmill(points, sorted_points[5], angle=PI / 4) </s> remove         \"windmill_rotation_speed\": TAU / 8, </s> add         \"windmill_rotation_speed\": TAU / 16, </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo) </s> remove         self.let_windmill_run(windmill, 8) </s> add         self.let_windmill_run(windmill, 16) </s> add         year = self.year\n        file = \"{}_imo_countries.json\".format(year)\n        with open(os.path.join(\"assets\", file)) as fp:\n            countries_with_counts = json.load(fp) </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep replace replace replace keep keep replace keep", "code_tokens": " <mask>         self.add(dots)\n <mask>         self.add(pivot_dot)\n <mask>         self.add(self.get_pivot_counters(\n <mask>             windmill,\n <mask>             counter_height=0.15,\n <mask>             buff=0.1,\n <mask>         ))\n <mask> \n <mask>         self.let_windmill_run(windmill, run_time)\n <mask>  </s> remove         self.let_windmill_run(windmill, 8) </s> add         self.let_windmill_run(windmill, 16) </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         )\n <mask>         self.wait()\n <mask> \n <mask>         windmill.rot_speed = TAU / 8\n <mask>         self.let_windmill_run(windmill, 8)\n <mask>         highlight = windmill.copy()\n <mask>         highlight.set_stroke(YELLOW, 4)\n <mask>         self.play(\n <mask>             ShowCreationThenDestruction(highlight),\n <mask>         ) </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3) </s> remove         \"windmill_rotation_speed\": TAU / 8,", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> class FearedCase(WindmillScene):\n <mask>     CONFIG = {\n <mask>         \"n_points\": 25,\n <mask>         \"windmill_rotation_speed\": TAU / 8,\n <mask>     }\n <mask> \n <mask>     def construct(self):\n <mask>         points = self.get_random_point_set(self.n_points)\n <mask>         sorted_points = sorted(list(points), key=lambda p: p[1]) </s> add         points = self.get_random_point_set(self.n_points)\n        points[:, 0] *= 1.5 </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask> \n <mask>         self.add_dot_color_updater(new_dots, windmill)\n <mask> \n <mask>         for rect in rects:\n <mask>             self.play(rect.set_opacity, 1)\n <mask>             self.play(rect.set_opacity, rects.const_opacity)\n <mask>         rects.resume_updating()\n <mask>         self.wait()\n <mask>         self.play( </s> Animations for windmill up to early draft publish </s> add         rects.resume_updating() </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects </s> remove         self.let_windmill_run(windmill, run_time) </s> add         self.let_windmill_run(windmill, self.run_time)\n\n\nclass WindmillExample15Points(WindmillExample30Points):\n    CONFIG = {\n        \"n_points\": 15,\n        \"run_time\": 60,\n        \"random_seed\": 2,\n        \"counter_config\": {\n            \"counter_height\": 0.25,\n            \"buff\": 0.1,\n        },\n    }\n\n\nclass TheQuestion(Scene):\n    def construct(self):\n        words = TextMobject(\n            \"Will each point be hit infinitely many times?\"\n        )\n        words.set_width(FRAME_WIDTH - 1)\n        words.to_edge(UP)\n\n        self.add(words)\n\n\nclass SpiritOfIMO(PiCreatureScene):\n    def construct(self):\n        randy = self.pi_creature\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems.scale(1.5)\n        problems[3:].shift(1.5 * RIGHT)\n        problems.to_corner(UR, buff=LARGE_BUFF)\n        problems.shift(2 * LEFT)\n\n        light_bulbs = VGroup()\n        lights = VGroup()\n        for problem in problems:\n            light_bulb = Lightbulb()\n            light_bulb.base = light_bulb[:3]\n            light_bulb.light = light_bulb[3:]\n            light_bulb.set_height(1)\n            light_bulb.next_to(problem, RIGHT)\n            light_bulbs.add(light_bulb)\n\n            light = self.get_light(light_bulb.get_center())\n            lights.add(light)\n\n        self.play(\n            LaggedStartMap(FadeInFromDown, problems)\n        )\n        self.play(\n            LaggedStartMap(\n                FadeIn, light_bulbs,\n                run_time=1,\n            ),\n            LaggedStartMap(\n                LaggedStartMap, lights,\n                lambda l: (VFadeInThenOut, l),\n                run_time=3\n            ),\n            randy.change, \"thinking\"\n        )\n        self.wait()\n        self.pi_creature_thinks(\n            \"Oh, I've\\\\\\\\seen this...\",\n            target_mode=\"surprised\",\n        )\n        self.wait(3)\n\n    def get_light(self, point):\n        radii = np.arange(0, 5, 0.1)\n        result = VGroup(*[\n            Annulus(\n                inner_radius=r1,\n                outer_radius=r2,\n                arc_center=point,\n                fill_opacity=(1 / (r1 + 1)**2),\n                fill_color=YELLOW,\n            )\n            for r1, r2 in zip(radii[1:], radii[2:])\n        ])\n        return result\n\n\n# TODO\nclass HowToPrepareForThis(Scene):\n    def construct(self):\n        pass\n\n\nclass HarderThanExpected(TeacherStudentsScene):\n    def construct(self):\n        title = TextMobject(\"Unusual aspect \\\\#2\")\n        title.scale(1.5)\n        title.to_edge(UP)\n\n        line = Line(LEFT, RIGHT)\n        line.match_width(title)\n        line.next_to(title, DOWN)\n\n        words = TextMobject(\"Harder than expected\")\n        words.set_color(RED)\n        words.scale(1.5)\n        words.next_to(line, DOWN, LARGE_BUFF)\n\n        self.play(\n            FadeInFromDown(title),\n            ShowCreation(line),\n            self.teacher.change, \"raise_right_hand\",\n            self.get_student_changes(\"pondering\", \"confused\", \"sassy\")\n        )\n        self.wait()\n        self.play(\n            FadeInFrom(words, UP),\n            self.get_student_changes(*3 * [\"horrified\"]),\n        )\n        self.wait(3)\n\n\nclass TraditionalDifficulty(ContrastToOtherOlympiadProblems):\n    def construct(self):\n        test = self.get_test()\n        rects = self.get_all_rects(test)\n        for rect in rects:\n            rect.reverse_points()\n\n        big_rects = VGroup(*[\n            FullScreenFadeRectangle()\n            for x in range(3)\n        ])\n        for br, r1, r2 in zip(big_rects, rects, rects[3:]):\n            br.append_vectorized_mobject(r1)\n            br.append_vectorized_mobject(r2)\n        big_rect = big_rects[0].copy()\n\n        p_labels = VGroup()\n        for i, rect in enumerate(rects):\n            p_label = TextMobject(\"P{}\".format(i + 1))\n            p_label.next_to(rect, LEFT)\n            p_labels.add(p_label)\n\n        arrow = Vector(3 * DOWN)\n        arrow.next_to(test[0], RIGHT)\n        arrow.match_y(rects)\n        harder_words = TextMobject(\"Get harder\")\n        harder_words.scale(2)\n        harder_words.next_to(arrow, RIGHT)\n        harder_words.set_color(RED)\n\n        p_words = VGroup(\n            TextMobject(\"Doable\", color=GREEN),\n            TextMobject(\"Challenging\", color=YELLOW),\n            TextMobject(\"Brutal\", color=RED),\n        )\n        p_words.add(*p_words.copy())\n        for rect, word, label in zip(rects, p_words, p_labels):\n            word.next_to(rect, UP)\n            label.match_color(word)\n\n        self.add(test[0])\n        self.play(\n            FadeIn(harder_words),\n            GrowArrow(arrow),\n            LaggedStart(*[FadeInFrom(p, UP) for p in p_labels[:3]]),\n            LaggedStartMap(ShowCreation, rects[:3]),\n        )\n        self.wait()\n        self.play(\n            FadeIn(test[1]),\n            FadeIn(p_labels[3:]),\n            FadeIn(rects[3:]),\n            FadeOut(harder_words),\n            FadeOut(arrow),\n        )\n        self.wait()\n        self.add(big_rect, p_labels[0], p_labels[3])\n        self.play(\n            FadeIn(big_rect),\n            FadeOut(rects),\n            FadeOut(p_labels[1:3]),\n            FadeOut(p_labels[4:]),\n            FadeInFromDown(p_words[0::3]),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[1]),\n            FadeOut(p_labels[0::3]),\n            FadeIn(p_labels[1::3]),\n            FadeOutAndShift(p_words[0::3], DOWN),\n            FadeInFrom(p_words[1::3], UP),\n        )\n        self.wait()\n        self.play(\n            Transform(big_rect, big_rects[2]),\n            FadeOut(p_labels[1::3]),\n            FadeIn(p_labels[2::3]),\n            FadeOutAndShift(p_words[1::3], DOWN),\n            FadeInFrom(p_words[2::3], UP),\n        )\n        self.wait()\n\n\nclass PerfectScoreData(Describe2011IMO):\n    CONFIG = {\n        \"n_students\": 563,\n        \"n_perfect_scores_per_problem\": [\n            345, 22, 51, 267, 170, 6,\n        ],\n        \"full_bar_width\": 7,\n    }\n\n    def construct(self):\n        self.add_title()\n        self.show_total_number_of_students()\n        self.add_subtitle()\n        self.show_data()\n        self.analyze_data()\n\n    def add_title(self):\n        self.force_skipping()\n        super().add_title()\n        self.revert_to_original_skipping_status()\n        self.title.center().to_edge(UP)\n\n    def show_total_number_of_students(self):\n        title = self.title\n\n        bar = self.get_bar(self.n_students, ORIGIN)\n        bar.next_to(title, DOWN, buff=0.3)\n        counter = self.get_bar_counter(bar)\n        counter_label = TextMobject(\"Students\")\n        counter_label.add_updater(\n            lambda m: m.next_to(counter, RIGHT)\n        )\n\n        self.add(counter, counter_label)\n        self.play(\n            self.get_bar_growth_anim(bar),\n            run_time=2,\n        )\n        self.wait()\n\n    def add_subtitle(self):\n        title = self.title\n\n        subtitle = TextMobject(\n            \"Number of perfect scores on each problem:\"\n        )\n        subtitle.scale(1.25)\n        subtitle.set_color(GREEN)\n        subtitle.next_to(title, DOWN, buff=LARGE_BUFF)\n\n        problems = VGroup(*[\n            TextMobject(\"P{})\".format(i))\n            for i in range(1, 7)\n        ])\n        problems.arrange_in_grid(n_cols=2, buff=LARGE_BUFF)\n        problems[3:].shift(5 * RIGHT)\n        problems.next_to(subtitle, DOWN, LARGE_BUFF)\n        problems.to_edge(LEFT)\n\n        self.play(\n            FadeInFromDown(subtitle),\n            LaggedStartMap(FadeInFromDown, problems),\n        )\n\n        self.problems = problems\n\n    def show_data(self):\n        problems = self.problems\n        bars = VGroup(*[\n            self.get_bar(n, p.get_right() + SMALL_BUFF * RIGHT)\n            for n, p in zip(\n                self.n_perfect_scores_per_problem,\n                problems,\n            )\n        ])\n        counters = VGroup(*map(self.get_bar_counter, bars))\n\n        self.play(\n            VFadeIn(counters),\n            *[\n                self.get_bar_growth_anim(bar)\n                for bar in bars\n            ],\n        )\n        counters.set_fill(WHITE, 1)\n        self.wait()\n\n        self.problem_bars = bars\n        self.problem_counters = counters\n\n    def analyze_data(self):\n        problems = VGroup(*[\n            VGroup(p, pb, pc)\n            for p, pb, pc in zip(\n                self.problems,\n                self.problem_bars,\n                self.problem_counters,\n            )\n        ])\n        rects = VGroup(*[\n            SurroundingRectangle(p, color=p[1].get_color())\n            for p in problems\n        ])\n\n        rect = rects[1].copy()\n        self.play(ShowCreation(rect))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[4]))\n        self.wait()\n        self.play(TransformFromCopy(rect, rects[2]))\n        self.wait()\n        self.play(\n            ReplacementTransform(rect, rects[5]),\n            ReplacementTransform(rects[4], rects[5]),\n            ReplacementTransform(rects[2], rects[5]),\n        )\n        self.wait()\n\n    #\n    def get_bar(self, number, left_side):\n        bar = Rectangle()\n        bar.set_stroke(width=0)\n        bar.set_fill(WHITE, 1)\n        bar.set_height(0.25)\n        bar.set_width(\n            self.full_bar_width * number / self.n_students,\n            stretch=True\n        )\n        bar.move_to(left_side, LEFT)\n\n        def update_bar_color(bar):\n            frac = bar.get_width() / self.full_bar_width\n            if 0 < frac <= 0.25:\n                alpha = 4 * frac\n                bar.set_color(interpolate_color(RED, YELLOW, alpha))\n            elif 0.25 < frac <= 0.5:\n                alpha = 4 * (frac - 0.25)\n                bar.set_color(interpolate_color(YELLOW, GREEN, alpha))\n            else:\n                alpha = 2 * (frac - 0.5)\n                bar.set_color(interpolate_color(GREEN, BLUE, alpha))\n        bar.add_updater(update_bar_color)\n        return bar\n\n    def get_bar_growth_anim(self, bar):\n        bar.save_state()\n        bar.stretch(0, 0, about_edge=LEFT)\n        return Restore(\n            bar,\n            suspend_mobject_updating=False,\n            run_time=2,\n        )\n\n    def get_bar_counter(self, bar):\n        counter = Integer()\n        counter.add_updater(\n            lambda m: m.set_value(\n                self.n_students * bar.get_width() / self.full_bar_width\n            )\n        )\n        counter.add_updater(lambda m: m.next_to(bar, RIGHT, SMALL_BUFF))\n        return counter\n\n\nclass SixOnSix(Describe2011IMO):\n    CONFIG = {\n        \"student_data\": [\n            [1, \"Lisa Sauermann\", \"de\", [7, 7, 7, 7, 7, 7]],\n            [2, \"Jeck Lim\", \"sg\", [7, 5, 7, 7, 7, 7]],\n            [3, \"Lin Chen\", \"cn\", [7, 3, 7, 7, 7, 7]],\n            [14, \"Mina Dalirrooyfard\", \"ir\", [7, 0, 2, 7, 7, 7]],\n            [202, \"Georgios Kalantzis\", \"gr\", [7, 0, 1, 1, 2, 7]],\n            [202, \"Chi Hong Chow\", \"hk\", [7, 0, 3, 1, 0, 7]],\n        ],\n    }\n\n    def construct(self):\n        grid = self.get_score_grid()\n        grid.to_edge(DOWN, buff=LARGE_BUFF)\n        for row in grid.rows:\n            row[0].set_opacity(0)\n        grid.h_lines.stretch(0.93, 0, about_edge=RIGHT)\n\n        sf = 1.25\n        title = TextMobject(\"Only 6 solved P6\")\n        title.scale(sf)\n        title.to_edge(UP, buff=MED_SMALL_BUFF)\n        subtitle = TextMobject(\"P2 evaded 5 of them\")\n        subtitle.set_color(YELLOW)\n        subtitle.scale(sf)\n        subtitle.next_to(title, DOWN)\n\n        six_rect, two_rect = [\n            SurroundingRectangle(VGroup(\n                grid.rows[0][index],\n                grid.rows[-1][index],\n            ))\n            for index in [7, 3]\n        ]\n\n        self.play(\n            Write(title),\n            LaggedStart(*[FadeInFrom(row, UP) for row in grid.rows]),\n            LaggedStart(*[ShowCreation(line) for line in grid.h_lines]),\n        )\n        self.play(ShowCreation(six_rect))\n        self.wait()\n        self.play(\n            ReplacementTransform(six_rect, two_rect),\n            FadeInFrom(subtitle, UP)\n        )\n        self.wait()\n\n\nclass AlwaysStartSimple(TeacherStudentsScene):\n    def construct(self):\n        self.teacher_says(\"Always start\\\\\\\\simple\")\n        self.change_all_student_modes(\"pondering\")\n        self.wait(3) </s> remove         self.let_windmill_run(windmill, 8) </s> add         self.let_windmill_run(windmill, 16)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>         for rect in rects:\n <mask>             self.play(rect.set_opacity, 1)\n <mask>             self.play(rect.set_opacity, rects.const_opacity)\n <mask>         self.wait()\n <mask>         self.play(\n <mask>             counters.space_out_submobjects, 0.8,\n <mask>             counters.next_to, mid_words, DOWN, LARGE_BUFF,\n <mask>             FadeOut(label_sets),\n <mask>         ) </s> add         rects.suspend_updating() </s> add         self.zoom_to_other_questions()\n\n    def zoom_to_other_questions(self):\n        test = self.get_test()\n        rects = self.get_all_rects()\n\n        big_rects = VGroup()\n        for rect in rects:\n            big_rect = FullScreenFadeRectangle()\n            rect.reverse_points()\n            big_rect.append_vectorized_mobject(rect)\n            big_rects.add(big_rect)\n\n        frame = self.camera_frame\n        frame.generate_target()\n        frame.target.scale(0.35)\n        frame.target.move_to(rects[1])\n        big_rect = big_rects[1].copy()\n\n        self.add(test)\n        self.play(\n            FadeIn(big_rect),\n            MoveToTarget(frame, run_time=3),\n        )\n        self.wait()\n        for i in [2, 0, 3, 5]:\n            self.play(\n                frame.move_to, rects[i],\n                Transform(big_rect, big_rects[i])\n            )\n            self.wait()\n\n    def get_all_rects(self, test):\n        rects = self.get_problem_rects(test[0])\n        new_rects = VGroup(rects[1], rects[0], rects[2]).copy()\n        new_rects[0].stretch(0.85, 1)\n        new_rects[1].stretch(0.8, 1)\n        new_rects[2].stretch(0.8, 1)\n        new_rects.arrange(DOWN, buff=0.08)\n        new_rects.move_to(test[1])\n        new_rects.align_to(rects, UP)\n        rects.add(*new_rects)\n        return rects", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     def ask_about_numbers(self):\n <mask>         self.windmill.rot_speed *= 0.5\n <mask>         self.let_windmill_run(self.windmill, 20)\n <mask> \n <mask> \n <mask> class SecondColoringExample(WindmillScene):\n <mask>     CONFIG = {\n <mask>         \"run_time\": 30, </s> remove         \"windmill_rotation_speed\": TAU / 8, </s> add         points = self.get_random_point_set(11)\n        points[:, 0] *= 1.7\n        points += 0.5 * LEFT\n\n        points[1] += DR + 0.5 * DOWN\n        points[10] += LEFT\n        points[6] += 3 * RIGHT\n\n        windmill = self.get_windmill(\n            points, points[1],\n            angle=45 * DEGREES,\n        )\n        dots = self.get_dots(points)\n        rects = self.get_left_right_colorings(windmill)\n        pivot_dot = self.get_pivot_dot(windmill)\n        pivot_dot.scale(2)\n        pivot_dot.set_color(WHITE)\n\n        new_pivot = points[5]\n        new_pivot2 = points[3]\n\n        flash = Flash(pivot_dot, flash_radius=0.5)\n\n        wa = windmill.get_angle()\n        arcs = VGroup(*[\n            Arc(\n                start_angle=wa + a,\n                angle=90 * DEGREES,\n                radius=1.5,\n                stroke_width=10,\n            ).add_tip(tip_length=0.7)\n            for a in [0, PI]\n        ])\n        arcs.move_to(windmill.pivot)\n        arcs.set_color([LIGHT_GREY, WHITE])\n\n        self.add(rects[0], windmill, dots, pivot_dot)\n        self.add(arcs)\n        self.add(flash.mobject)\n        self.add_dot_color_updater(dots, windmill, color2=WHITE)\n\n        words = TextMobject(\"Next\\\\\\\\\", \"pivot\")\n        words2 = TextMobject(\"Next \", \"next\\\\\\\\\", \"pivot\", alignment=\"\")\n        words.scale(2)\n        words2.scale(2)\n        # words.next_to(windmill.pivot, RIGHT)\n        words.to_edge(UR)\n        words2.to_corner(DL)\n\n        arrow = Arrow(words[1].get_left(), new_pivot, buff=0.6)\n        arrow.set_stroke(width=10)\n        arrow.set_color(YELLOW)\n        arrow2 = Arrow(words2[-1].get_right(), new_pivot2, buff=0.6)\n        arrow2.match_style(arrow)\n\n        self.add(words, arrow)\n        self.add(words2, arrow2)\n\n        # for i, dot in enumerate(dots):\n        #     self.add(Integer(i).move_to(dot))\n\n\nclass Thumbnail2(Scene):\n    def construct(self):\n        words = TextMobject(\"Olympics\\\\\\\\\", \"for\\\\\\\\\", \"math\", alignment=\"\")\n        # words.arrange(DOWN, aligned_edge=LEFT)\n\n        words.set_height(FRAME_HEIGHT - 1.5)\n        words.to_edge(LEFT)\n\n        logo = ImageMobject(\"imo_logo\")\n        logo.set_height(4.5)\n        logo.to_corner(DR, buff=LARGE_BUFF)\n\n        rect = FullScreenFadeRectangle()\n        rect.set_fill([GREY, BLACK], 1)\n\n        self.clear()\n        self.add(rect)\n        self.add(words)\n        self.add(logo)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace", "code_tokens": " <mask> \n <mask> \n <mask> class NewSceneName(Scene):\n <mask>     def construct(self):\n <mask>         pass </s> remove # TODO\nclass ContrastToOtherOlympiadProblems(Scene): </s> add class FootnoteToIMOIntro(Scene):\n    def construct(self):\n        words = TextMobject(\"$^*$Based on data from 2019 test\")\n        self.play(FadeInFrom(words, UP))\n        self.wait()", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "active_projects/windmill.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     # TODO, fix this\n <mask>     animation_dir = os.path.join(\n <mask>         os.path.expanduser('~'),\n <mask>         \"Dropbox (3Blue1Brown)/3Blue1Brown Team Folder/videos\",\n <mask>         \"diffyq\", \"part5\", \"1440p60\"\n <mask>     )\n <mask>     # \n <mask>     files = os.listdir(animation_dir)\n <mask>     sorted_files = []\n <mask>     for scene_class in scene_classes: </s> remove             code_map = json.load(fp)", "html_url": "https://github.com/3b1b/manim/commit/00b5aaeb2675f858a4afb703811d115acd72fad2", "file_name": "stage_scenes.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         \"fill_dtype\": [\n <mask>             ('point', np.float32, (3,)),\n <mask>             ('color', np.float32, (4,)),\n <mask>             ('fill_all', np.float32, (1,)),\n <mask>             ('orientation', np.float32, (1,)),\n <mask>         ],\n <mask>         \"stroke_dtype\": [\n <mask>             (\"point\", np.float32, (3,)),\n <mask>             (\"prev_point\", np.float32, (3,)),\n <mask>             (\"next_point\", np.float32, (3,)), </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient; </s> remove         inner_tri_indices = inner_vert_indices[\n            earclip_triangulation(inner_verts, rings)\n        ] </s> add         inner_tri_indices = inner_vert_indices[earclip_triangulation(inner_verts, rings)] </s> remove         data[\"orientation\"] = orientation </s> add         # Always send points in a positively oriented way\n        if orientation < 0:\n            data[\"point\"][:len(points)] = points[::-1] </s> remove in float fill_type; </s> add in float fill_all;  // Either 0 or 1e </s> remove // Needed for quadratic_bezier_distance </s> add // Needed for quadratic_bezier_distance insertion below", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         rings = np.arange(1, len(inner_vert_indices) + 1)[inner_vert_indices % 3 == 2]\n <mask> \n <mask>         # Triangulate\n <mask>         inner_verts = points[inner_vert_indices]\n <mask>         inner_tri_indices = inner_vert_indices[\n <mask>             earclip_triangulation(inner_verts, rings)\n <mask>         ]\n <mask> \n <mask>         tri_indices = np.hstack([indices, inner_tri_indices])\n <mask>         return tri_indices\n <mask> \n <mask>     def get_fill_shader_data(self): </s> add         # Always send points in a positively oriented way\n        if orientation < 0:\n            data[\"point\"][:len(points)] = points[::-1] </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> add         return;\n    }\n\n    vec2 new_bp[3];\n    int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n    bezier_degree = float(n);\n    vec2 bp0, bp1, bp2;\n    if(n == 0){\n        return;  // Don't emit any vertices\n    }\n    else if(n == 1){\n        bp0 = new_bp[0];\n        bp2 = new_bp[1];\n        bp1 = 0.5 * (bp0 + bp2); </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         # Assume the triangulation is such that the first n_points points\n <mask>         # are on the boundary, and the rest are in the interior\n <mask>         data[\"fill_all\"][:len(points)] = 0\n <mask>         data[\"fill_all\"][len(points):] = 1\n <mask>         data[\"orientation\"] = orientation\n <mask> \n <mask>         return data\n <mask> \n <mask> \n <mask> class VGroup(VMobject):\n <mask>     def __init__(self, *vmobjects, **kwargs): </s> remove         inner_tri_indices = inner_vert_indices[\n            earclip_triangulation(inner_verts, rings)\n        ] </s> add         inner_tri_indices = inner_vert_indices[earclip_triangulation(inner_verts, rings)]", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/mobject/types/vectorized_mobject.py"}
{"docstring_tokens": "keep keep replace keep keep keep replace keep keep keep keep", "code_tokens": " <mask> \n <mask> in vec4 color;\n <mask> in float fill_type;\n <mask> in float uv_anti_alias_width;\n <mask> \n <mask> in vec2 uv_coords;\n <mask> in vec2 wz_coords;\n <mask> in vec2 uv_b2;\n <mask> in float bezier_degree;\n <mask> \n <mask> out vec4 frag_color; </s> remove in float v_orientation[3]; </s> remove out float fill_type; </s> add out float fill_all; </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1 </s> remove // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\nout vec2 wz_coords; </s> remove     float epsilon = 1e-6; </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_frag.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> const float FILL_OUTSIDE = 1;\n <mask> const float FILL_ALL = 2;\n <mask> \n <mask> \n <mask> // Needed for quadratic_bezier_distance\n <mask> float modify_distance_for_endpoints(vec2 p, float dist, float t){\n <mask>     return dist;\n <mask> }\n <mask> \n <mask> // To my knowledge, there is no notion of #include for shaders, </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\nout vec2 wz_coords; </s> remove     float epsilon = 1e-6; </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1 </s> remove \nbool is_inside_curve(){\n    if(bezier_degree < 2) return false;\n\n    float value = wz_coords.x * wz_coords.x - wz_coords.y;\n    if(fill_type == FILL_INSIDE) return value < 0;\n    if(fill_type == FILL_OUTSIDE) return value > 0;\n    return false;\n} </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove out float fill_type; </s> add out float fill_all;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_frag.glsl"}
{"docstring_tokens": "keep keep replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep keep keep replace replace", "code_tokens": " <mask> #INSERT quadratic_bezier_distance.glsl\n <mask> \n <mask> \n <mask> bool is_inside_curve(){\n <mask>     if(bezier_degree < 2) return false;\n <mask> \n <mask>     float value = wz_coords.x * wz_coords.x - wz_coords.y;\n <mask>     if(fill_type == FILL_INSIDE) return value < 0;\n <mask>     if(fill_type == FILL_OUTSIDE) return value > 0;\n <mask>     return false;\n <mask> }\n <mask> \n <mask> \n <mask> float sdf(){\n <mask>     if(is_inside_curve()) return -1.0;\n <mask>     return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n <mask> }\n <mask> \n <mask> \n <mask> float sdf(){\n <mask>     if(is_inside_curve()) return -1.0;\n <mask>     return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> add </s> remove // Needed for quadratic_bezier_distance </s> add // Needed for quadratic_bezier_distance insertion below </s> remove         inner_tri_indices = inner_vert_indices[\n            earclip_triangulation(inner_verts, rings)\n        ] </s> add         inner_tri_indices = inner_vert_indices[earclip_triangulation(inner_verts, rings)] </s> remove         data[\"orientation\"] = orientation </s> add         # Always send points in a positively oriented way\n        if orientation < 0:\n            data[\"point\"][:len(points)] = points[::-1]", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_frag.glsl"}
{"docstring_tokens": "keep keep keep replace keep replace", "code_tokens": " <mask> void main() {\n <mask>     if (color.a == 0) discard;\n <mask>     frag_color = color;\n <mask>     if (fill_type == FILL_ALL) return;\n <mask>     frag_color.a *= smoothstep(1, 0, sdf() / uv_anti_alias_width);\n <mask>     // frag_color.a += 0.2; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_frag.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep replace keep keep keep keep", "code_tokens": " <mask> \n <mask> in vec3 bp[3];\n <mask> in vec4 v_color[3];\n <mask> in float v_fill_all[3];\n <mask> in float v_orientation[3];\n <mask> \n <mask> out vec4 color;\n <mask> out float fill_type;\n <mask> out float uv_anti_alias_width;\n <mask> \n <mask> // uv space is where b0 = (0, 0), b1 = (1, 0), and transform is orthogonal\n <mask> out vec2 uv_coords; </s> remove // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\nout vec2 wz_coords; </s> remove in vec2 wz_coords; </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1 </s> remove in float fill_type; </s> add in float fill_all;  // Either 0 or 1e </s> remove out float v_orientation;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> // uv space is where b0 = (0, 0), b1 = (1, 0), and transform is orthogonal\n <mask> out vec2 uv_coords;\n <mask> out vec2 uv_b2;\n <mask> // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\n <mask> out vec2 wz_coords;\n <mask> \n <mask> out float bezier_degree;\n <mask> \n <mask> const float FILL_INSIDE = 0;\n <mask> const float FILL_OUTSIDE = 1; </s> remove out float fill_type; </s> add out float fill_all; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad); </s> remove // Needed for quadratic_bezier_distance </s> add // Needed for quadratic_bezier_distance insertion below </s> remove in vec2 wz_coords; </s> remove     float epsilon = 1e-6; </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n}", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> // replaces this line with the contents of named file\n <mask> #INSERT quadratic_bezier_geometry_functions.glsl\n <mask> #INSERT scale_and_shift_point_for_frame.glsl\n <mask> \n <mask> \n <mask> mat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n <mask>     // If linear or null, this matrix is not needed\n <mask>     if(bezier_degree < 2) return mat3(1.0);\n <mask> \n <mask>     vec2 inv_col1 = 2 * (b1 - b0);\n <mask>     vec2 inv_col2 = b2 - 2 * b1 + b0;\n <mask>     float inv_det = cross(inv_col1, inv_col2);\n <mask> \n <mask>     mat3 transform = mat3(\n <mask>         inv_col2.y, -inv_col1.y, 0,\n <mask>         -inv_col2.x, inv_col1.x, 0,\n <mask>         0, 0, inv_det\n <mask>     ) / inv_det;\n <mask> \n <mask>     mat3 shift = mat3(\n <mask>         1, 0, 0,\n <mask>         0, 1, 0,\n <mask>         -b0.x, -b0.y, 1\n <mask>     );\n <mask>     return transform * shift;\n <mask> }\n <mask> \n <mask> \n <mask> void emit_simple_triangle(){\n <mask>     for(int i = 0; i < 3; i++){\n <mask>         color = v_color[i];\n <mask>         gl_Position = vec4(\n <mask>             scale_and_shift_point_for_frame(bp[i]), </s> remove     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2); </s> add     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2); </s> remove \nbool is_inside_curve(){\n    if(bezier_degree < 2) return false;\n\n    float value = wz_coords.x * wz_coords.x - wz_coords.y;\n    if(fill_type == FILL_INSIDE) return value < 0;\n    if(fill_type == FILL_OUTSIDE) return value > 0;\n    return false;\n} </s> add         float z = bp[nearest_bp_index_map[i]].z; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep replace keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2, float orientation){\n <mask>     // Tangent vectors\n <mask>     vec2 t01 = normalize(bp1 - bp0);\n <mask>     vec2 t12 = normalize(bp2 - bp1);\n <mask> \n <mask>     // Inside and left turn -> rot right -> -1\n <mask>     // Outside and left turn -> rot left -> +1\n <mask>     // Inside and right turn -> rot left -> +1\n <mask>     // Outside and right turn -> rot right -> -1\n <mask>     float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n <mask>     c_orient *= orientation;\n <mask> \n <mask>     bool fill_in = (c_orient > 0);\n <mask>     fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n <mask> \n <mask>     // float orient = in_or_out * c_orient;\n <mask> \n <mask>     // Normal vectors\n <mask>     // Rotate tangent vector 90-degrees clockwise\n <mask>     // if the curve is positively oriented, otherwise </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0); </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove     bool distinct_01 = length(v01) > epsilon;  // v01 is considered nonzero\n    bool distinct_12 = length(v12) > epsilon;  // v12 is considered nonzero </s> add     // bool aligned = abs(cross(normalize(v01), normalize(v12))) < angle_threshold;\n    bool aligned = acos(dot(normalize(v01), normalize(v12))) < angle_threshold;\n    bool distinct_01 = length(v01) > length_threshold;  // v01 is considered nonzero\n    bool distinct_12 = length(v12) > length_threshold;  // v12 is considered nonzero </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad); </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     // float orient = in_or_out * c_orient;\n <mask> \n <mask>     // Normal vectors\n <mask>     // Rotate tangent vector 90-degrees clockwise\n <mask>     // if the curve is positively oriented, otherwise\n <mask>     // rotate it 90-degrees counterclockwise\n <mask>     vec2 n01 = orientation * vec2(t01.y, -t01.x);\n <mask>     vec2 n12 = orientation * vec2(t12.y, -t12.x);\n <mask> \n <mask>     float aaw = anti_alias_width;\n <mask>     vec2 nudge1 = fill_in ? 0.5 * aaw * (n01 + n12) : vec2(0);\n <mask>     vec2 corners[5] = vec2[5](\n <mask>         bp0 + aaw * n01, </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient; </s> add </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation); </s> add         bp0 = new_bp[0];\n        bp1 = new_bp[1];\n        bp2 = new_bp[2]; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad); </s> add         return;\n    }\n\n    vec2 new_bp[3];\n    int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n    bezier_degree = float(n);\n    vec2 bp0, bp1, bp2;\n    if(n == 0){\n        return;  // Don't emit any vertices\n    }\n    else if(n == 1){\n        bp0 = new_bp[0];\n        bp2 = new_bp[1];\n        bp1 = 0.5 * (bp0 + bp2); </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> add", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     int coords_index_map[5] = int[5](0, 1, 2, 3, 4);\n <mask>     if(!fill_in) coords_index_map = int[5](1, 0, 2, 4, 3);\n <mask>         \n <mask>     mat3 xy_to_uv = get_xy_to_uv(bp0, bp1);\n <mask>     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2);\n <mask>     uv_b2 = (xy_to_uv * vec3(bp2, 1)).xy;\n <mask>     uv_anti_alias_width = anti_alias_width / length(bp1 - bp0);\n <mask> \n <mask>     for(int i = 0; i < 5; i++){\n <mask>         vec2 corner = corners[coords_index_map[i]]; </s> add     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2); </s> add         float z = bp[nearest_bp_index_map[i]].z; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove         wz_coords = (xy_to_wz * vec3(corner, 1)).xy;\n        float z; </s> remove void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2, float orientation){ </s> add void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2){ </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep add keep keep keep keep", "code_tokens": " <mask>     uv_b2 = (xy_to_uv * vec3(bp2, 1)).xy;\n <mask>     uv_anti_alias_width = anti_alias_width / length(bp1 - bp0);\n <mask> \n <mask>     for(int i = 0; i < 5; i++){\n <mask>         vec2 corner = corners[coords_index_map[i]];\n <mask>         float z = bp[nearest_bp_index_map[i]].z;\n <mask>         uv_coords = (xy_to_uv * vec3(corner, 1)).xy; </s> remove     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2); </s> remove         wz_coords = (xy_to_wz * vec3(corner, 1)).xy;\n        float z; </s> add         float z = bp[nearest_bp_index_map[i]].z; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove         if(i < 2){\n            color = v_color[0];\n            z = bp[0].z;\n        }\n        else if(i == 2){\n            color = v_color[1];\n            z = bp[1].z;\n        }\n        else{\n            color = v_color[2];\n            z = bp[2].z;\n        } </s> add         if(i < 2)       color = v_color[0];\n        else if(i == 2) color = v_color[1];\n        else            color = v_color[2]; </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2);\n <mask>     for(int i = 0; i < 5; i++){\n <mask>         vec2 corner = corners[coords_index_map[i]];\n <mask>         uv_coords = (xy_to_uv * vec3(corner, 1)).xy;\n <mask>         // I haven't a clue why an index map doesn't work just\n <mask>         // as well here, but for some reason it doesn't.\n <mask>         if(i < 2)       color = v_color[0];\n <mask>         else if(i == 2) color = v_color[1]; </s> remove         wz_coords = (xy_to_wz * vec3(corner, 1)).xy;\n        float z; </s> remove         if(i < 2){\n            color = v_color[0];\n            z = bp[0].z;\n        }\n        else if(i == 2){\n            color = v_color[1];\n            z = bp[1].z;\n        }\n        else{\n            color = v_color[2];\n            z = bp[2].z;\n        } </s> add         if(i < 2)       color = v_color[0];\n        else if(i == 2) color = v_color[1];\n        else            color = v_color[2]; </s> add     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2); </s> remove     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2); </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep replace replace keep keep replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask>         vec2 corner = corners[coords_index_map[i]];\n <mask>         uv_coords = (xy_to_uv * vec3(corner, 1)).xy;\n <mask>         wz_coords = (xy_to_wz * vec3(corner, 1)).xy;\n <mask>         float z;\n <mask>         // I haven't a clue why an index map doesn't work just\n <mask>         // as well here, but for some reason it doesn't.\n <mask>         if(i < 2){\n <mask>             color = v_color[0];\n <mask>             z = bp[0].z;\n <mask>         }\n <mask>         else if(i == 2){\n <mask>             color = v_color[1];\n <mask>             z = bp[1].z;\n <mask>         }\n <mask>         else{\n <mask>             color = v_color[2];\n <mask>             z = bp[2].z;\n <mask>         }\n <mask>         gl_Position = vec4(\n <mask>             scale_and_shift_point_for_frame(vec3(corner, z)),\n <mask>             1.0 </s> add         float z = bp[nearest_bp_index_map[i]].z; </s> add     int nearest_bp_index_map[5] = int[5](0, 0, 1, 2, 2); </s> remove     mat3 xy_to_wz = get_xy_to_wz(bp0, bp1, bp2); </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove     if(is_inside_curve()) return -1.0;\n    return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false); </s> add     // For really flat curves, just take the distance to the curve\n    if(bezier_degree < 2 || abs(uv_b2.y / uv_b2.x) < uv_anti_alias_width){\n        return min_dist_to_curve(uv_coords, uv_b2, bezier_degree, false);\n    }\n    // This converts uv_coords to a space where the bezier points sit on\n    // (0, 0), (1/2, 0) and (1, 1), so that the curve can be expressed implicityly\n    // as y = x^2.\n    float u2 = uv_b2.x;\n    float v2 = uv_b2.y;\n    mat2 to_simple_space = mat2(\n        v2, 0,\n        2 - u2, 4 * v2\n    );\n    vec2 p = to_simple_space * uv_coords;\n\n    float Fp = sign(v2) * (p.x * p.x - p.y);\n\n    vec2 grad = vec2(\n        - 2 * p.x * v2,  // del C / del u\n        4 * v2 - 4 * p.x * (2 - u2)  // del C / del v\n    );\n    return Fp / length(grad);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep replace keep keep replace keep", "code_tokens": " <mask> \n <mask> void main(){\n <mask>     float fill_all = v_fill_all[0];\n <mask> \n <mask>     if(fill_all == 1){\n <mask>         fill_type = FILL_ALL;\n <mask>         emit_simple_triangle(); </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove     v_orientation = orientation; </s> remove out float v_orientation; </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep add keep keep keep keep keep keep", "code_tokens": " <mask> \n <mask>     if(fill_all == 1){\n <mask>         emit_simple_triangle();\n <mask>     }else{\n <mask>         bp0 = new_bp[0];\n <mask>         bp1 = new_bp[1];\n <mask>         bp2 = new_bp[2];\n <mask>     }\n <mask>  </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation); </s> add         bp0 = new_bp[0];\n        bp1 = new_bp[1];\n        bp2 = new_bp[2]; </s> remove     float fill_all = v_fill_all[0]; </s> add     fill_all = v_fill_all[0]; </s> add     emit_pentagon(bp0, bp1, bp2); </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep", "code_tokens": " <mask>     if(fill_all == 1){\n <mask>         fill_type = FILL_ALL;\n <mask>         emit_simple_triangle();\n <mask>     }else{\n <mask>         vec2 new_bp[3];\n <mask>         int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n <mask>         bezier_degree = float(n);\n <mask>         float orientation = v_orientation[0];\n <mask> \n <mask>         vec2 bp0, bp1, bp2;\n <mask>         if(n == 0){\n <mask>             return;  // Don't emit any vertices\n <mask>         }\n <mask>         else if(n == 1){\n <mask>             bp0 = new_bp[0];\n <mask>             bp2 = new_bp[1];\n <mask>             bp1 = 0.5 * (bp0 + bp2);\n <mask>         }else{\n <mask>             bp0 = new_bp[0];\n <mask>             bp1 = new_bp[1];\n <mask>             bp2 = new_bp[2];\n <mask>         }\n <mask> \n <mask>         emit_pentagon(bp0, bp1, bp2, orientation);\n <mask>     }\n <mask> }\n <mask>  </s> add         return;\n    }\n\n    vec2 new_bp[3];\n    int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n    bezier_degree = float(n);\n    vec2 bp0, bp1, bp2;\n    if(n == 0){\n        return;  // Don't emit any vertices\n    }\n    else if(n == 1){\n        bp0 = new_bp[0];\n        bp2 = new_bp[1];\n        bp1 = 0.5 * (bp0 + bp2); </s> add     emit_pentagon(bp0, bp1, bp2); </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0); </s> remove void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2, float orientation){ </s> add void emit_pentagon(vec2 bp0, vec2 bp1, vec2 bp2){", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep add keep keep", "code_tokens": " <mask>         bp2 = new_bp[2];\n <mask>     }\n <mask> }\n <mask>  </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation); </s> add         bp0 = new_bp[0];\n        bp1 = new_bp[1];\n        bp2 = new_bp[2]; </s> add         return;\n    }\n\n    vec2 new_bp[3];\n    int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n    bezier_degree = float(n);\n    vec2 bp0, bp1, bp2;\n    if(n == 0){\n        return;  // Don't emit any vertices\n    }\n    else if(n == 1){\n        bp0 = new_bp[0];\n        bp2 = new_bp[1];\n        bp1 = 0.5 * (bp0 + bp2); </s> remove     v_orientation = orientation; </s> add </s> remove         if(i < 2){\n            color = v_color[0];\n            z = bp[0].z;\n        }\n        else if(i == 2){\n            color = v_color[1];\n            z = bp[1].z;\n        }\n        else{\n            color = v_color[2];\n            z = bp[2].z;\n        }", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace keep keep keep keep replace replace keep", "code_tokens": " <mask> #version 330\n <mask> \n <mask> in vec3 point;\n <mask> in vec4 color;\n <mask> // fill_all is 0 or 1\n <mask> in float fill_all;\n <mask> // orientation is +1 for counterclockwise curves, -1 otherwise\n <mask> in float orientation;\n <mask> \n <mask> out vec3 bp;  // Bezier control point\n <mask> out vec4 v_color;\n <mask> out float v_fill_all;\n <mask> out float v_orientation;\n <mask> \n <mask>  </s> remove in float fill_type; </s> add in float fill_all;  // Either 0 or 1e </s> remove in float v_orientation[3]; </s> remove out float fill_type; </s> add out float fill_all; </s> remove in vec2 wz_coords; </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_vert.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep", "code_tokens": " <mask> void main(){\n <mask>     bp = rotate_point_for_frame(point);\n <mask>     v_color = color;\n <mask>     v_fill_all = fill_all;\n <mask>     v_orientation = orientation;\n <mask> } </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove     float fill_all = v_fill_all[0]; </s> remove     float fill_all = v_fill_all[0]; </s> add     fill_all = v_fill_all[0]; </s> remove         fill_type = FILL_ALL; </s> remove out float fill_type; </s> add out float fill_all; </s> remove // fill_all is 0 or 1\nin float fill_all;\n// orientation is +1 for counterclockwise curves, -1 otherwise\nin float orientation; </s> add in float fill_all;  // Either 0 or 1 </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation);", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_fill_vert.glsl"}
{"docstring_tokens": "keep keep replace keep keep replace replace keep keep keep", "code_tokens": " <mask> // while also passing tangency information in the linear case.\n <mask> int get_reduced_control_points(vec2 b0, vec2 b1, vec2 b2, out vec2 new_points[3]){\n <mask>     float epsilon = 1e-6;\n <mask>     vec2 v01 = (b1 - b0);\n <mask>     vec2 v12 = (b2 - b1);\n <mask>     bool distinct_01 = length(v01) > epsilon;  // v01 is considered nonzero\n <mask>     bool distinct_12 = length(v12) > epsilon;  // v12 is considered nonzero\n <mask>     int n_uniques = int(distinct_01) + int(distinct_12);\n <mask>     if(n_uniques == 2){\n <mask>         bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon; </s> Fixed the random-dimples-on-zeros bug while fixing up the fill shaders </s> remove     if(n_uniques == 2){\n        bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n        if(linear){\n            new_points[0] = b0;\n            new_points[1] = b2;\n            return 1;\n        }else{\n            new_points[0] = b0;\n            new_points[1] = b1;\n            new_points[2] = b2;\n            return 2;\n        }\n    }else if(n_uniques == 1){ </s> add     bool quadratic = (n_uniques == 2) && !aligned;\n    bool linear = (n_uniques == 1) || ((n_uniques == 2) && aligned);\n    bool constant = (n_uniques == 0);\n    if(quadratic){\n        new_points[0] = b0;\n        new_points[1] = b1;\n        new_points[2] = b2;\n        return 2;\n    }else if(linear){ </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove \n    // Inside and left turn -> rot right -> -1\n    // Outside and left turn -> rot left -> +1\n    // Inside and right turn -> rot left -> +1\n    // Outside and right turn -> rot right -> -1\n    float c_orient = (cross(t01, t12) > 0) ? 1 : -1;\n    c_orient *= orientation;\n\n    bool fill_in = (c_orient > 0);\n    fill_type = fill_in ? FILL_INSIDE : FILL_OUTSIDE;\n\n    // float orient = in_or_out * c_orient; </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0); </s> remove // wz space is where b0 = (0, 0), b1 = (0.5, 0), b2 = (1, 1)\nout vec2 wz_coords;", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_geometry_functions.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     vec2 v12 = (b2 - b1);\n <mask>     bool distinct_01 = length(v01) > epsilon;  // v01 is considered nonzero\n <mask>     bool distinct_12 = length(v12) > epsilon;  // v12 is considered nonzero\n <mask>     int n_uniques = int(distinct_01) + int(distinct_12);\n <mask>     if(n_uniques == 2){\n <mask>         bool linear = dot(normalize(v01), normalize(v12)) > 1 - epsilon;\n <mask>         if(linear){\n <mask>             new_points[0] = b0;\n <mask>             new_points[1] = b2;\n <mask>             return 1;\n <mask>         }else{\n <mask>             new_points[0] = b0;\n <mask>             new_points[1] = b1;\n <mask>             new_points[2] = b2;\n <mask>             return 2;\n <mask>         }\n <mask>     }else if(n_uniques == 1){\n <mask>         new_points[0] = b0;\n <mask>         new_points[1] = b2;\n <mask>         return 1;\n <mask>     }else{\n <mask>         new_points[0] = b0; </s> remove     bool distinct_01 = length(v01) > epsilon;  // v01 is considered nonzero\n    bool distinct_12 = length(v12) > epsilon;  // v12 is considered nonzero </s> add     // bool aligned = abs(cross(normalize(v01), normalize(v12))) < angle_threshold;\n    bool aligned = acos(dot(normalize(v01), normalize(v12))) < angle_threshold;\n    bool distinct_01 = length(v01) > length_threshold;  // v01 is considered nonzero\n    bool distinct_12 = length(v12) > length_threshold;  // v12 is considered nonzero </s> remove     float epsilon = 1e-6; </s> add     float length_threshold = 1e-6;\n    float angle_threshold = 1e-3; </s> remove \nmat3 get_xy_to_wz(vec2 b0, vec2 b1, vec2 b2){\n    // If linear or null, this matrix is not needed\n    if(bezier_degree < 2) return mat3(1.0);\n\n    vec2 inv_col1 = 2 * (b1 - b0);\n    vec2 inv_col2 = b2 - 2 * b1 + b0;\n    float inv_det = cross(inv_col1, inv_col2);\n\n    mat3 transform = mat3(\n        inv_col2.y, -inv_col1.y, 0,\n        -inv_col2.x, inv_col1.x, 0,\n        0, 0, inv_det\n    ) / inv_det;\n\n    mat3 shift = mat3(\n        1, 0, 0,\n        0, 1, 0,\n        -b0.x, -b0.y, 1\n    );\n    return transform * shift;\n} </s> remove     // if the curve is positively oriented, otherwise\n    // rotate it 90-degrees counterclockwise\n    vec2 n01 = orientation * vec2(t01.y, -t01.x);\n    vec2 n12 = orientation * vec2(t12.y, -t12.x); </s> add     vec2 n01 = vec2(t01.y, -t01.x);\n    vec2 n12 = vec2(t12.y, -t12.x);\n\n    float c_orient = sign(cross(t01, t12));\n    bool fill_in = (c_orient > 0); </s> remove         vec2 new_bp[3];\n        int n = get_reduced_control_points(bp[0].xy, bp[1].xy, bp[2].xy, new_bp);\n        bezier_degree = float(n);\n        float orientation = v_orientation[0];\n\n        vec2 bp0, bp1, bp2;\n        if(n == 0){\n            return;  // Don't emit any vertices\n        }\n        else if(n == 1){\n            bp0 = new_bp[0];\n            bp2 = new_bp[1];\n            bp1 = 0.5 * (bp0 + bp2);\n        }else{\n            bp0 = new_bp[0];\n            bp1 = new_bp[1];\n            bp2 = new_bp[2];\n        }\n\n        emit_pentagon(bp0, bp1, bp2, orientation); </s> remove // Needed for quadratic_bezier_distance </s> add // Needed for quadratic_bezier_distance insertion below", "html_url": "https://github.com/3b1b/manim/commit/00dcc14df1f0c52364789e8873beefbe557ae4b0", "file_name": "manimlib/shaders/quadratic_bezier_geometry_functions.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace", "code_tokens": " <mask> .DS_Store\n <mask> \n <mask> # For manim\n <mask> /videos\n <mask> /custom_defaults.yml\n <mask> /manimlib/defaults.yml </s> rename custom_defaults -> custom_config defaults -> default_config </s> add /custom_config.yml </s> rename custom_defaults -> custom_config defaults -> default_config </s> add /custom_config.yml\n/manimlib/default_config.yml </s> remove         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\") </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\") </s> remove         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": ".gitignore"}
{"docstring_tokens": "keep keep keep add", "code_tokens": " <mask> \n <mask> # For manim\n <mask> /videos\n <mask> /custom_config.yml </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove /custom_defaults.yml\n/manimlib/defaults.yml </s> add </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\") </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": ".gitignore"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             # You can texture a surface with up to two images, which will\n <mask>             # be interpreted as the side towards the light, and away from\n <mask>             # the light.  These can be either urls, or paths to a local file\n <mask>             # in whatever you've set as the image directory in\n <mask>             # the custom_defaults.yml file\n <mask> \n <mask>             # day_texture = \"EarthTextureMap\"\n <mask>             # night_texture = \"NightEarthTextureMap\"\n <mask>             day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n <mask>             night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\" </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove     # See if there's a custom_defaults file in current directory, </s> remove             local_defaults = yaml.safe_load(file) </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config) </s> remove             custom_defaults = yaml.safe_load(file)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "docs/source/getting_started/example_scenes.rst"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         # You can texture a surface with up to two images, which will\n <mask>         # be interpreted as the side towards the light, and away from\n <mask>         # the light.  These can be either urls, or paths to a local file\n <mask>         # in whatever you've set as the image directory in\n <mask>         # the custom_defaults.yml file\n <mask> \n <mask>         # day_texture = \"EarthTextureMap\"\n <mask>         # night_texture = \"NightEarthTextureMap\"\n <mask>         day_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/4/4d/Whole_world_-_land_and_oceans.jpg/1280px-Whole_world_-_land_and_oceans.jpg\"\n <mask>         night_texture = \"https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/The_earth_at_night.jpg/1280px-The_earth_at_night.jpg\"\n </s> rename custom_defaults -> custom_config defaults -> default_config", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "example_scenes.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask>         spec.loader.exec_module(module)\n <mask>         return module\n <mask> \n <mask> \n <mask> def get_custom_defaults():\n <mask>     filename = \"custom_defaults.yml\"\n <mask>     global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\")\n <mask> \n <mask>     if not (os.path.exists(global_defaults_file) or os.path.exists(filename)):\n <mask>         print(\"There is no configuration file detected. Initial configuration:\\n\")\n <mask>         init_customization()\n <mask>  </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove         custom_defaults = get_custom_defaults()\n        SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"]) </s> add         custom_config = get_custom_config()\n        SAVED_TEX_CONFIG.update(custom_config[\"tex\"]) </s> remove         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\") </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\") </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults </s> add     \n    return config </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep replace keep keep replace keep keep keep keep", "code_tokens": " <mask>         with open(global_defaults_file, \"r\") as file:\n <mask>             custom_defaults = yaml.safe_load(file)\n <mask>     else:\n <mask>         with open(filename, \"r\") as file:\n <mask>             local_defaults = yaml.safe_load(file)\n <mask> \n <mask>     # See if there's a custom_defaults file in current directory,\n <mask>     # and if so, it further updates the defaults based on it.\n <mask>     if os.path.exists(filename): </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove     # See if there's a custom_defaults file in current directory, </s> add     # See if there's a custom_config file in current directory, </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove         custom_defaults = get_custom_defaults()\n        SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"]) </s> add         custom_config = get_custom_config()\n        SAVED_TEX_CONFIG.update(custom_config[\"tex\"])", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     else:\n <mask>         with open(filename, \"r\") as file:\n <mask>             local_defaults = yaml.safe_load(file)\n <mask> \n <mask>     # See if there's a custom_defaults file in current directory,\n <mask>     # and if so, it further updates the defaults based on it.\n <mask>     if os.path.exists(filename):\n <mask>         with open(filename, \"r\") as file:\n <mask>             local_defaults = yaml.safe_load(file)\n <mask>         if local_defaults: </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove             local_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file) </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults </s> remove             custom_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file)\n\n        if os.path.exists(filename):\n            with open(filename, \"r\") as file:\n                local_defaults = yaml.safe_load(file)\n            if local_defaults:\n                config = merge_dicts_recursively(\n                    config,\n                    local_defaults,\n                ) </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove             # the custom_defaults.yml file </s> add             # the custom_config.yml file </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace keep keep keep replace keep keep keep", "code_tokens": " <mask>             local_defaults = yaml.safe_load(file)\n <mask> \n <mask>     # See if there's a custom_defaults file in current directory,\n <mask>     # and if so, it further updates the defaults based on it.\n <mask>     if os.path.exists(filename):\n <mask>         with open(filename, \"r\") as file:\n <mask>             local_defaults = yaml.safe_load(file)\n <mask>         if local_defaults:\n <mask>             custom_defaults = merge_dicts_recursively(\n <mask>                 custom_defaults,\n <mask>                 local_defaults,\n <mask>             )\n <mask> \n <mask>     return custom_defaults\n <mask> \n <mask> \n <mask> def get_configuration(args):\n <mask>     custom_defaults = get_custom_defaults()\n <mask> \n <mask>     write_file = any([args.write_file, args.open, args.finder])\n <mask>     if args.transparent: </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove     # See if there's a custom_defaults file in current directory, </s> add     # See if there's a custom_config file in current directory, </s> remove             local_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file) </s> remove             custom_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file)\n\n        if os.path.exists(filename):\n            with open(filename, \"r\") as file:\n                local_defaults = yaml.safe_load(file)\n            if local_defaults:\n                config = merge_dicts_recursively(\n                    config,\n                    local_defaults,\n                ) </s> remove         custom_defaults = get_custom_defaults()\n        SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"]) </s> add         custom_config = get_custom_config()\n        SAVED_TEX_CONFIG.update(custom_config[\"tex\"])", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>         file_ext = \".mp4\"\n <mask> \n <mask>     file_writer_config = {\n <mask>         \"write_to_movie\": not args.skip_animations and write_file,\n <mask>         \"break_into_partial_movies\": custom_defaults[\"break_into_partial_movies\"],\n <mask>         \"save_last_frame\": args.skip_animations and write_file,\n <mask>         \"save_pngs\": args.save_pngs,\n <mask>         # If -t is passed in (for transparent), this will be RGBA\n <mask>         \"png_mode\": \"RGBA\" if args.transparent else \"RGB\",\n <mask>         \"movie_file_extension\": file_ext, </s> remove         \"mirror_module_path\": custom_defaults[\"directories\"][\"mirror_module_path\"],\n        \"output_directory\": args.video_dir or custom_defaults[\"directories\"][\"output\"], </s> add         \"mirror_module_path\": custom_config[\"directories\"][\"mirror_module_path\"],\n        \"output_directory\": args.video_dir or custom_config[\"directories\"][\"output\"], </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config) </s> remove             # the custom_defaults.yml file </s> remove             # the custom_defaults.yml file", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>         \"save_pngs\": args.save_pngs,\n <mask>         # If -t is passed in (for transparent), this will be RGBA\n <mask>         \"png_mode\": \"RGBA\" if args.transparent else \"RGB\",\n <mask>         \"movie_file_extension\": file_ext,\n <mask>         \"mirror_module_path\": custom_defaults[\"directories\"][\"mirror_module_path\"],\n <mask>         \"output_directory\": args.video_dir or custom_defaults[\"directories\"][\"output\"],\n <mask>         \"file_name\": args.file_name,\n <mask>         \"input_file_path\": args.file or \"\",\n <mask>         \"open_file_upon_completion\": args.open,\n <mask>         \"show_file_location_upon_completion\": args.finder,\n <mask>         \"quiet\": args.quiet, </s> remove             # the custom_defaults.yml file </s> remove             # the custom_defaults.yml file </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config) </s> remove         bg_color = args.color or custom_defaults[\"style\"][\"background_color\"] </s> add         bg_color = args.color or custom_config[\"style\"][\"background_color\"]", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     ])\n <mask>     return config\n <mask> \n <mask> \n <mask> def get_camera_configuration(args, custom_defaults):\n <mask>     camera_config = {}\n <mask>     camera_qualities = get_custom_defaults()[\"camera_qualities\"]\n <mask>     if args.low_quality:\n <mask>         quality = camera_qualities[\"low\"]\n <mask>     elif args.medium_quality: </s> remove     camera_qualities = get_custom_defaults()[\"camera_qualities\"] </s> add     camera_qualities = get_custom_config()[\"camera_qualities\"] </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> def get_camera_configuration(args, custom_defaults):\n <mask>     camera_config = {}\n <mask>     camera_qualities = get_custom_defaults()[\"camera_qualities\"]\n <mask>     if args.low_quality:\n <mask>         quality = camera_qualities[\"low\"]\n <mask>     elif args.medium_quality:\n <mask>         quality = camera_qualities[\"medium\"]\n <mask>     elif args.hd: </s> remove def get_camera_configuration(args, custom_defaults): </s> add def get_camera_configuration(args, custom_config): </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> add     config[\"camera_config\"] = get_camera_configuration(args, custom_config)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> class BlankScene(Scene):\n <mask>     def construct(self):\n <mask>         exec(get_custom_defaults()[\"universal_import_line\"])\n <mask>         self.embed()\n <mask> \n <mask> \n <mask> def is_child_scene(obj, module):\n <mask>     if not inspect.isclass(obj): </s> remove def get_camera_configuration(args, custom_defaults): </s> add def get_camera_configuration(args, custom_config): </s> remove     camera_qualities = get_custom_defaults()[\"camera_qualities\"] </s> add     camera_qualities = get_custom_config()[\"camera_qualities\"]", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/extract_scene.py"}
{"docstring_tokens": "keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> import os\n <mask> import tempfile\n <mask> \n <mask> from manimlib.config import get_custom_defaults\n <mask> from manimlib.config import get_manim_dir\n <mask> \n <mask> CUSTOMIZATION = {}\n <mask> \n <mask>  </s> remove from manimlib.config import get_custom_defaults </s> remove from manimlib.config import get_custom_defaults </s> remove         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\") </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\")", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/customization.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> def get_customization():\n <mask>     if not CUSTOMIZATION:\n <mask>         CUSTOMIZATION.update(get_custom_defaults())\n <mask>         directories = CUSTOMIZATION[\"directories\"]\n <mask>         # Unless user has specified otherwise, use the system default temp\n <mask>         # directory for storing tex files, mobject_data, etc.\n <mask>         if not directories[\"temporary_storage\"]:\n <mask>             directories[\"temporary_storage\"] = tempfile.gettempdir() </s> remove def get_custom_defaults():\n    filename = \"custom_defaults.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add def get_custom_config():\n    filename = \"custom_config.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/customization.py"}
{"docstring_tokens": "keep replace keep replace keep keep", "code_tokens": " <mask>         from manimlib.config import get_manim_dir\n <mask>         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\")\n <mask>     else:\n <mask>         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\")\n <mask> \n <mask>     print(\"\\n directories:\") </s> remove from manimlib.config import get_custom_defaults </s> add from manimlib.config import get_custom_config </s> remove from manimlib.config import get_custom_defaults </s> add from manimlib.config import get_custom_config </s> remove def get_custom_defaults():\n    filename = \"custom_defaults.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add def get_custom_config():\n    filename = \"custom_config.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove from manimlib.config import get_custom_defaults </s> add from manimlib.config import get_custom_config </s> remove         custom_defaults = get_custom_defaults()\n        SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"]) </s> add         custom_config = get_custom_config()\n        SAVED_TEX_CONFIG.update(custom_config[\"tex\"])", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/init_config.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> from contextlib import contextmanager\n <mask> \n <mask> from manimlib.utils.directories import get_tex_dir\n <mask> from manimlib.config import get_manim_dir\n <mask> from manimlib.config import get_custom_defaults\n <mask> \n <mask> \n <mask> SAVED_TEX_CONFIG = {}\n <mask> \n <mask>  </s> rename custom_defaults -> custom_config defaults -> default_config </s> remove from manimlib.config import get_custom_defaults </s> add from manimlib.config import get_custom_config </s> remove from manimlib.config import get_custom_defaults </s> add from manimlib.config import get_custom_config </s> remove         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add         file_name = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove         file_name = os.path.join(os.getcwd(), \"custom_defaults.yml\") </s> add         file_name = os.path.join(os.getcwd(), \"custom_config.yml\")", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/tex_file_writing.py"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>     }\n <mask>     \"\"\"\n <mask>     # Only load once, then save thereafter\n <mask>     if not SAVED_TEX_CONFIG:\n <mask>         custom_defaults = get_custom_defaults()\n <mask>         SAVED_TEX_CONFIG.update(custom_defaults[\"tex\"])\n <mask>         # Read in template file\n <mask>         template_filename = os.path.join(\n <mask>             get_manim_dir(), \"manimlib\", \"tex_templates\",\n <mask>             SAVED_TEX_CONFIG[\"template_file\"],\n <mask>         ) </s> remove     if os.path.exists(filename):\n        with open(filename, \"r\") as file:\n            local_defaults = yaml.safe_load(file)\n        if local_defaults:\n            custom_defaults = merge_dicts_recursively(\n                custom_defaults,\n                local_defaults,\n            )\n\n    return custom_defaults </s> remove             custom_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file)\n\n        if os.path.exists(filename):\n            with open(filename, \"r\") as file:\n                local_defaults = yaml.safe_load(file)\n            if local_defaults:\n                config = merge_dicts_recursively(\n                    config,\n                    local_defaults,\n                ) </s> remove     custom_defaults = get_custom_defaults() </s> remove def get_custom_defaults():\n    filename = \"custom_defaults.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"defaults.yml\") </s> add def get_custom_config():\n    filename = \"custom_config.yml\"\n    global_defaults_file = os.path.join(get_manim_dir(), \"manimlib\", \"default_config.yml\") </s> remove     config[\"camera_config\"] = get_camera_configuration(args, custom_defaults) </s> remove             local_defaults = yaml.safe_load(file) </s> add             config = yaml.safe_load(file)", "html_url": "https://github.com/3b1b/manim/commit/00fe33957c8662588a680c64f5bdbf01eda09b88", "file_name": "manimlib/utils/tex_file_writing.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> uniform float reflectiveness;\n <mask> uniform float gloss;\n <mask> uniform float shadow;\n <mask> \n <mask> in vec3 bp[3];\n <mask> \n <mask> in float v_joint_angle[3];\n <mask> in float v_stroke_width[3];\n <mask> in vec4 v_color[3];\n <mask>  </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2]));", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask> #INSERT get_unit_normal.glsl\n <mask> #INSERT finalize_color.glsl\n <mask> \n <mask> \n <mask> void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n <mask>     for(int i = 0; i < 3; i++){\n <mask>         float sf = perspective_scale_factor(points[i].z, focal_distance);\n <mask>         flat_points[i] = sf * points[i].xy;\n <mask>     }\n <mask> }\n <mask> \n <mask> \n <mask> float angle_between_vectors(vec2 v1, vec2 v2){\n <mask>     float v1_norm = length(v1);\n <mask>     float v2_norm = length(v2);\n <mask>     if(v1_norm == 0 || v2_norm == 0) return 0.0;\n <mask>     float dp = dot(v1, v2) / (v1_norm * v2_norm);\n <mask>     float angle = acos(clamp(dp, -1.0, 1.0));\n <mask>     float sn = sign(cross2d(v1, v2));\n <mask>     return sn * angle;\n <mask> }\n <mask> \n <mask> \n <mask> bool find_intersection(vec2 p0, vec2 v0, vec2 p1, vec2 v1, out vec2 intersection){\n <mask>     // Find the intersection of a line passing through\n <mask>     // p0 in the direction v0 and one passing through p1 in\n <mask>     // the direction p1. </s> Minor simplifications for stroke shader </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> add </s> remove     flatten_points(controls, flat_controls); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove     int n_corners = get_corners(flat_controls, degree, scaled_strokes, corners); </s> add     int n_corners = get_corners(flat_controls, int(bezier_degree), scaled_strokes, corners); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     return 5;\n <mask> }\n <mask> \n <mask> \n <mask> void set_adjascent_info(vec2 c0, vec2 tangent,\n <mask>                         int degree,\n <mask>                         vec2 adj[3],\n <mask>                         out float bevel,\n <mask>                         out float angle\n <mask>                         ){\n <mask>     bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n <mask>     angle = angle_between_vectors(c0 - adj[1], tangent);\n <mask>     // Decide on joint type\n <mask>     bool one_linear = (degree == 1 || linear_adj);\n <mask>     bool should_bevel = (\n <mask>         (joint_type == AUTO_JOINT && one_linear) ||\n <mask>         joint_type == BEVEL_JOINT\n <mask>     );\n <mask>     bevel = should_bevel ? 1.0 : 0.0;\n <mask> }\n <mask> \n <mask> \n <mask> void find_joint_info(){\n <mask>     angle_from_prev = v_joint_angle[0];\n <mask>     angle_to_next = v_joint_angle[2];\n <mask>     has_prev = 1.0;\n <mask>     has_next = 1.0; </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     int n_corners = get_corners(flat_controls, degree, scaled_strokes, corners); </s> add     int n_corners = get_corners(flat_controls, int(bezier_degree), scaled_strokes, corners); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    }", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep replace replace replace replace replace replace replace keep keep keep keep replace keep keep keep", "code_tokens": " <mask> \n <mask> \n <mask> void main() {\n <mask>     // Convert control points to a standard form if they are linear or null\n <mask>     vec3 controls[3];\n <mask>     bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n <mask>     if(bezier_degree == 0.0) return;  // Null curve\n <mask>     int degree = int(bezier_degree);\n <mask>     unit_normal = get_unit_normal(controls);\n <mask> \n <mask> \n <mask>     // Adjust stroke width based on distance from the camera\n <mask>     float scaled_strokes[3];\n <mask>     for(int i = 0; i < 3; i++){\n <mask>         float sf = perspective_scale_factor(controls[i].z, focal_distance);\n <mask>         if(bool(flat_stroke)){\n <mask>             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]);\n <mask>             sf *= abs(dot(unit_normal, to_cam)); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove     flatten_points(controls, flat_controls); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove     int n_corners = get_corners(flat_controls, degree, scaled_strokes, corners); </s> add     int n_corners = get_corners(flat_controls, int(bezier_degree), scaled_strokes, corners);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     float scaled_strokes[3];\n <mask>     for(int i = 0; i < 3; i++){\n <mask>         float sf = perspective_scale_factor(controls[i].z, focal_distance);\n <mask>         if(bool(flat_stroke)){\n <mask>             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]);\n <mask>             sf *= abs(dot(unit_normal, to_cam));\n <mask>         }\n <mask>         scaled_strokes[i] = v_stroke_width[i] * sf;\n <mask>     }\n <mask>  </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove     bp = position_point_into_frame(point); </s> add     verts = position_point_into_frame(point);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     // Control points are projected to the xy plane before drawing, which in turn\n <mask>     // gets tranlated to a uv plane.  The z-coordinate information will be remembered\n <mask>     // by what's sent out to gl_Position, and by how it affects the lighting and stroke width\n <mask>     vec2 flat_controls[3];\n <mask>     flatten_points(controls, flat_controls);\n <mask> \n <mask>     // Set joint angles, etc.\n <mask>     find_joint_info();\n <mask> \n <mask>     // Corners of a bounding region around curve </s> Minor simplifications for stroke shader </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove         // vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n        vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z); </s> add         vec3 xyz_coords = vec3(corners[i], verts[index_map[i]].z); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove out vec3 bp; </s> add out vec3 verts; </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     find_joint_info();\n <mask> \n <mask>     // Corners of a bounding region around curve\n <mask>     vec2 corners[5];\n <mask>     int n_corners = get_corners(flat_controls, degree, scaled_strokes, corners);\n <mask> \n <mask>     int index_map[5] = int[5](0, 0, 1, 2, 2);\n <mask>     if(n_corners == 4) index_map[2] = 2;\n <mask> \n <mask>     // Find uv conversion matrix </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove         // vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n        vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z); </s> add         vec3 xyz_coords = vec3(corners[i], verts[index_map[i]].z); </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace replace keep keep keep keep keep", "code_tokens": " <mask>     for(int i = 0; i < n_corners; i++){\n <mask>         uv_coords = (xy_to_uv * vec3(corners[i], 1.0)).xy;\n <mask>         uv_stroke_width = scaled_strokes[index_map[i]] / scale_factor;\n <mask>         // Apply some lighting to the color before sending out.\n <mask>         // vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n <mask>         vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n <mask>         color = finalize_color(\n <mask>             v_color[index_map[i]],\n <mask>             xyz_coords,\n <mask>             unit_normal,\n <mask>             light_source_position, </s> remove     flatten_points(controls, flat_controls); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     bp = position_point_into_frame(point); </s> add     verts = position_point_into_frame(point); </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n}", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>             shadow\n <mask>         );\n <mask>         gl_Position = vec4(\n <mask>             get_gl_Position(vec3(corners[i], 0.0)).xy,\n <mask>             get_gl_Position(controls[index_map[i]]).zw\n <mask>         );\n <mask>         EmitVertex();\n <mask>     }\n <mask>     EndPrimitive();\n <mask> } </s> Minor simplifications for stroke shader </s> remove void set_adjascent_info(vec2 c0, vec2 tangent, </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove     bp = position_point_into_frame(point); </s> add     verts = position_point_into_frame(point); </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance); </s> remove     flatten_points(controls, flat_controls); </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    }", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/geom.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> in float stroke_width;\n <mask> in vec4 color;\n <mask> \n <mask> // Bezier control point\n <mask> out vec3 bp;\n <mask> \n <mask> out float v_joint_angle;\n <mask> out float v_stroke_width;\n <mask> out vec4 v_color;\n <mask>  </s> remove in vec3 bp[3]; </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> add     for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(verts[i].z, focal_distance);\n        flat_controls[i] = sf * verts[i].xy;\n    }\n    // If the curve is flat, put the middle control in the midpoint\n    if (bezier_degree == 1.0){\n        flat_controls[1] = 0.5 * (flat_controls[0] + flat_controls[2]);\n    } </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/vert.glsl"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask> \n <mask> #INSERT position_point_into_frame.glsl\n <mask> \n <mask> void main(){\n <mask>     bp = position_point_into_frame(point);\n <mask> \n <mask>     v_stroke_width = STROKE_WIDTH_CONVERSION * stroke_width * frame_shape[1] / 8.0;\n <mask>     v_joint_angle = joint_angle;\n <mask>     v_color = color;\n <mask> } </s> Minor simplifications for stroke shader </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){ </s> remove void flatten_points(in vec3[3] points, out vec2[3] flat_points){\n    for(int i = 0; i < 3; i++){\n        float sf = perspective_scale_factor(points[i].z, focal_distance);\n        flat_points[i] = sf * points[i].xy;\n    }\n}\n\n\nfloat angle_between_vectors(vec2 v1, vec2 v2){\n    float v1_norm = length(v1);\n    float v2_norm = length(v2);\n    if(v1_norm == 0 || v2_norm == 0) return 0.0;\n    float dp = dot(v1, v2) / (v1_norm * v2_norm);\n    float angle = acos(clamp(dp, -1.0, 1.0));\n    float sn = sign(cross2d(v1, v2));\n    return sn * angle;\n} </s> remove void set_adjascent_info(vec2 c0, vec2 tangent,\n                        int degree,\n                        vec2 adj[3],\n                        out float bevel,\n                        out float angle\n                        ){\n    bool linear_adj = (angle_between_vectors(adj[1] - adj[0], adj[2] - adj[1]) < 1e-3);\n    angle = angle_between_vectors(c0 - adj[1], tangent);\n    // Decide on joint type\n    bool one_linear = (degree == 1 || linear_adj);\n    bool should_bevel = (\n        (joint_type == AUTO_JOINT && one_linear) ||\n        joint_type == BEVEL_JOINT\n    );\n    bevel = should_bevel ? 1.0 : 0.0;\n} </s> remove         // vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z);\n        vec3 xyz_coords = vec3(corners[i], controls[index_map[i]].z); </s> add         vec3 xyz_coords = vec3(corners[i], verts[index_map[i]].z); </s> remove     // Convert control points to a standard form if they are linear or null\n    vec3 controls[3];\n    bezier_degree = get_reduced_control_points(vec3[3](bp[0], bp[1], bp[2]), controls);\n    if(bezier_degree == 0.0) return;  // Null curve\n    int degree = int(bezier_degree);\n    unit_normal = get_unit_normal(controls); </s> add     bezier_degree = (abs(v_joint_angle[1]) < 1e-3) ? 1.0 : 2.0;\n    unit_normal = get_unit_normal(vec3[3](verts[0], verts[1], verts[2])); </s> remove             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - controls[i]); </s> add             vec3 to_cam = normalize(vec3(0.0, 0.0, focal_distance) - verts[i]); </s> remove         float sf = perspective_scale_factor(controls[i].z, focal_distance); </s> add         float sf = perspective_scale_factor(verts[i].z, focal_distance);", "html_url": "https://github.com/3b1b/manim/commit/0136cef1d90f973f6d8f8b6e9f3c521c77b691c7", "file_name": "manimlib/shaders/quadratic_bezier_stroke/vert.glsl"}
{"docstring_tokens": "keep keep keep replace replace replace keep keep keep keep keep", "code_tokens": " <mask> import os\n <mask> import numpy as np\n <mask> \n <mask> \n <mask> GENERALLY_BUFFER_POINTS = True\n <mask> \n <mask> PRODUCTION_QUALITY_DISPLAY_CONFIG = {\n <mask>     \"height\"         : 1440,\n <mask>     \"width\"          : 2560,\n <mask>     \"frame_duration\" : 0.04,\n <mask> } </s> add def adjusted_thickness(thickness, width, height):\n    big_width = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"width\"]\n    big_height = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"height\"]\n    factor = (big_width + big_height) / (width + height)\n    return 1 + (thickness-1)/factor </s> add         \"point_thickness\" : DEFAULT_POINT_THICKNESS,", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "constants.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep keep keep", "code_tokens": " <mask>     \"\"\"\n <mask>     Imagine dragging each pixel around like a paintbrush in\n <mask>     a plus-sign-shaped pixel arrangement surrounding it\n <mask>     \"\"\"\n <mask>     original = np.array(pixel_indices)\n <mask>     original_rgbs = np.array(rgbs)\n <mask>     for nudge in range(-thickness/2+1, thickness/2+1):\n <mask>         if nudge == 0:\n <mask>             continue\n <mask>         for x, y in [[nudge, 0], [0, nudge]]: </s> A few fixes to initial point_thickness implementation </s> add         if nudge == 0:\n            continue </s> remove \nGENERALLY_BUFFER_POINTS = True </s> add def adjusted_thickness(thickness, width, height):\n    big_width = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"width\"]\n    big_height = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"height\"]\n    factor = (big_width + big_height) / (width + height)\n    return 1 + (thickness-1)/factor </s> add         \"point_thickness\" : DEFAULT_POINT_THICKNESS,", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "displayer.py"}
{"docstring_tokens": "keep add keep keep keep keep keep", "code_tokens": " <mask>     original_rgbs = np.array(rgbs)\n <mask>     for nudge in range(-thickness/2+1, thickness/2+1):\n <mask>         for x, y in [[nudge, 0], [0, nudge]]:\n <mask>             pixel_indices = np.append(\n <mask>                 pixel_indices, \n <mask>                 original+[x, y], \n <mask>                 axis = 0 </s> A few fixes to initial point_thickness implementation </s> add     thickness = adjusted_thickness(thickness, width, height) </s> remove         digest_config(self, Mobject1D, kwargs) </s> add         digest_config(self, Mobject2D, kwargs) </s> add def adjusted_thickness(thickness, width, height):\n    big_width = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"width\"]\n    big_height = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"height\"]\n    factor = (big_width + big_height) / (width + height)\n    return 1 + (thickness-1)/factor </s> remove         \"point_thickness\" : 4, </s> add         \"point_thickness\" : DEFAULT_POINT_THICKNESS,", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "displayer.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>                   (pixel_indices[:,0] < width) & \\\n <mask>                   (pixel_indices[:,1] >= 0) & \\\n <mask>                   (pixel_indices[:,1] < height)\n <mask>     return pixel_indices[admissibles], rgbs[admissibles]\n <mask>     \n <mask> \n <mask> def place_on_screen(points, rgbs, space_width, space_height):\n <mask>     \"\"\"\n <mask>     Projects points to 2d space and remove those outside a\n <mask>     the space constraints </s> A few fixes to initial point_thickness implementation </s> add         \"point_thickness\" : DEFAULT_POINT_THICKNESS, </s> add     thickness = adjusted_thickness(thickness, width, height) </s> remove \nGENERALLY_BUFFER_POINTS = True", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "displayer.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     \"\"\"\n <mask>     #Number of numbers used to describe a point (3 for pos, 3 for normal vector)\n <mask>     DEFAULT_CONFIG = {\n <mask>         \"color\" : \"white\",\n <mask>         \"point_thickness\" : 4,\n <mask>         \"name\" : None,\n <mask>     }\n <mask>     DIM = 3\n <mask>     def __init__(self, **kwargs):\n <mask>         digest_config(self, Mobject, kwargs) </s> remove         digest_config(self, Mobject1D, kwargs) </s> add         digest_config(self, Mobject2D, kwargs) </s> add def adjusted_thickness(thickness, width, height):\n    big_width = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"width\"]\n    big_height = PRODUCTION_QUALITY_DISPLAY_CONFIG[\"height\"]\n    factor = (big_width + big_height) / (width + height)\n    return 1 + (thickness-1)/factor </s> add     thickness = adjusted_thickness(thickness, width, height)", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "mobject/mobject.py"}
{"docstring_tokens": "keep keep keep keep replace keep keep keep keep keep", "code_tokens": " <mask>     DEFAULT_CONFIG = {\n <mask>         \"density\" : DEFAULT_POINT_DENSITY_2D,\n <mask>     }\n <mask>     def __init__(self, **kwargs):\n <mask>         digest_config(self, Mobject1D, kwargs)\n <mask>         self.epsilon = 1.0 / self.density\n <mask>         Mobject.__init__(self, **kwargs)\n <mask> \n <mask> class CompoundMobject(Mobject):\n <mask>     def __init__(self, *mobjects): </s> remove \nGENERALLY_BUFFER_POINTS = True", "html_url": "https://github.com/3b1b/manim/commit/014a277a97759bbc0e6ec8fba588bc6e6de65a86", "file_name": "mobject/mobject.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask>         vector_coords = [-1, 2]\n <mask> \n <mask>         vector = self.move_matrix_columns(transposed_matrix, vector_coords)\n <mask>         self.scale_and_add(vector, vector_coords)\n <mask> \n <mask>     def move_matrix_columns(self, transposed_matrix, vector_coords = None):\n <mask>         matrix = np.array(transposed_matrix).transpose()\n <mask>         matrix_mob = Matrix(matrix)\n </s> About to start chapter 5 </s> remove         questions = map(TextMobject, [\n            \"Can you visualize these transformations?\",\n            \"Can you represent them with matrices?\",\n            \"How many rows and columns?\",\n            \"When does it make sense to multiply these matrices?\",\n        ])\n        nums = VMobject(*[\n            TexMobject(\"%d.\"%(num+1))\n            for num in range(len(questions))\n        ])\n        nums.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n        nums.to_edge(LEFT)\n        for num, question in zip(nums.split(), questions):\n            question.scale(0.8)\n            question.next_to(num)\n            self.play(Write(num), FadeIn(question))\n </s> add         questions = VMobject(*map(TextMobject, [\n            \"1. Can you visualize these transformations?\",\n            \"2. Can you represent them with matrices?\",\n            \"3. How many rows and columns?\",\n            \"4. When can you multiply these matrices?\",\n        ]))\n        questions.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n        questions.to_edge(LEFT)\n        for question in questions.split():\n            self.play(Write(question, run_time = 1)) </s> add class ComputerGraphicsAndRobotics(Scene):\n    def construct(self):\n        mob = VMobject(\n            TextMobject(\"Computer graphics\"),\n            TextMobject(\"Robotics\")\n        )\n        mob.arrange_submobjects(DOWN, buff = 1)\n        self.play(Write(mob, run_time = 1))\n        self.dither()\n", "html_url": "https://github.com/3b1b/manim/commit/014b7bfdef961acc4bf1717599b3276a484109d6", "file_name": "eola/chapter3.py"}
{"docstring_tokens": "keep keep keep add keep keep keep keep", "code_tokens": " <mask> \n <mask> class ApplyTwoSuccessiveTransforms(Scene):\n <mask>     pass\n <mask> \n <mask> class ThreeDRotation(Scene):\n <mask>     pass\n <mask> \n <mask> class ThreeDRotationBrokenUp(Scene):\n </s> About to start chapter 5 </s> remove         questions = map(TextMobject, [\n            \"Can you visualize these transformations?\",\n            \"Can you represent them with matrices?\",\n            \"How many rows and columns?\",\n            \"When does it make sense to multiply these matrices?\",\n        ])\n        nums = VMobject(*[\n            TexMobject(\"%d.\"%(num+1))\n            for num in range(len(questions))\n        ])\n        nums.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n        nums.to_edge(LEFT)\n        for num, question in zip(nums.split(), questions):\n            question.scale(0.8)\n            question.next_to(num)\n            self.play(Write(num), FadeIn(question))\n </s> add         questions = VMobject(*map(TextMobject, [\n            \"1. Can you visualize these transformations?\",\n            \"2. Can you represent them with matrices?\",\n            \"3. How many rows and columns?\",\n            \"4. When can you multiply these matrices?\",\n        ]))\n        questions.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n        questions.to_edge(LEFT)\n        for question in questions.split():\n            self.play(Write(question, run_time = 1)) </s> add         self.dither(3)", "html_url": "https://github.com/3b1b/manim/commit/014b7bfdef961acc4bf1717599b3276a484109d6", "file_name": "eola/footnote.py"}
{"docstring_tokens": "keep keep keep keep replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace replace keep keep keep keep keep", "code_tokens": " <mask>     def construct(self):\n <mask>         title = TextMobject(\"Questions to ponder\")\n <mask>         title.highlight(YELLOW).to_edge(UP)\n <mask>         self.add(title)\n <mask>         questions = map(TextMobject, [\n <mask>             \"Can you visualize these transformations?\",\n <mask>             \"Can you represent them with matrices?\",\n <mask>             \"How many rows and columns?\",\n <mask>             \"When does it make sense to multiply these matrices?\",\n <mask>         ])\n <mask>         nums = VMobject(*[\n <mask>             TexMobject(\"%d.\"%(num+1))\n <mask>             for num in range(len(questions))\n <mask>         ])\n <mask>         nums.arrange_submobjects(DOWN, buff = 1, aligned_edge = LEFT)\n <mask>         nums.to_edge(LEFT)\n <mask>         for num, question in zip(nums.split(), questions):\n <mask>             question.scale(0.8)\n <mask>             question.next_to(num)\n <mask>             self.play(Write(num), FadeIn(question))\n <mask>             self.dither()\n <mask> \n <mask> class NextVideo(Scene):\n <mask>     def construct(self):\n <mask>         title = TextMobject(\"\"\"\n </s> About to start chapter 5 </s> add class ComputerGraphicsAndRobotics(Scene):\n    def construct(self):\n        mob = VMobject(\n            TextMobject(\"Computer graphics\"),\n            TextMobject(\"Robotics\")\n        )\n        mob.arrange_submobjects(DOWN, buff = 1)\n        self.play(Write(mob, run_time = 1))\n        self.dither()\n </s> add         self.dither(3)", "html_url": "https://github.com/3b1b/manim/commit/014b7bfdef961acc4bf1717599b3276a484109d6", "file_name": "eola/footnote.py"}